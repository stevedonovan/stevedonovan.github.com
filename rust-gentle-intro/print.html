<!DOCTYPE HTML>
<html lang="en">
    <head>
        <meta charset="UTF-8">
        <title>Pain Points - A Gentle Introduction to Rust</title>
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="Introduction to the Rust language, standard library and ecosystem">
        <meta name="viewport" content="width=device-width, initial-scale=1">

        <base href="">

        <link rel="stylesheet" href="book.css">
        <link href='https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800' rel='stylesheet' type='text/css'>

        <link rel="shortcut icon" href="favicon.png">

        <!-- Font Awesome -->
        <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.3.0/css/font-awesome.min.css">

        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">

        <!-- MathJax -->
        <script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

        <!-- Fetch JQuery from CDN but have a local fallback -->
        <script src="https://code.jquery.com/jquery-2.1.4.min.js"></script>
        <script>
            if (typeof jQuery == 'undefined') {
                document.write(unescape("%3Cscript src='jquery.js'%3E%3C/script%3E"));
            }
        </script>
    </head>
    <body class="light">
        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme = localStorage.getItem('theme');
            if (theme == null) { theme = 'light'; }
            $('body').removeClass().addClass(theme);
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var sidebar = localStorage.getItem('sidebar');
            if (sidebar === "hidden") { $("html").addClass("sidebar-hidden") }
            else if (sidebar === "visible") { $("html").addClass("sidebar-visible") }
        </script>

        <div id="sidebar" class="sidebar">
            <ul class="chapter"><li class="affix"><a href="./readme.html">Introduction</a></li><li><a href="./1-basics.html"><strong>1.</strong> Basics</a></li><li><a href="./2-structs-enums-lifetimes.html"><strong>2.</strong> Structs, Enums and Matching</a></li><li><a href="./3-filesystem.html"><strong>3.</strong> Filesystem and Processes</a></li><li><a href="./4-modules.html"><strong>4.</strong> Modules and Cargo</a></li><li><a href="./5-stdlib-containers.html"><strong>5.</strong> Standard Library Containers</a></li><li><a href="./6-error-handling.html"><strong>6.</strong> Error Handling</a></li><li><a href="./7-shared-and-networking.html"><strong>7.</strong> Threads, Networking and Sharing</a></li><li><a href="./object-orientation.html"><strong>8.</strong> Object-Oriented Programming</a></li><li><a href="./nom-intro.html"><strong>9.</strong> Parsing with Nom</a></li><li><a href="./pain-points.html"><strong>10.</strong> Pain Points</a></li></ul>
        </div>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar" class="menu-bar">
                    <div class="left-buttons">
                        <i id="sidebar-toggle" class="fa fa-bars"></i>
                        <i id="theme-toggle" class="fa fa-paint-brush"></i>
                    </div>

                    <h1 class="menu-title">A Gentle Introduction to Rust</h1>

                    <div class="right-buttons">
                        <i id="print-button" class="fa fa-print" title="Print this book"></i>
                    </div>
                </div>

                <div id="content" class="content">
                    <a class="header" href="print.html#a-gentle-introduction-to-rust" name="a-gentle-introduction-to-rust"><h1>A Gentle Introduction To Rust</h1></a>
<p><img src="PPrustS.png" alt="Rust" /></p>
<p><a href="http://leftoversalad.com/c/015_programmingpeople/">thanks to David Marino</a></p>
<a class="header" href="print.html#why-learn-a-new-programming-language" name="why-learn-a-new-programming-language"><h2>Why learn a new Programming Language?</h2></a>
<p>The aim of this tutorial is to take you to a place where you can read and write
enough Rust to fully appreciate the excellent learning resources available
online, in particular <a href="https://doc.rust-lang.org/stable/book/">The Book</a>.
It's an opportunity to <em>try before you buy</em>, and get enough feeling for the
power of the language to want to go deeper.</p>
<p>As Einstein might have said, &quot;As gentle as possible, but no gentler.&quot;. There is a
lot of new stuff to learn here, and it's different enough to require some
rearrangement of your mental furniture. By 'gentle' I mean that the features are
presented practically with examples; as we encounter difficulties, I hope to
show how Rust solves these problems. It is important to understand the problems before
the solutions make sense. To put it in flowery language, we are going for a hike
in hilly country and I will point out some interesting rock formations on the way,
with only a few geology lectures. There will be some uphill but the view will be
inspiring; the community is unusually pleasant and happy to help.
There is the <a href="https://users.rust-lang.org/">Rust Users Forum</a> and an active
<a href="https://www.reddit.com/r/rust/">subreddit</a> which is unusually well-moderated.
The <a href="https://www.rust-lang.org/en-US/faq.html">FAQ</a> is a good resource if
you have specific questions.</p>
<p>First, why learn a new programming language? It is an investment of time and energy
and that needs some justification. Even if you do not immediately land
a cool job using that language, it stretches the mental muscles and makes you a
better programmer. That seems a poor kind of return-on-investment but if you're
not learning something <em>genuinely</em> new all the time then you will stagnate and be
like the person who has ten years of experience in doing the same thing over and over.</p>
<a class="header" href="print.html#where-rust-shines" name="where-rust-shines"><h2>Where Rust Shines</h2></a>
<p>Rust is a statically and strongly typed systems programming language. <em>statically</em>
means that all types are known at compile-time, <em>strongly</em> means that these types
are designed to make it harder to write incorrect programs. A successful compilation
means you have a much better guarantee of correctness than with a cowboy language
like C. <em>systems</em> means generating the best possible machine code with full control
of memory use.  So the uses are pretty hardcore: operating systems, device drivers
and embedded systems that might not even have an operating system.  However, it's
actually a very pleasant language to write normal application code in as well.</p>
<p>The big difference from C and C++ is that Rust is <em>safe by default</em>; all memory accesses
are checked. It is not possible to corrupt memory by accident.</p>
<p>The unifying principles behind Rust are:</p>
<ul>
<li>strictly enforcing <em>safe borrowing</em> of data</li>
<li>functions, methods and closures to operate on data</li>
<li>tuples, structs and enums to aggregate data</li>
<li>pattern matching to select and destructure data</li>
<li>traits to define <em>behaviour</em> on data</li>
</ul>
<p>There is a fast-growing ecosystem of available libraries through Cargo
but here we will concentrate on the core principles of the language
by learning to use the standard library. My advice is to write <em>lots of small programs</em>,
so learning to use <code>rustc</code> directly is a core skill. When doing the examples in this
tutorial I defined a little script called <code>rrun</code> which does a compilation and runs
the result:</p>
<pre><code>rustc $1.rs &amp;&amp; ./$1
</code></pre>
<a class="header" href="print.html#setting-up" name="setting-up"><h2>Setting Up</h2></a>
<p>This tutorial assumes that you have Rust installed locally. Fortunately this is
<a href="https://www.rust-lang.org/en-US/downloads.html">very straightforward</a>.</p>
<pre><code>$ curl https://sh.rustup.rs -sSf | sh
$ rustup component add rust-docs
</code></pre>
<p>I would recommend getting the default stable version; it's easy to download
unstable versions later and to switch between.</p>
<p>This gets the compiler, the Cargo package manager, the API documentation, and the Rust Book.
The journey of a thousand miles starts with one step, and this first step is painless.</p>
<p><code>rustup</code> is the command you use to manage your Rust installation. When a new stable release
appears, you just have to say <code>rustup update</code> to upgrade. <code>rustup doc</code> will open
the offline documentation in your browser.</p>
<p>You will probably already have an editor you like, and <a href="https://areweideyet.com/">basic Rust support</a>
is good. I'd suggest you start out with basic syntax highlighting at first, and
work up as your programs get larger.</p>
<p>Personally I'm a fan of <a href="https://www.geany.org/Download/Releases">Geany</a> which is
one of the few editors with Rust support out-of-the-box; it's particularly easy
on Linux since it's available through the package manager, but it works fine on
other platforms.</p>
<p>The main thing is knowing how to edit, compile and run Rust programs.
You learn to program with your <em>fingers</em>; type in
the code yourself, and learn to rearrange things efficiently with your editor.</p>
<p>Zed Shaw's <a href="https://learnpythonthehardway.org/book/intro.html">advice</a> about learning
to program in Python remains good, whatever the language. He says learning to program
is like learning a musical instrument - the secret is practice and persistence.
There's also good advice from Yoga and the soft martial arts like Tai Chi;
feel the strain, but don't over-strain. You are not building dumb muscle here.</p>
<p>I'd like to thank the many contributors who caught bad English or bad Rust for me,
and thanks to David Marino for his cool characterization
of Rust as a friendly-but-hardcore no-nonsense knight in shining armour.</p>
<p>Steve Donovan © 2017-2018 MIT license version 0.4.0</p>
<a class="header" href="print.html#basics" name="basics"><h1>Basics</h1></a>
<a class="header" href="print.html#hello-world" name="hello-world"><h2>Hello, World!</h2></a>
<p>The original purpose of &quot;hello world&quot;, ever since the first C version was written,
was to test the compiler and run an actual program.</p>
<pre><pre class="playpen"><code class="language-rust">// hello.rs
fn main() {
    println!(&quot;Hello, World!&quot;);
}
</code></pre></pre>
<pre><code>$ rustc hello.rs
$ ./hello
Hello, World!
</code></pre>
<p>Rust is a curly-braces language with semicolons, C++-style comments and a <code>main</code>
function - so far, so familiar.  The exclamation mark indicates that this is a
<em>macro</em> call. For C++ programmers, this can be a turn-off, since they are used to
seriously stupid C macros - but I can ensure you that these macros are more
capable and sane.</p>
<p>For anybody else,
it's probably &quot;Great, now I have to remember when to say bang!&quot;.  However, the
compiler is unusually helpful; if you leave out that exclamation, you get:</p>
<pre><code>error[E0425]: unresolved name `println`
 --&gt; hello2.rs:2:5
  |
2 |     println(&quot;Hello, World!&quot;);
  |     ^^^^^^^ did you mean the macro `println!`?

</code></pre>
<p>Learning a language means getting comfortable with its errors. Try to see the compiler
as a strict but friendly helper rather than a computer <em>shouting</em> at you, because you are
going to see a lot of red ink in the beginning.  It's much better for the compiler
to catch you out than for your program to blow up in front of actual humans.</p>
<p>The next step is to introduce a <em>variable</em>:</p>
<pre><pre class="playpen"><code class="language-rust">// let1.rs
fn main() {
    let answer = 42;
    println!(&quot;Hello {}&quot;, answer);
}

</code></pre></pre>
<p>Spelling mistakes are <em>compile</em> errors, not runtime errors like with dynamic languages
like Python or JavaScript.  This will save you a lot of stress later! And if I wrote
'answr' instead of 'answer', the compiler is actually <em>nice</em> about it:</p>
<pre><code>4 |     println!(&quot;Hello {}&quot;, answr);
  |                         ^^^^^ did you mean `answer`?

</code></pre>
<p>The <code>println!</code> macro takes a <a href="https://doc.rust-lang.org/std/fmt/index.html">format string</a>
and some values; it's very similar to the formatting used by Python 3.</p>
<p>Another very useful macro is <code>assert_eq!</code>. This is the workhorse of testing
in Rust; you <em>assert</em> that two things must be equal, and if not, <em>panic</em>.</p>
<pre><pre class="playpen"><code class="language-rust">// let2.rs
fn main() {
    let answer = 42;
    assert_eq!(answer,42);
}
</code></pre></pre>
<p>Which won't produce any output. But change 42 to 40:</p>
<pre><code>thread 'main' panicked at
'assertion failed: `(left == right)` (left: `42`, right: `40`)',
let2.rs:4
note: Run with `RUST_BACKTRACE=1` for a backtrace.
</code></pre>
<p>And that's our first <em>runtime error</em> in Rust.</p>
<a class="header" href="print.html#looping-and-ifing" name="looping-and-ifing"><h2>Looping and Ifing</h2></a>
<p>Anything interesting can be done more than once:</p>
<pre><pre class="playpen"><code class="language-rust">// for1.rs
fn main() {
    for i in 0..5 {
        println!(&quot;Hello {}&quot;, i);
    }
}
</code></pre></pre>
<p>The <em>range</em> is not inclusive, so <code>i</code> goes from 0 to 4. This is convenient in a
language which <em>indexes</em> things like arrays from 0.</p>
<p>And interesting things have to be done <em>conditionally</em>:</p>
<pre><pre class="playpen"><code class="language-rust">// for2.rs
fn main() {
    for i in 0..5 {
        if i % 2 == 0 {
            println!(&quot;even {}&quot;, i);
        } else {
            println!(&quot;odd {}&quot;, i);
        }
    }
}
</code></pre></pre>
<pre><code>even 0
odd 1
even 2
odd 3
even 4
</code></pre>
<p><code>i % 2</code> is zero if 2 can divide into <code>i</code> cleanly; Rust uses C-style operators.
There are <em>no</em> brackets around the condition, just like in Go, but
you <em>must</em> use curly brackets around the block.</p>
<p>This does the same, written in a more interesting way:</p>
<pre><pre class="playpen"><code class="language-rust">// for3.rs
fn main() {
    for i in 0..5 {
        let even_odd = if i % 2 == 0 {&quot;even&quot;} else {&quot;odd&quot;};
        println!(&quot;{} {}&quot;, even_odd, i);
    }
}
</code></pre></pre>
<p>Traditionally, programming languages have <em>statements</em> (like <code>if</code>) and
<em>expressions</em> (like <code>1+i</code>). In Rust, nearly everything has a value and can
be an expression.  The seriously ugly C 'ternary operator' <code>i % 2 == 0 ? &quot;even&quot; : &quot;odd&quot;</code>
is not needed.</p>
<p>Note that there aren't any semi-colons in those blocks!</p>
<a class="header" href="print.html#adding-things-up" name="adding-things-up"><h2>Adding Things Up</h2></a>
<p>Computers are very good at arithmetic. Here is a first attempt at adding all
the numbers from 0 to 4:</p>
<pre><pre class="playpen"><code class="language-rust">// add1.rs
fn main() {
    let sum = 0;
    for i in 0..5 {
        sum += i;
    }
    println!(&quot;sum is {}&quot;, sum);
}
</code></pre></pre>
<p>But it fails to compile:</p>
<pre><code>error[E0384]: re-assignment of immutable variable `sum`
 --&gt; add1.rs:5:9
3 |     let sum = 0;
  |         --- first assignment to `sum`
4 |     for i in 0..5 {
5 |         sum += i;
  |         ^^^^^^^^ re-assignment of immutable variable

</code></pre>
<p>'Immutable'? A variable that cannot <em>vary</em>?  <code>let</code> variables by default can only
be assigned a value when declared. Adding the magic word <code>mut</code> (<em>please</em> make
this variable mutable) does the trick:</p>
<pre><pre class="playpen"><code class="language-rust">// add2.rs
fn main() {
    let mut sum = 0;
    for i in 0..5 {
        sum += i;
    }
    println!(&quot;sum is {}&quot;, sum);
}
</code></pre></pre>
<p>This can be puzzling when coming from other languages, where variables can be
re-written by default. What makes something a 'variable' is that it gets assigned
a computed value at run-time - it is not a <em>constant</em>.
It is also how the word is used in mathematics, like when we say
'let n be the largest number in set S'.</p>
<p>There is a reason for declaring variables to be <em>read-only</em> by default. In a larger
program, it gets hard to track where writes are taking place. So Rust makes things
like mutability ('write-ability') explicit. There's a lot of cleverness in the
language, but it tries not to hide anything.</p>
<p>Rust is both statically-typed and strongly-typed - these are often confused, but
think of C (statically but weakly typed) and Python (dynamically but strongly typed).
In static types the type is known at compile time, and dynamic types are only known
at run time.</p>
<p>At the moment, however, it feels like Rust is <em>hiding</em> those types from you. What
exactly is the type of <code>i</code>?  The compiler can work it out, starting with 0,
with <em>type inference</em>, and comes up with <code>i32</code> (four byte signed integer.)</p>
<p>Let's make exactly one change - turn that <code>0</code> into <code>0.0</code>. Then we get errors:</p>
<pre><code>error[E0277]: the trait bound `{float}: std::ops::AddAssign&lt;{integer}&gt;` is not satisfied
 --&gt; add3.rs:5:9
  |
5 |         sum += i;
  |         ^^^^^^^^ the trait `std::ops::AddAssign&lt;{integer}&gt;` is not implemented for `{float}`
  |

</code></pre>
<p>Ok, so the honeymoon is over: what does this mean? Each operator (like <code>+=</code>) corresponds
to a <em>trait</em>, which is like an abstract interface that must be implemented for each concrete type.
We'll deal with traits in detail later, but here all you need to know is that
<code>AddAssign</code> is the name of the trait implementing the <code>+=</code> operator, and the error is saying
that floating point numbers do not implement this operator for integers. (The full list of
operator traits is <a href="https://doc.rust-lang.org/std/ops/index.html">here</a>.)</p>
<p>Again, Rust likes to be explicit - it will not silently convert that integer into a float for you.</p>
<p>We have to <em>cast</em> that value to a floating-point value explicitly.</p>
<pre><pre class="playpen"><code class="language-rust">// add3.rs
fn main() {
    let mut sum = 0.0;
    for i in 0..5 {
        sum += i as f64;
    }
    println!(&quot;sum is {}&quot;, sum);
}
</code></pre></pre>
<a class="header" href="print.html#function-types-are-explicit" name="function-types-are-explicit"><h2>Function Types are Explicit</h2></a>
<p><em>Functions</em> are one place where the compiler will not work out types for you.
And this in fact was a deliberate decision, since languages like Haskell have
such powerful type inference that there are hardly any explicit type names. It's
actually good Haskell style to put in explicit type signatures for functions.
Rust requires this always.</p>
<p>Here is a simple user-defined function:</p>
<pre><pre class="playpen"><code class="language-rust">// fun1.rs

fn sqr(x: f64) -&gt; f64 {
    return x * x;
}

fn main() {
    let res = sqr(2.0);
    println!(&quot;square is {}&quot;, res);
}
</code></pre></pre>
<p>Rust goes back to an
older style of argument declaration, where the type follows the name. This is
how it was done in Algol-derived languages like Pascal.</p>
<p>Again, no integer-to-float conversions - if you replace the <code>2.0</code> with <code>2</code> then we
get a clear error:</p>
<pre><code>8 |     let res = sqr(2);
  |                   ^ expected f64, found integral variable
  |
</code></pre>
<p>You will actually rarely see functions written using a <code>return</code> statement. More
often, it will look like this:</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
# 
#fn main() {
fn sqr(x: f64) -&gt; f64 {
    x * x
}

#}</code></pre></pre>
<p>This is because the body of the function (inside <code>{}</code>) has the value of its
last expression, just like with if-as-an-expression.</p>
<p>Since semicolons are inserted semi-automatically by human fingers, you might add it
here and get the following error:</p>
<pre><code>  |
3 | fn sqr(x: f64) -&gt; f64 {
  |                       ^ expected f64, found ()
  |
  = note: expected type `f64`
  = note:    found type `()`
help: consider removing this semicolon:
 --&gt; fun2.rs:4:8
  |
4 |     x * x;
  |       ^

</code></pre>
<p>The <code>()</code> type is the empty type, nada, <code>void</code>, zilch, nothing. Everything in Rust
has a value, but sometimes it's just nothing.  The compiler knows this is
a common mistake, and actually <em>helps</em> you.  (Anybody who has spent time with a
C++ compiler will know how <em>damn unusual</em> this is.)</p>
<p>A few more examples of this no-return expression style:</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
# 
#fn main() {
// absolute value of a floating-point number
fn abs(x: f64) -&gt; f64 {
    if x &gt; 0.0 {
        x
    } else {
        -x
    }
}

// ensure the number always falls in the given range
fn clamp(x: f64, x1: f64, x2: f64) -&gt; f64 {
    if x &lt; x1 {
        x1
    } else if x &gt; x2 {
        x2
    } else {
        x
    }
}

#}</code></pre></pre>
<p>It's not wrong to use <code>return</code>, but code is cleaner without it. You will still
use <code>return</code> for <em>returning early</em> from a function.</p>
<p>Some operations can be elegantly expressed <em>recursively</em>:</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
# 
#fn main() {
fn factorial(n: u64) -&gt; u64 {
    if n == 0 {
        1
    } else {
        n * factorial(n-1)
    }
}

#}</code></pre></pre>
<p>This can be a little strange at first, and the best thing is then to use pencil and paper
and work out some examples. It isn't usually the most <em>efficient</em> way to do that
operation however.</p>
<p>Values can also be passed by <em>reference</em>. A reference is created by <code>&amp;</code> and <em>dereferenced</em>
by <code>*</code>.</p>
<pre><pre class="playpen"><code class="language-rust">fn by_ref(x: &amp;i32) -&gt; i32{
    *x + 1
}

fn main() {
    let i = 10;
    let res1 = by_ref(&amp;i);
    let res2 = by_ref(&amp;41);
    println!(&quot;{} {}&quot;, res1,res2);
}
// 11 42
</code></pre></pre>
<p>What if you want a function to modify one of its arguments?  Enter <em>mutable references</em>:</p>
<pre><pre class="playpen"><code class="language-rust">// fun4.rs

fn modifies(x: &amp;mut f64) {
    *x = 1.0;
}

fn main() {
    let mut res = 0.0;
    modifies(&amp;mut res);
    println!(&quot;res is {}&quot;, res);
}
</code></pre></pre>
<p>This is more how C would do it than C++. You have to explicitly pass the
reference (with <code>&amp;</code>) and explicitly <em>dereference</em> with <code>*</code>. And then throw in <code>mut</code>
because it's not the default. (I've always felt that C++ references are
too easy to miss compared to C.)</p>
<p>Basically, Rust is introducing some <em>friction</em> here, and not-so-subtly pushing
you towards returning values from functions directly.  Fortunately, Rust has
powerful ways to express things like &quot;operation succeeded and here's the result&quot;
so <code>&amp;mut</code> isn't needed that often. Passing by reference is important when we have a
large object and don't wish to copy it.</p>
<p>The type-after-variable style applies to <code>let</code> as well, when you really want to nail
down the type of a variable:</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
# 
#fn main() {
let bigint: i64 = 0;

#}</code></pre></pre>
<a class="header" href="print.html#learning-where-to-find-the-ropes" name="learning-where-to-find-the-ropes"><h2>Learning Where to Find the Ropes</h2></a>
<p>It's time to start using the documentation. This will be installed on your machine,
and you can use <code>rustup doc --std</code> to open it in a browser.</p>
<p>Note the <em>search</em> field at the top, since this
is going to be your friend; it operates completely offline.</p>
<p>Let's say we want to see where the mathematical
functions are, so search for 'cos'. The first two hits show it defined for both
single and double-precision floating point numbers.  It is defined on the
<em>value itself</em> as a method, like so:</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
# 
#fn main() {
let pi: f64 = 3.1416;
let x = pi/2.0;
let cosine = x.cos();

#}</code></pre></pre>
<p>And the result will be sort-of zero; we obviously need a more authoritative source
of pi-ness!</p>
<p>(Why do we need an explicit <code>f64</code> type? Because without it, the constant could
be either <code>f32</code> or <code>f64</code>, and these are very different.)</p>
<p>Let me quote the example given for <code>cos</code>, but written as a complete program
( <code>assert!</code> is a cousin of <code>assert_eq!</code>; the expression must be true):</p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    let x = 2.0 * std::f64::consts::PI;

    let abs_difference = (x.cos() - 1.0).abs();

    assert!(abs_difference &lt; 1e-10);
}
</code></pre></pre>
<p><code>std::f64::consts::PI</code> is a mouthful! <code>::</code> means much the same as it does in C++,
(often written using '.' in other languages) - it is a <em>fully qualified name</em>. We get
this full name from the second hit on searching for <code>PI</code>.</p>
<p>Up to now, our little Rust programs have been free of all that <code>import</code> and
<code>include</code> stuff that tends to slow down the discussion of 'Hello World' programs.
Let's make this program more readable with a <code>use</code> statement:</p>
<pre><pre class="playpen"><code class="language-rust">use std::f64::consts;

fn main() {
    let x = 2.0 * consts::PI;

    let abs_difference = (x.cos() - 1.0).abs();

    assert!(abs_difference &lt; 1e-10);
}
</code></pre></pre>
<p>Why haven't we needed to do this up to now?
This is because Rust helpfully makes a lot of basic functionality visible without
explicit <code>use</code> statements through the Rust <em>prelude</em>.</p>
<a class="header" href="print.html#arrays-and-slices" name="arrays-and-slices"><h2>Arrays and Slices</h2></a>
<p>All statically-typed languages have <em>arrays</em>, which are values packed nose to tail
in memory. Arrays are <em>indexed</em> from zero:</p>
<pre><pre class="playpen"><code class="language-rust">// array1.rs
fn main() {
    let arr = [10, 20, 30, 40];
    let first = arr[0];
    println!(&quot;first {}&quot;, first);

    for i in 0..4 {
        println!(&quot;[{}] = {}&quot;, i,arr[i]);
    }
    println!(&quot;length {}&quot;, arr.len());
}
</code></pre></pre>
<p>And the output is:</p>
<pre><code>first 10
[0] = 10
[1] = 20
[2] = 30
[3] = 40
length 4
</code></pre>
<p>In this case, Rust knows <em>exactly</em> how big the array is and if you try to
access <code>arr[4]</code> it will be a <em>compile error</em>.</p>
<p>Learning a new language often involves <em>unlearning</em> mental habits from languages
you already know; if you are a Pythonista, then those brackets say <code>List</code>. We will
come to the Rust equivalent of <code>List</code> soon, but arrays are not the droids you're looking
for; they are <em>fixed in size</em>. They can be <em>mutable</em> (if we ask nicely) but you
cannot add new elements.</p>
<p>Arrays are not used that often in Rust, because the type of an array includes its
size.  The type of the array in the example is
<code>[i32; 4]</code>; the type of <code>[10, 20]</code> would be <code>[i32; 2]</code> and so forth: they
have <em>different types</em>.  So they are bastards to pass around as
function arguments.</p>
<p>What <em>are</em> used often are <em>slices</em>. You can think of these as <em>views</em> into
an underlying array of values. They otherwise behave very much like an array, and
<em>know their size</em>, unlike those dangerous animals C pointers.</p>
<p>Note two important things here - how to write a slice's type, and that
you have to use <code>&amp;</code> to pass it to the function.</p>
<pre><pre class="playpen"><code class="language-rust">// array2.rs
// read as: slice of i32
fn sum(values: &amp;[i32]) -&gt; i32 {
    let mut res = 0;
    for i in 0..values.len() {
        res += values[i]
    }
    res
}

fn main() {
    let arr = [10,20,30,40];
    // look at that &amp;
    let res = sum(&amp;arr);
    println!(&quot;sum {}&quot;, res);
}
</code></pre></pre>
<p>Ignore the code of <code>sum</code> for a while, and look at <code>&amp;[i32]</code>. The relationship between
Rust arrays and slices is similar to that between C arrays and pointers, except for
two important differences - Rust slices keep track of their size (and will
panic if you try to access outside that size) and you have to explicitly say that
you want to pass an array as a slice using the <code>&amp;</code> operator.</p>
<p>A C programmer pronounces <code>&amp;</code> as 'address of'; a Rust programmer pronounces it
'borrow'. This is going to be the key word when learning Rust. Borrowing is the name
given to a common pattern in programming; whenever you pass something by reference
(as nearly always happens in dynamic languages) or pass a pointer in C. Anything
borrowed remains owned by the original owner.</p>
<a class="header" href="print.html#slicing-and-dicing" name="slicing-and-dicing"><h2>Slicing and Dicing</h2></a>
<p>You cannot print out an array in the usual way with <code>{}</code> but you can do a <em>debug</em>
print with <code>{:?}</code>.</p>
<pre><pre class="playpen"><code class="language-rust">// array3.rs
fn main() {
    let ints = [1, 2, 3];
    let floats = [1.1, 2.1, 3.1];
    let strings = [&quot;hello&quot;, &quot;world&quot;];
    let ints_ints = [[1, 2], [10, 20]];
    println!(&quot;ints {:?}&quot;, ints);
    println!(&quot;floats {:?}&quot;, floats);
    println!(&quot;strings {:?}&quot;, strings);
    println!(&quot;ints_ints {:?}&quot;, ints_ints);
}
</code></pre></pre>
<p>Which gives:</p>
<pre><code>ints [1, 2, 3]
floats [1.1, 2.1, 3.1]
strings [&quot;hello&quot;, &quot;world&quot;]
ints_ints [[1, 2], [10, 20]]
</code></pre>
<p>So, arrays of arrays are no problem, but the important thing is that an array contains
values of <em>only one type</em>.  The values in an array are arranged next to each other
in memory so that they are <em>very</em> efficient to access.</p>
<p>If you are curious about the actual types of these variables, here is a useful trick.
Just declare a variable with an explicit type which you know will be wrong:</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
# 
#fn main() {
let var: () = [1.1, 1.2];

#}</code></pre></pre>
<p>Here is the informative error:</p>
<pre><code>3 |     let var: () = [1.1, 1.2];
  |                   ^^^^^^^^^^ expected (), found array of 2 elements
  |
  = note: expected type `()`
  = note:    found type `[{float}; 2]`
</code></pre>
<p>(<code>{float}</code> means 'some floating-point type which is not fully specified yet')</p>
<p>Slices give you different <em>views</em> of the <em>same</em> array:</p>
<pre><pre class="playpen"><code class="language-rust">// slice1.rs
fn main() {
    let ints = [1, 2, 3, 4, 5];
    let slice1 = &amp;ints[0..2];
    let slice2 = &amp;ints[1..];  // open range!

    println!(&quot;ints {:?}&quot;, ints);
    println!(&quot;slice1 {:?}&quot;, slice1);
    println!(&quot;slice2 {:?}&quot;, slice2);
}
</code></pre></pre>
<pre><code>ints [1, 2, 3, 4, 5]
slice1 [1, 2]
slice2 [2, 3, 4, 5]
</code></pre>
<p>This is a neat notation which looks similar to Python slices but with a big difference:
a copy of the data is never made.  These slices all <em>borrow</em> their data from their
arrays. They have a very intimate relationship with that array, and Rust spends a lot
of effort to make sure that relationship does not break down.</p>
<a class="header" href="print.html#optional-values" name="optional-values"><h2>Optional Values</h2></a>
<p>Slices, like arrays, can be <em>indexed</em>. Rust knows the size of an array at
compile-time, but the size of a slice is only known at run-time. So <code>s[i]</code> can
cause an out-of-bounds error when running and will <em>panic</em>.  This is really not
what you want to happen - it can be the difference between a safe launch abort and
scattering pieces of a very expensive satellite all over Florida. And there are
<em>no exceptions</em>.</p>
<p>Let that sink in, because it comes as a shock. You cannot wrap dodgy-may-panic
code in some try-block and 'catch the error' - at least not in a way you'd want to use
every day. So how can Rust be safe?</p>
<p>There is a slice method <code>get</code> which does not panic. But what does it return?</p>
<pre><pre class="playpen"><code class="language-rust">// slice2.rs
fn main() {
    let ints = [1, 2, 3, 4, 5];
    let slice = &amp;ints;
    let first = slice.get(0);
    let last = slice.get(5);

    println!(&quot;first {:?}&quot;, first);
    println!(&quot;last {:?}&quot;, last);
}
// first Some(1)
// last None
</code></pre></pre>
<p><code>last</code> failed (we forgot about zero-based indexing), but returned something called <code>None</code>.
<code>first</code> is fine, but appears as a value wrapped in <code>Some</code>.  Welcome to the <code>Option</code>
type!  It may be <em>either</em> <code>Some</code> or <code>None</code>.</p>
<p>The <code>Option</code> type has some useful methods:</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
# 
#fn main() {
    println!(&quot;first {} {}&quot;, first.is_some(), first.is_none());
    println!(&quot;last {} {}&quot;, last.is_some(), last.is_none());
    println!(&quot;first value {}&quot;, first.unwrap());

// first true false
// last false true
// first value 1

#}</code></pre></pre>
<p>If you were to <em>unwrap</em> <code>last</code>, you would get a panic. But at least you can call
<code>is_some</code> first to make sure - for instance, if you had a distinct no-value default:</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
# 
#fn main() {
    let maybe_last = slice.get(5);
    let last = if maybe_last.is_some() {
        *maybe_last.unwrap()
    } else {
        -1
    };

#}</code></pre></pre>
<p>Note the <code>*</code> - the precise type inside the <code>Some</code> is <code>&amp;i32</code>, which is a reference. We need
to dereference this to get back to a <code>i32</code> value.</p>
<p>Which is long-winded, so there's a shortcut - <code>unwrap_or</code> will return the value it
is given if the <code>Option</code> was <code>None</code>. The types must match up - <code>get</code> returns
a reference. so you have to make up a <code>&amp;i32</code> with <code>&amp;-1</code>. Finally, again use <code>*</code>
to get the value as <code>i32</code>.</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
# 
#fn main() {
    let last = *slice.get(5).unwrap_or(&amp;-1);

#}</code></pre></pre>
<p>It's easy to miss the <code>&amp;</code>, but the compiler has your back here. If it was <code>-1</code>,
<code>rustc</code> says 'expected &amp;{integer}, found integral variable' and then
'help: try with <code>&amp;-1</code>'.</p>
<p>You can think of <code>Option</code> as a box which may contain a value, or nothing (<code>None</code>).
(It is called <code>Maybe</code> in Haskell). It may contain <em>any</em> kind of value, which is
its <em>type parameter</em>. In this case, the full type is <code>Option&lt;&amp;i32&gt;</code>, using
C++-style notation for <em>generics</em>.  Unwrapping this box may cause an explosion,
but unlike Schroedinger's Cat, we can know in advance if it contains a value.</p>
<p>It is very common for Rust functions/methods to return such maybe-boxes, so learn
how to <a href="https://doc.rust-lang.org/std/option/enum.Option.html">use them</a> comfortably.</p>
<a class="header" href="print.html#vectors" name="vectors"><h2>Vectors</h2></a>
<p>We'll return to slice methods again, but first: vectors. These are <em>re-sizeable</em>
arrays and behave much like Python <code>List</code> and C++ <code>std::vector</code>. The Rust type
<code>Vec</code> (pronounced 'vector') behaves very much like an slice in fact; the
difference is that you can append extra values to a vector - note that it must
be declared as mutable.</p>
<pre><pre class="playpen"><code class="language-rust">// vec1.rs
fn main() {
    let mut v = Vec::new();
    v.push(10);
    v.push(20);
    v.push(30);

    let first = v[0];  // will panic if out-of-range
    let maybe_first = v.get(0);

    println!(&quot;v is {:?}&quot;, v);
    println!(&quot;first is {}&quot;, first);
    println!(&quot;maybe_first is {:?}&quot;, maybe_first);
}
// v is [10, 20, 30]
// first is 10
// maybe_first is Some(10)
</code></pre></pre>
<p>A common beginner mistake is to forget the <code>mut</code>; you will get a helpful error
message:</p>
<pre><code>3 |     let v = Vec::new();
  |         - use `mut v` here to make mutable
4 |     v.push(10);
  |     ^ cannot borrow mutably
</code></pre>
<p>There is a very intimate relation between vectors and slices:</p>
<pre><pre class="playpen"><code class="language-rust">// vec2.rs
fn dump(arr: &amp;[i32]) {
    println!(&quot;arr is {:?}&quot;, arr);
}

fn main() {
    let mut v = Vec::new();
    v.push(10);
    v.push(20);
    v.push(30);

    dump(&amp;v);

    let slice = &amp;v[1..];
    println!(&quot;slice is {:?}&quot;, slice);
}
</code></pre></pre>
<p>That little, so-important borrow operator <code>&amp;</code> is <em>coercing</em> the vector into a
slice. And it makes complete sense, because the vector is also looking after an array of
values, with the difference that the array is allocated <em>dynamically</em>.</p>
<p>If you come from a dynamic language, now is time for that little talk. In systems
languages, program memory comes in two kinds: the stack and the heap. It is very fast
to allocate data on the stack, but the stack is limited; typically of the order of
megabytes. The heap can be gigabytes, but allocating is relatively expensive, and
such memory must be <em>freed</em> later. In so-called 'managed' languages (like Java, Go
and the so-called 'scripting' languages) these details are hidden from you by that
convenient municipal utility called the <em>garbage collector</em>. Once the system is sure
that data is no longer referenced by other data, it goes back into the pool
of available memory.</p>
<p>Generally, this is a price worth paying. Playing with the stack is terribly unsafe,
because if you make one mistake you can override the return address of the current
function, and you die an ignominious death or (worse) got pwned by some guy living
in his Mom's basement in Minsk.</p>
<p>The first C program I wrote (on an DOS PC)
took out the whole computer. Unix systems always behaved better, and only the process died
with a <em>segfault</em>. Why is this worse than a Rust (or Go) program panicking?
Because a panic happens when the original problem happens, not when the program
has become hopelessly confused and eaten all your homework. Panics are <em>memory safe</em>
because they happen before any illegal access to memory. This is a common cause of
security problems in C, because all memory accesses are unsafe and a cunning attacker
can exploit this weakness.</p>
<p>Panicking sounds desperate and unplanned, but Rust panics are structured - the stack is <em>unwound</em>
just as with exceptions. All allocated objects are dropped, and a backtrace is generated.</p>
<p>The downsides of garbage collection? The first is that it is wasteful of memory, which
matters in those small embedded microchips which increasingly rule our world. The
second is that it will decide, at the worst possible time, that a clean up must happen
<em>now</em>. (The Mom analogy is that she wants to clean your room when you are at a
delicate stage with a new lover). Those embedded systems need to respond to things
<em>when they happen</em> ('real-time') and can't tolerate unscheduled outbreaks of
cleaning. Roberto Ierusalimschy, the chief designer of Lua (one of the most elegant
dynamic languages ever) said that he would not like to fly on an airplane that
relied on garbage-collected software.</p>
<p>Back to vectors: when a vector is modified or created, it allocates from the heap and becomes
the <em>owner</em> of that memory. The slice <em>borrows</em> the memory from the vector.
When the vector dies or <em>drops</em>, it lets the memory go.</p>
<a class="header" href="print.html#iterators" name="iterators"><h2>Iterators</h2></a>
<p>We have got so far without mentioning a key part of the Rust puzzle - iterators.
The for-loop over a range was using an iterator (<code>0..n</code> is actually similar to the
Python 3 <code>range</code> function).</p>
<p>An iterator is easy to define informally. It is an 'object' with a <code>next</code> method
which returns an <code>Option</code>. As long as that value is not <code>None</code>, we keep calling
<code>next</code>:</p>
<pre><pre class="playpen"><code class="language-rust">// iter1.rs
fn main() {
    let mut iter = 0..3;
    assert_eq!(iter.next(), Some(0));
    assert_eq!(iter.next(), Some(1));
    assert_eq!(iter.next(), Some(2));
    assert_eq!(iter.next(), None);
}
</code></pre></pre>
<p>And that is exactly what <code>for var in iter {}</code> does.</p>
<p>This may seem an inefficient way to define a for-loop, but <code>rustc</code> does crazy-ass
optimizations in release mode and it will be just as fast as a <code>while</code> loop.</p>
<p>Here is the first attempt to iterate over an array:</p>
<pre><pre class="playpen"><code class="language-rust">// iter2.rs
fn main() {
    let arr = [10, 20, 30];
    for i in arr {
        println!(&quot;{}&quot;, i);
    }
}
</code></pre></pre>
<p>which fails, but helpfully:</p>
<pre><code>4 |     for i in arr {
  |     ^ the trait `std::iter::Iterator` is not implemented for `[{integer}; 3]`
  |
  = note: `[{integer}; 3]` is not an iterator; maybe try calling
   `.iter()` or a similar method
  = note: required by `std::iter::IntoIterator::into_iter`
</code></pre>
<p>Following <code>rustc</code>'s advice, the following program works as expected.</p>
<pre><pre class="playpen"><code class="language-rust">// iter3.rs
fn main() {
    let arr = [10, 20, 30];
    for i in arr.iter() {
        println!(&quot;{}&quot;, i);
    }

    // slices will be converted implicitly to iterators...
    let slice = &amp;arr;
    for i in slice {
        println!(&quot;{}&quot;, i);
    }
}
</code></pre></pre>
<p>In fact, it is more efficient to iterate over an array or slice this way
than to use <code>for i in 0..slice.len() {}</code> because Rust does not have to obsessively
check every index operation.</p>
<p>We had an example of summing up a range of integers earlier. It involved a <code>mut</code>
variable and a loop. Here's the <em>idiomatic</em>, pro-level way of doing the sum:</p>
<pre><pre class="playpen"><code class="language-rust">// sum1.rs
fn main() {
    let sum: i32  = (0..5).sum();
    println!(&quot;sum was {}&quot;, sum);

    let sum: i64 = [10, 20, 30].iter().sum();
    println!(&quot;sum was {}&quot;, sum);
}
</code></pre></pre>
<p>Note that this is one of those cases where you need to be explicit about
the <em>type</em> of the variable, since otherwise Rust doesn't have enough information.
Here we do sums with two different integer sizes, no problem. (It is also no
problem to create a new variable of the same name if you run out of names to
give things.)</p>
<p>With this background, some more of the <a href="https://doc.rust-lang.org/std/primitive.slice.html">slice methods</a>
will make more sense.
(Another documentation tip; on the right-hand side of every doc page there's a '[-]' which you can
click to collapse the method list. You can then expand the details of anything
that looks interesting. Anything that looks too weird, just ignore for now.)</p>
<p>The <code>windows</code> method gives you an iterator of slices - overlapping windows of
values!</p>
<pre><pre class="playpen"><code class="language-rust">// slice4.rs
fn main() {
    let ints = [1, 2, 3, 4, 5];
    let slice = &amp;ints;

    for s in slice.windows(2) {
        println!(&quot;window {:?}&quot;, s);
    }
}
// window [1, 2]
// window [2, 3]
// window [3, 4]
// window [4, 5]
</code></pre></pre>
<p>Or <code>chunks</code>:</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
# 
#fn main() {
    for s in slice.chunks(2) {
        println!(&quot;chunks {:?}&quot;, s);
    }
// chunks [1, 2]
// chunks [3, 4]
// chunks [5]

#}</code></pre></pre>
<a class="header" href="print.html#more-about-vectors" name="more-about-vectors"><h2>More about vectors...</h2></a>
<p>There is a useful little macro <code>vec!</code> for initializing a vector. Note that you
can <em>remove</em> values from the end of a vector using <code>pop</code>, and <em>extend</em> a vector
using any compatible iterator.</p>
<pre><pre class="playpen"><code class="language-rust">// vec3.rs
fn main() {
    let mut v1 = vec![10, 20, 30, 40];
    v1.pop();

    let mut v2 = Vec::new();
    v2.push(10);
    v2.push(20);
    v2.push(30);

    assert_eq!(v1, v2);

    v2.extend(0..2);
    assert_eq!(v2, &amp;[10, 20, 30, 0, 1]);
}
</code></pre></pre>
<p>Vectors compare with each other and with slices by value.</p>
<p>You can insert values into a vector at arbitrary positions with <code>insert</code>,
and remove with <code>remove</code>. This is not as efficient as pushing and popping since
the values will have to be moved to make room, so watch out for these operations on big
vectors.</p>
<p>Vectors have a size and a <em>capacity</em>. If you <code>clear</code> a vector, its size becomes zero,
but it still retains its old capacity. So refilling it with <code>push</code>, etc only requires
reallocation when the size gets larger than that capacity.</p>
<p>Vectors can be sorted, and then duplicates can be removed - these operate in-place
on the vector. (If you want to make a copy first, use <code>clone</code>.)</p>
<pre><pre class="playpen"><code class="language-rust">// vec4.rs
fn main() {
    let mut v1 = vec![1, 10, 5, 1, 2, 11, 2, 40];
    v1.sort();
    v1.dedup();
    assert_eq!(v1, &amp;[1, 2, 5, 10, 11, 40]);
}
</code></pre></pre>
<a class="header" href="print.html#strings" name="strings"><h2>Strings</h2></a>
<p>Strings in Rust are a little more involved than in other languages; the <code>String</code> type,
like <code>Vec</code>, allocates dynamically and is resizeable. (So it's like C++'s <code>std::string</code>
but not like the immutable strings of Java and Python.) But a program may contain a lot
of <em>string literals</em> (like &quot;hello&quot;) and a system language should be able to store
these statically in the executable itself. In embedded micros, that could mean putting
them in cheap ROM rather than expensive RAM (for low-power devices, RAM is
also expensive in terms of power consumption.) A <em>system</em> language has to have
two kinds of string, allocated or static.</p>
<p>So &quot;hello&quot; is not of type <code>String</code>. It is of type <code>&amp;str</code> (pronounced 'string slice').
It's like the distinction between <code>const char*</code> and <code>std::string</code> in C++, except
<code>&amp;str</code> is much more intelligent.  In fact, <code>&amp;str</code> and <code>String</code> have a very
similar relationship to each other as do <code>&amp;[T]</code> to <code>Vec&lt;T&gt;</code>.</p>
<pre><pre class="playpen"><code class="language-rust">// string1.rs
fn dump(s: &amp;str) {
    println!(&quot;str '{}'&quot;, s);
}

fn main() {
    let text = &quot;hello dolly&quot;;  // the string slice
    let s = text.to_string();  // it's now an allocated string

    dump(text);
    dump(&amp;s);
}
</code></pre></pre>
<p>Again, the borrow operator can coerce <code>String</code> into <code>&amp;str</code>, just as <code>Vec&lt;T&gt;</code> could
be coerced into <code>&amp;[T]</code>.</p>
<p>Under the hood, <code>String</code> is basically a <code>Vec&lt;u8&gt;</code> and <code>&amp;str</code> is <code>&amp;[u8]</code>, but
those bytes <em>must</em> represent valid UTF-8 text.</p>
<p>Like a vector, you can <code>push</code> a character and <code>pop</code> one off the end of <code>String</code>:</p>
<pre><pre class="playpen"><code class="language-rust">// string5.rs
fn main() {
    let mut s = String::new();
    // initially empty!
    s.push('H');
    s.push_str(&quot;ello&quot;);
    s.push(' ');
    s += &quot;World!&quot;; // short for `push_str`
    // remove the last char
    s.pop();

    assert_eq!(s, &quot;Hello World&quot;);
}
</code></pre></pre>
<p>You can convert many types to strings using <code>to_string</code>
(if you can display them with '{}' then they can be converted).
The <code>format!</code> macro is a very useful way to build
up more complicated strings using the same format strings as <code>println!</code>.</p>
<pre><pre class="playpen"><code class="language-rust">// string6.rs
fn array_to_str(arr: &amp;[i32]) -&gt; String {
    let mut res = '['.to_string();
    for v in arr {
        res += &amp;v.to_string();
        res.push(',');
    }
    res.pop();
    res.push(']');
    res
}

fn main() {
    let arr = array_to_str(&amp;[10, 20, 30]);
    let res = format!(&quot;hello {}&quot;, arr);

    assert_eq!(res, &quot;hello [10,20,30]&quot;);
}
</code></pre></pre>
<p>Note the <code>&amp;</code> in front of <code>v.to_string()</code> - the operator is defined on a string
slice, not a <code>String</code> itself, so it needs a little persuasion to match.</p>
<p>The notation used for slices works with strings as well:</p>
<pre><pre class="playpen"><code class="language-rust">// string2.rs
fn main() {
    let text = &quot;static&quot;;
    let string = &quot;dynamic&quot;.to_string();

    let text_s = &amp;text[1..];
    let string_s = &amp;string[2..4];

    println!(&quot;slices {:?} {:?}&quot;, text_s, string_s);
}
// slices &quot;tatic&quot; &quot;na&quot;
</code></pre></pre>
<p>But, you cannot index strings!  This is because they use the One True Encoding,
UTF-8, where a 'character' may be a number of bytes.</p>
<pre><pre class="playpen"><code class="language-rust">// string3.rs
fn main() {
    let multilingual = &quot;Hi! ¡Hola! привет!&quot;;
    for ch in multilingual.chars() {
        print!(&quot;'{}' &quot;, ch);
    }
    println!(&quot;&quot;);
    println!(&quot;len {}&quot;, multilingual.len());
    println!(&quot;count {}&quot;, multilingual.chars().count());

    let maybe = multilingual.find('п');
    if maybe.is_some() {
        let hi = &amp;multilingual[maybe.unwrap()..];
        println!(&quot;Russian hi {}&quot;, hi);
    }
}
// 'H' 'i' '!' ' ' '¡' 'H' 'o' 'l' 'a' '!' ' ' 'п' 'р' 'и' 'в' 'е' 'т' '!'
// len 25
// count 18
// Russian hi привет!
</code></pre></pre>
<p>Now, let that sink in - there are 25 bytes, but only 18 characters! However, if
you use a method like <code>find</code>, you will get a valid index (if found) and then
any slice will be fine.</p>
<p>(The Rust <code>char</code> type is a 4-byte Unicode code point. Strings are <em>not</em> arrays
of chars!)</p>
<p>String slicing may explode like vector indexing, because it uses byte offsets. In this case,
the string consists of two bytes, so trying to pull out the first byte is a Unicode error. So be
careful to only slice strings using valid offsets that come from string methods.</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
# 
#fn main() {
    let s = &quot;¡&quot;;
    println!(&quot;{}&quot;, &amp;s[0..1]); &lt;-- bad, first byte of a multibyte character

#}</code></pre></pre>
<p>Breaking up strings is a popular and useful pastime. The string <code>split_whitespace</code>
method returns an <em>iterator</em>, and we then choose what to do with it. A common need
is to create a vector of the split substrings.</p>
<p><code>collect</code> is very general and so needs some clues about <em>what</em> it is collecting - hence
the explicit type.</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
# 
#fn main() {
    let text = &quot;the red fox and the lazy dog&quot;;
    let words: Vec&lt;&amp;str&gt; = text.split_whitespace().collect();
    // [&quot;the&quot;, &quot;red&quot;, &quot;fox&quot;, &quot;and&quot;, &quot;the&quot;, &quot;lazy&quot;, &quot;dog&quot;]

#}</code></pre></pre>
<p>You could also say it like this, passing the iterator into the <code>extend</code> method:</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
# 
#fn main() {
    let mut words = Vec::new();
    words.extend(text.split_whitespace());

#}</code></pre></pre>
<p>In most languages, we would have to make these <em>separately allocated strings</em>,
whereas here each slice in the vector is borrowing from the original string.
All we allocate is the space to keep the slices.</p>
<p>Have a look at this cute two-liner; we get an iterator over the chars,
and only take those characters which are not space. Again, <code>collect</code> needs
a clue (we may have wanted a vector of chars, say):</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
# 
#fn main() {
    let stripped: String = text.chars()
        .filter(|ch| ! ch.is_whitespace()).collect();
    // theredfoxandthelazydog

#}</code></pre></pre>
<p>The <code>filter</code> method takes a <em>closure</em>, which is Rust-speak for
lambdas or anonymous functions.  Here the argument type is clear from the
context, so the explicit rule is relaxed.</p>
<p>Yes, you can do this as an explicit loop over chars, pushing the returned slices
into a mutable vector, but this is shorter, reads well (<em>when</em> you are used to it,
of course) and just as fast. It is not a <em>sin</em> to use a loop, however, and I encourage
you to write that version as well.</p>
<a class="header" href="print.html#interlude-getting-command-line-arguments" name="interlude-getting-command-line-arguments"><h2>Interlude: Getting Command Line Arguments</h2></a>
<p>Up to now our programs have lived in blissful ignorance of the outside world; now
it's time to feed them data.</p>
<p><code>std::env::args</code> is how you access command-line arguments; it returns an iterator
over the arguments as strings, including the program name.</p>
<pre><pre class="playpen"><code class="language-rust">// args0.rs
fn main() {
    for arg in std::env::args() {
        println!(&quot;'{}'&quot;, arg);
    }
}
</code></pre></pre>
<pre><code>src$ rustc args0.rs
src$ ./args0 42 'hello dolly' frodo
'./args0'
'42'
'hello dolly'
'frodo'
</code></pre>
<p>Would it have been better to return a <code>Vec</code>? It's easy enough to use <code>collect</code> to
make that vector, using the iterator <code>skip</code> method to move past the program
name.</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
# 
#fn main() {
    let args: Vec&lt;String&gt; = std::env::args().skip(1).collect();
    if args.len() &gt; 0 { // we have args!
        ...
    }

#}</code></pre></pre>
<p>Which is fine; it's pretty much how you would do it in most languages.</p>
<p>A more Rust-y approach to reading a single argument (together with parsing an
integer value):</p>
<pre><pre class="playpen"><code class="language-rust">// args1.rs
use std::env;

fn main() {
    let first = env::args().nth(1).expect(&quot;please supply an argument&quot;);
    let n: i32 = first.parse().expect(&quot;not an integer!&quot;);
    // do your magic
}
</code></pre></pre>
<p><code>nth(1)</code> gives you the second value of the iterator, and <code>expect</code>
is like an <code>unwrap</code> with a readable message.</p>
<p>Converting a string into a number is straightforward, but you do need to specify
the type of the value - how else could <code>parse</code> know?</p>
<p>This program can panic, which is fine for dinky test programs. But don't get too
comfortable with this convenient habit.</p>
<a class="header" href="print.html#matching" name="matching"><h2>Matching</h2></a>
<p>The code in <code>string3.rs</code> where we extract the Russian greeting is not how it would
be usually written. Enter <em>match</em>:</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
# 
#fn main() {
    match multilingual.find('п') {
        Some(idx) =&gt; {
            let hi = &amp;multilingual[idx..];
            println!(&quot;Russian hi {}&quot;, hi);
        },
        None =&gt; println!(&quot;couldn't find the greeting, Товарищ&quot;)
    };

#}</code></pre></pre>
<p><code>match</code> consists of several <em>patterns</em> with a matching value following the fat arrow,
separated by commas.  It has conveniently unwrapped the value from the <code>Option</code> and
bound it to <code>idx</code>.  You <em>must</em> specify all the possibilities, so we have to handle
<code>None</code>.</p>
<p>Once you are used to it (and by that I mean, typed it out in full a few times) it
feels more natural than the explicit <code>is_some</code> check which needed an extra
variable to store the <code>Option</code>.</p>
<p>But if you're not interested in failure here, then <code>if let</code> is your friend:</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
# 
#fn main() {
    if let Some(idx) = multilingual.find('п') {
        println!(&quot;Russian hi {}&quot;, &amp;multilingual[idx..]);
    }

#}</code></pre></pre>
<p>This is convenient if you want to do a match and are <em>only</em> interested in one possible
result.</p>
<p><code>match</code> can also operate like a C <code>switch</code> statement, and like other Rust constructs
can return a value:</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
# 
#fn main() {
    let text = match n {
        0 =&gt; &quot;zero&quot;,
        1 =&gt; &quot;one&quot;,
        2 =&gt; &quot;two&quot;,
        _ =&gt; &quot;many&quot;,
    };

#}</code></pre></pre>
<p>The <code>_</code> is like C <code>default</code> - it's a fall-back case. If you don't provide one then
<code>rustc</code> will consider it an error. (In C++ the best you can expect is a warning, which
says a lot about the respective languages).</p>
<p>Rust <code>match</code> statements can also match on ranges. Note that these ranges have
<em>three</em> dots and are inclusive ranges, so that the first condition would match 3.</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
# 
#fn main() {
    let text = match n {
        0...3 =&gt; &quot;small&quot;,
        4...6 =&gt; &quot;medium&quot;,
        _ =&gt; &quot;large&quot;,
     };

#}</code></pre></pre>
<a class="header" href="print.html#reading-from-files" name="reading-from-files"><h2>Reading from Files</h2></a>
<p>The next step to exposing our programs to the world is to <em>reading files</em>.</p>
<p>Recall that <code>expect</code> is like <code>unwrap</code> but gives a custom error message. We are
going to throw away a few errors here:</p>
<pre><pre class="playpen"><code class="language-rust">// file1.rs
use std::env;
use std::fs::File;
use std::io::Read;

fn main() {
    let first = env::args().nth(1).expect(&quot;please supply a filename&quot;);

    let mut file = File::open(&amp;first).expect(&quot;can't open the file&quot;);

    let mut text = String::new();
    file.read_to_string(&amp;mut text).expect(&quot;can't read the file&quot;);

    println!(&quot;file had {} bytes&quot;, text.len());

}
</code></pre></pre>
<pre><code>src$ file1 file1.rs
file had 366 bytes
src$ ./file1 frodo.txt
thread 'main' panicked at 'can't open the file: Error { repr: Os { code: 2, message: &quot;No such file or directory&quot; } }', ../src/libcore/result.rs:837
note: Run with `RUST_BACKTRACE=1` for a backtrace.
src$ file1 file1
thread 'main' panicked at 'can't read the file: Error { repr: Custom(Custom { kind: InvalidData, error: StringError(&quot;stream did not contain valid UTF-8&quot;) }) }', ../src/libcore/result.rs:837
note: Run with `RUST_BACKTRACE=1` for a backtrace.
</code></pre>
<p>So <code>open</code> can fail because the file doesn't exist or we aren't allowed to read it,
and <code>read_to_string</code> can fail because the file doesn't contain valid UTF-8. (Which is
fair enough, you can use <code>read_to_end</code> and put the contents into a vector of bytes
instead.) For files that aren't too big, reading them in one gulp is useful and
straightforward.</p>
<p>If you know anything about file handling in other languages, you may wonder when
the file is <em>closed</em>. If we were writing to this file, then not closing it could
result in loss of data.
But the file here is closed when the function ends and the <code>file</code> variable is <em>dropped</em>.</p>
<p>This 'throwing away errors' thing is getting too much of a habit. You do not
want to put this code into a function, knowing that it could so easily crash
the whole program.  So now we have to talk about exactly what <code>File::open</code> returns.
If <code>Option</code> is a value that may contain something or nothing, then <code>Result</code> is a value
that may contain something or an error. They both understand <code>unwrap</code> (and its cousin
<code>expect</code>) but they are quite different. <code>Result</code> is defined by <em>two</em> type parameters,
for the <code>Ok</code> value and the <code>Err</code> value.
The <code>Result</code> 'box' has two compartments, one labelled <code>Ok</code> and the other <code>Err</code>.</p>
<pre><pre class="playpen"><code class="language-rust">fn good_or_bad(good: bool) -&gt; Result&lt;i32,String&gt; {
    if good {
        Ok(42)
    } else {
        Err(&quot;bad&quot;.to_string())
    }
}

fn main() {
    println!(&quot;{:?}&quot;,good_or_bad(true));
    //Ok(42)
    println!(&quot;{:?}&quot;,good_or_bad(false));
    //Err(&quot;bad&quot;)

    match good_or_bad(true) {
        Ok(n) =&gt; println!(&quot;Cool, I got {}&quot;,n),
        Err(e) =&gt; println!(&quot;Huh, I just got {}&quot;,e)
    }
    // Cool, I got 42

}
</code></pre></pre>
<p>(The actual 'error' type is arbitrary - a lot of people use strings until
they are comfortable with Rust error types.) It's a convenient way to <em>either</em>
return one value <em>or</em> another.</p>
<p>This version of the file reading function does not crash. It returns a <code>Result</code> and
it is the <em>caller</em> who must decide how to handle the error.</p>
<pre><pre class="playpen"><code class="language-rust">// file2.rs
use std::env;
use std::fs::File;
use std::io::Read;
use std::io;

fn read_to_string(filename: &amp;str) -&gt; Result&lt;String,io::Error&gt; {
    let mut file = match File::open(&amp;filename) {
        Ok(f) =&gt; f,
        Err(e) =&gt; return Err(e),
    };
    let mut text = String::new();
    match file.read_to_string(&amp;mut text) {
        Ok(_) =&gt; Ok(text),
        Err(e) =&gt; Err(e),
    }
}

fn main() {
    let file = env::args().nth(1).expect(&quot;please supply a filename&quot;);

    let text = read_to_string(&amp;file).expect(&quot;bad file man!&quot;);

    println!(&quot;file had {} bytes&quot;, text.len());
}
</code></pre></pre>
<p>The first match safely extracts the value from <code>Ok</code>, which
becomes the value of the match. If it's <code>Err</code> it returns the error,
rewrapped as an <code>Err</code>.</p>
<p>The second match returns the string, wrapped up as an <code>Ok</code>, otherwise
(again) the error. The actual value in the <code>Ok</code> is unimportant, so we ignore
it with <code>_</code>.</p>
<p>This is not so pretty; when most of a function is error handling, then
the 'happy path' gets lost. Go tends to have this problem, with lots of
explicit early returns, or just <em>ignoring errors</em>.  (That is, by the way,
the closest thing to evil in the Rust universe.)</p>
<p>Fortunately, there is a shortcut.</p>
<p>The <code>std::io</code> module defines a type alias <code>io::Result&lt;T&gt;</code> which is exactly
the same as <code>Result&lt;T,io::Error&gt;</code> and easier to type.</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
# 
#fn main() {
fn read_to_string(filename: &amp;str) -&gt; io::Result&lt;String&gt; {
    let mut file = File::open(&amp;filename)?;
    let mut text = String::new();
    file.read_to_string(&amp;mut text)?;
    Ok(text)
}

#}</code></pre></pre>
<p>That <code>?</code> operator does almost exactly what the match on <code>File::open</code> does;
if the result was an error, then it will immediately return that error.
Otherwise, it returns the <code>Ok</code> result.
At the end, we still need to wrap up the string as a result.</p>
<p>2017 was a good year for Rust, and <code>?</code> was one of the cool things that
became stable. You will still see the macro <code>try!</code> used in older code:</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
# 
#fn main() {
fn read_to_string(filename: &amp;str) -&gt; io::Result&lt;String&gt; {
    let mut file = try!(File::open(&amp;filename));
    let mut text = String::new();
    try!(file.read_to_string(&amp;mut text));
    Ok(text)
}

#}</code></pre></pre>
<p>In summary, it's possible to write perfectly safe Rust that isn't ugly, without
needing exceptions.</p>
<a class="header" href="print.html#structs-enums-and-matching" name="structs-enums-and-matching"><h1>Structs, Enums and Matching</h1></a>
<a class="header" href="print.html#rust-likes-to-move-it-move-it" name="rust-likes-to-move-it-move-it"><h2>Rust likes to Move It, Move It</h2></a>
<p>I'd like to move back a little, and show you something surprising:</p>
<pre><pre class="playpen"><code class="language-rust">// move1.rs
fn main() {
    let s1 = &quot;hello dolly&quot;.to_string();
    let s2 = s1;
    println!(&quot;s1 {}&quot;, s1);
}
</code></pre></pre>
<p>And we get the following error:</p>
<pre><code>error[E0382]: use of moved value: `s1`
 --&gt; move1.rs:5:22
  |
4 |     let s2 = s1;
  |         -- value moved here
5 |     println!(&quot;s1 {}&quot;, s1);
  |                      ^^ value used here after move
  |
  = note: move occurs because `s1` has type `std::string::String`,
  which does not implement the `Copy` trait
</code></pre>
<p>Rust has different behaviour than other languages. In a language where variables are
always references (like Java or Python), <code>s2</code> becomes yet another reference to the
string object referenced by <code>s1</code>. In C++, <code>s1</code> is a value, and it is <em>copied</em> to <code>s2</code>.
But Rust moves the value.  It doesn't see strings as copyable
(&quot;does not implement the Copy trait&quot;).</p>
<p>We would not see this with 'primitive' types like numbers, since they are just values;
they are allowed to be copyable because they are cheap to copy. But <code>String</code> has allocated
memory containing &quot;Hello dolly&quot;, and copying will involve allocating some more memory
and copying the characters. Rust will not do this silently.</p>
<p>Consider a <code>String</code> containing the whole text of 'Moby-Dick'. It's not a big struct,
just has the address in memory of the text, its size, and how big the allocated block is.
Copying this is going to be expensive, because that memory is allocated on the heap and
the copy will need its own allocated block.</p>
<pre><code>    String
    | addr | ---------&gt; Call me Ishmael.....
    | size |                    |
    | cap  |                    |
                                |
    &amp;str                        |
    | addr | -------------------|
    | size |

    f64
    | 8 bytes |
</code></pre>
<p>The second value is a string slice (<code>&amp;str</code>) which refers to the same memory as the string,
with a size - just the guy's name. Cheap to copy!</p>
<p>The third value is an <code>f64</code> - just 8 bytes. It does not refer to any other memory, so
it's just as cheap to copy as to move.</p>
<p><code>Copy</code> values are only defined by their representation in memory, and when
Rust copies, it just copies those bytes elsewhere. Similarly, a non-<code>Copy</code> value
is also <em>just moved</em>.  There is no cleverness in copying and moving, unlike in C++.</p>
<p>Re-writing with a function call reveals exactly the same error:</p>
<pre><pre class="playpen"><code class="language-rust">// move2.rs

fn dump(s: String) {
    println!(&quot;{}&quot;, s);
}

fn main() {
    let s1 = &quot;hello dolly&quot;.to_string();
    dump(s1);
    println!(&quot;s1 {}&quot;, s1); // &lt;---error: 'value used here after move'
}
</code></pre></pre>
<p>Here, you have a choice. You may pass a reference to that string, or
explicitly copy it using its <code>clone</code> method.  Generally, the first is the better way
to go.</p>
<pre><pre class="playpen"><code class="language-rust">fn dump(s: &amp;String) {
    println!(&quot;{}&quot;, s);
}

fn main() {
    let s1 = &quot;hello dolly&quot;.to_string();
    dump(&amp;s1);
    println!(&quot;s1 {}&quot;, s1);
}
</code></pre></pre>
<p>The error goes away. But you'll rarely see a plain
<code>String</code> reference like this, since to pass a string literal is really ugly <em>and</em> involves
creating a temporary string.</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
# 
#fn main() {
    dump(&amp;&quot;hello world&quot;.to_string());

#}</code></pre></pre>
<p>So altogether the best way to declare that function is:</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
# 
#fn main() {
fn dump(s: &amp;str) {
    println!(&quot;{}&quot;, s);
}

#}</code></pre></pre>
<p>And then both <code>dump(&amp;s1)</code> and <code>dump(&quot;hello world&quot;)</code> work properly. (Here <code>Deref</code>
coercion kicks in and Rust will convert <code>&amp;String</code> to <code>&amp;str</code> for you.)</p>
<p>To summarise, assignment of a non-Copy value moves the value from one location
to another. Otherwise, Rust would be forced to <em>implicitly</em> do a copy and break its
promise to make allocations explicit.</p>
<a class="header" href="print.html#scope-of-variables" name="scope-of-variables"><h2>Scope of Variables</h2></a>
<p>So, the rule of thumb is to prefer to keep references to the original data - to 'borrow'
it.</p>
<p>But a reference must <em>not</em> outlive the owner!</p>
<p>First, Rust is a <em>block-scoped</em> language. Variables only exist for the duration of their
block:</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
# 
#fn main() {
{
    let a = 10;
    let b = &quot;hello&quot;;
    {
        let c = &quot;hello&quot;.to_string();
        // a,b and c are visible
    }
    // the string c is dropped
    // a,b are visible
    for i in 0..a {
        let b = &amp;b[1..];
        // original b is no longer visible - it is shadowed.
    }
    // the slice b is dropped
    // i is _not_ visible!
}

#}</code></pre></pre>
<p>Loop variables (like <code>i</code>) are a little different, they are only visible in the loop
block.  It is not an error to create a new variable using the same name ('shadowing')
but it can be confusing.</p>
<p>When a variable 'goes out of scope' then it is <em>dropped</em>. Any memory used is reclaimed,
and any other <em>resources</em> owned by that variable are given back to the system - for
instance, dropping a <code>File</code> closes it.  This is a Good Thing. Unused resources are
reclaimed immediately when not needed.</p>
<p>(A further Rust-specific issue is that a variable may appear to be in scope, but its
value has moved.)</p>
<p>Here a reference <code>rs1</code> is made to a value <code>tmp</code> which only lives for the duration
of its block:</p>
<pre><pre class="playpen"><code class="language-rust">01 // ref1.rs
02 fn main() {
03    let s1 = &quot;hello dolly&quot;.to_string();
04    let mut rs1 = &amp;s1;
05    {
06        let tmp = &quot;hello world&quot;.to_string();
07        rs1 = &amp;tmp;
08    }
09    println!(&quot;ref {}&quot;, rs1);
10 }
</code></pre></pre>
<p>We borrow the value of <code>s1</code> and then borrow the value of <code>tmp</code>. But <code>tmp</code>'s value
does not exist outside that block!</p>
<pre><code>error: `tmp` does not live long enough
  --&gt; ref1.rs:8:5
   |
7  |         rs1 = &amp;tmp;
   |                --- borrow occurs here
8  |     }
   |     ^ `tmp` dropped here while still borrowed
9  |     println!(&quot;ref {}&quot;, rs1);
10 | }
   | - borrowed value needs to live until here
</code></pre>
<p>Where is <code>tmp</code>? Gone, dead, gone back to the Big Heap in the Sky: <em>dropped</em>.
Rust is here saving you from the dreaded 'dangling pointer' problem of C -
a reference that points to stale data.</p>
<a class="header" href="print.html#tuples" name="tuples"><h2>Tuples</h2></a>
<p>It's sometimes very useful to return multiple values from a function. Tuples are
a convenient solution:</p>
<pre><pre class="playpen"><code class="language-rust">// tuple1.rs

fn add_mul(x: f64, y: f64) -&gt; (f64,f64) {
    (x + y, x * y)
}

fn main() {
    let t = add_mul(2.0,10.0);

    // can debug print
    println!(&quot;t {:?}&quot;, t);

    // can 'index' the values
    println!(&quot;add {} mul {}&quot;, t.0,t.1);

    // can _extract_ values
    let (add,mul) = t;
    println!(&quot;add {} mul {}&quot;, add,mul);
}
// t (12, 20)
// add 12 mul 20
// add 12 mul 20
</code></pre></pre>
<p>Tuples may contain <em>different</em> types, which is the main difference from arrays.</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
# 
#fn main() {
let tuple = (&quot;hello&quot;, 5, 'c');

assert_eq!(tuple.0, &quot;hello&quot;);
assert_eq!(tuple.1, 5);
assert_eq!(tuple.2, 'c');

#}</code></pre></pre>
<p>They appear in some <code>Iterator</code> methods. <code>enumerate</code> is like the Python generator
of the same name:</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
# 
#fn main() {
    for t in [&quot;zero&quot;,&quot;one&quot;,&quot;two&quot;].iter().enumerate() {
        print!(&quot; {} {};&quot;,t.0,t.1);
    }
    //  0 zero; 1 one; 2 two;

#}</code></pre></pre>
<p><code>zip</code> combines two iterators into a single iterator of
tuples containing the values from both:</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
# 
#fn main() {
    let names = [&quot;ten&quot;,&quot;hundred&quot;,&quot;thousand&quot;];
    let nums = [10,100,1000];
    for p in names.iter().zip(nums.iter()) {
        print!(&quot; {} {};&quot;, p.0,p.1);
    }
    //  ten 10; hundred 100; thousand 1000;

#}</code></pre></pre>
<a class="header" href="print.html#structs" name="structs"><h2>Structs</h2></a>
<p>Tuples are convenient, but saying <code>t.1</code> and keeping track of the meaning of each part
is tedious for anything that isn't straightforward.</p>
<p>Rust <em>structs</em> contain named <em>fields</em>:</p>
<pre><pre class="playpen"><code class="language-rust">// struct1.rs

struct Person {
    first_name: String,
    last_name: String
}

fn main() {
    let p = Person {
        first_name: &quot;John&quot;.to_string(),
        last_name: &quot;Smith&quot;.to_string()
    };
    println!(&quot;person {} {}&quot;, p.first_name,p.last_name);
}
</code></pre></pre>
<p>The values of a struct will be placed next to each other in memory, although you should
not assume any particular memory layout, since the compiler will organize the memory for
efficiency, not size, and there may be padding.</p>
<p>Initializing this struct is a bit clumsy, so we want to move the construction of a <code>Person</code>
into its own function. This function can be made into an <em>associated function</em> of <code>Person</code> by putting
it into a <code>impl</code> block:</p>
<pre><pre class="playpen"><code class="language-rust">// struct2.rs

struct Person {
    first_name: String,
    last_name: String
}

impl Person {

    fn new(first: &amp;str, name: &amp;str) -&gt; Person {
        Person {
            first_name: first.to_string(),
            last_name: name.to_string()
        }
    }

}

fn main() {
    let p = Person::new(&quot;John&quot;,&quot;Smith&quot;);
    println!(&quot;person {} {}&quot;, p.first_name,p.last_name);
}
</code></pre></pre>
<p>There is nothing magic or reserved about the name <code>new</code> here. Note that it's accessed
using a C++-like notation using double-colon <code>::</code>.</p>
<p>Here's a <code>Person</code> <em>method</em> , that takes a <em>reference self</em> argument:</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
# 
#fn main() {
impl Person {
    ...

    fn full_name(&amp;self) -&gt; String {
        format!(&quot;{} {}&quot;, self.first_name, self.last_name)
    }

}
...
    println!(&quot;fullname {}&quot;, p.full_name());
// fullname John Smith

#}</code></pre></pre>
<p>The <code>self</code> is used explicitly and is passed as a reference.
(You can think of <code>&amp;self</code> as short for <code>self: &amp;Person</code>.)</p>
<p>The keyword <code>Self</code> refers to the struct type - you can mentally substitute <code>Person</code>
for <code>Self</code> here:</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
# 
#fn main() {
    fn copy(&amp;self) -&gt; Self {
        Self::new(&amp;self.first_name,&amp;self.last_name)
    }

#}</code></pre></pre>
<p>Methods may allow the data to be modified using a <em>mutable self</em> argument:</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
# 
#fn main() {
    fn set_first_name(&amp;mut self, name: &amp;str) {
        self.first_name = name.to_string();
    }

#}</code></pre></pre>
<p>And the data will <em>move</em> into the method when a plain self argument is used:</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
# 
#fn main() {
    fn to_tuple(self) -&gt; (String,String) {
        (self.first_name, self.last_name)
    }

#}</code></pre></pre>
<p>(Try that with <code>&amp;self</code> - structs will not let go of their data without a fight!)</p>
<p>Note that after <code>v.to_tuple()</code> is called, then <code>v</code> has moved and is no longer
available.</p>
<p>To summarize:</p>
<ul>
<li>no <code>self</code> argument: you can associate functions with structs, like the <code>new</code> &quot;constructor&quot;.</li>
<li><code>&amp;self</code> argument: can use the values of the struct, but not change them</li>
<li><code>&amp;mut self</code> argument: can modify the values</li>
<li><code>self</code> argument: will consume the value, which will move.</li>
</ul>
<p>If you try to do a debug dump of a <code>Person</code>, you will get an informative error:</p>
<pre><code>error[E0277]: the trait bound `Person: std::fmt::Debug` is not satisfied
  --&gt; struct2.rs:23:21
   |
23 |     println!(&quot;{:?}&quot;, p);
   |                     ^ the trait `std::fmt::Debug` is not implemented for `Person`
   |
   = note: `Person` cannot be formatted using `:?`; if it is defined in your crate,
    add `#[derive(Debug)]` or manually implement it
   = note: required by `std::fmt::Debug::fmt`
</code></pre>
<p>The compiler is giving advice, so we put <code>#[derive(Debug)]</code> in front of <code>Person</code>, and now
there is sensible output:</p>
<pre><code>Person { first_name: &quot;John&quot;, last_name: &quot;Smith&quot; }
</code></pre>
<p>The <em>directive</em> makes the compiler generate a <code>Debug</code> implementation, which is very
helpful. It's good practice to do this for your structs, so they can be
printed out (or written as a string using <code>format!</code>).  (Doing so <em>by default</em> would be
very un-Rustlike.)</p>
<p>Here is the final little program:</p>
<pre><pre class="playpen"><code class="language-rust">// struct4.rs
use std::fmt;

#[derive(Debug)]
struct Person {
    first_name: String,
    last_name: String
}

impl Person {

    fn new(first: &amp;str, name: &amp;str) -&gt; Person {
        Person {
            first_name: first.to_string(),
            last_name: name.to_string()
        }
    }

    fn full_name(&amp;self) -&gt; String {
        format!(&quot;{} {}&quot;,self.first_name, self.last_name)
    }

    fn set_first_name(&amp;mut self, name: &amp;str) {
        self.first_name = name.to_string();
    }

    fn to_tuple(self) -&gt; (String,String) {
        (self.first_name, self.last_name)
    }
}

fn main() {
    let mut p = Person::new(&quot;John&quot;,&quot;Smith&quot;);

    println!(&quot;{:?}&quot;, p);

    p.set_first_name(&quot;Jane&quot;);

    println!(&quot;{:?}&quot;, p);

    println!(&quot;{:?}&quot;, p.to_tuple());
    // p has now moved.

}
// Person { first_name: &quot;John&quot;, last_name: &quot;Smith&quot; }
// Person { first_name: &quot;Jane&quot;, last_name: &quot;Smith&quot; }
// (&quot;Jane&quot;, &quot;Smith&quot;)
</code></pre></pre>
<a class="header" href="print.html#lifetimes-start-to-bite" name="lifetimes-start-to-bite"><h2>Lifetimes Start to Bite</h2></a>
<p>Usually structs contain values, but often they also need to contain references.
Say we want to put a string slice, not a string value, in a struct.</p>
<pre><pre class="playpen"><code class="language-rust">// life1.rs

#[derive(Debug)]
struct A {
    s: &amp;str
}

fn main() {
    let a = A { s: &quot;hello dammit&quot; };

    println!(&quot;{:?}&quot;, a);
}
</code></pre></pre>
<pre><code>error[E0106]: missing lifetime specifier
 --&gt; life1.rs:5:8
  |
5 |     s: &amp;str
  |        ^ expected lifetime parameter
</code></pre>
<p>To understand the complaint, you have to see the problem from the point of view of Rust.
It will not allow a reference to be stored without knowing its lifetime. All
references are borrowed from some value, and all values have lifetimes. The lifetime of
a reference cannot be longer than the lifetime of that value.
Rust cannot allow
a situation where that reference could suddenly become invalid.</p>
<p>Now, string slices borrow from <em>string literals</em>
like &quot;hello&quot; or from <code>String</code> values. String literals exist for the duration
of the whole program, which is called the 'static' lifetime.</p>
<p>So this works - we assure Rust that the string slice always refers to such static strings:</p>
<pre><pre class="playpen"><code class="language-rust">// life2.rs

#[derive(Debug)]
struct A {
    s: &amp;'static str
}

fn main() {
    let a = A { s: &quot;hello dammit&quot; };

    println!(&quot;{:?}&quot;, a);
}
// A { s: &quot;hello dammit&quot; }
</code></pre></pre>
<p>It is not the most <em>pretty</em> notation, but sometimes ugliness is the necessary
price of being precise.</p>
<p>This can also be used to specify a string slice that is returned from a function:</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
# 
#fn main() {
fn how(i: u32) -&gt; &amp;'static str {
    match i {
    0 =&gt; &quot;none&quot;,
    1 =&gt; &quot;one&quot;,
    _ =&gt; &quot;many&quot;
    }
}

#}</code></pre></pre>
<p>That works for the special case of static strings, but this is very restrictive.</p>
<p>However we can specify that the lifetime of the reference is <em>at least as long</em> as that of
the struct itself.</p>
<pre><pre class="playpen"><code class="language-rust">// life3.rs

#[derive(Debug)]
struct A &lt;'a&gt; {
    s: &amp;'a str
}

fn main() {
    let s = &quot;I'm a little string&quot;.to_string();
    let a = A { s: &amp;s };

    println!(&quot;{:?}&quot;, a);
}
</code></pre></pre>
<p>Lifetimes are conventionally called 'a','b',etc but you could just as well called it
'me' here.</p>
<p>After this point, our <code>a</code> struct and the <code>s</code> string are bound by a strict contract:
<code>a</code> borrows from <code>s</code>, and cannot outlive it.</p>
<p>With this struct definition, we would like to write a function that returns an <code>A</code> value:</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
# 
#fn main() {
fn makes_a() -&gt; A {
    let string = &quot;I'm a little string&quot;.to_string();
    A { s: &amp;string }
}

#}</code></pre></pre>
<p>But <code>A</code> needs a lifetime - &quot;expected lifetime parameter&quot;:</p>
<pre><code>  = help: this function's return type contains a borrowed value,
   but there is no value for it to be borrowed from
  = help: consider giving it a 'static lifetime
</code></pre>
<p><code>rustc</code> is giving advice, so we follow it:</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
# 
#fn main() {
fn makes_a() -&gt; A&lt;'static&gt; {
    let string = &quot;I'm a little string&quot;.to_string();
    A { s: &amp;string }
}

#}</code></pre></pre>
<p>And now the error is</p>
<pre><code>8 |      A { s: &amp;string }
  |              ^^^^^^ does not live long enough
9 | }
  | - borrowed value only lives until here
</code></pre>
<p>There is no way that this could safely work, because <code>string</code> will be dropped when the
function ends, and no reference to <code>string</code> can outlast it.</p>
<p>You can usefully think of lifetime parameters as being part of the type of a value.</p>
<p>Sometimes it seems like a good idea for a struct to contain a value <em>and</em> a reference
that borrows from that value.
It's basically impossible because structs must be <em>moveable</em>, and any move will
invalidate the reference.  It isn't necessary to do this - for instance, if your
struct has a string field, and needs to provide slices, then it could keep indices
and have a method to generate the actual slices.</p>
<a class="header" href="print.html#traits" name="traits"><h2>Traits</h2></a>
<p>Please note that Rust does not spell <code>struct</code> <em>class</em>. The keyword <code>class</code> in other
languages is so overloaded with meaning that it effectively shuts down original thinking.</p>
<p>Let's put it like this: Rust structs cannot <em>inherit</em> from other structs; they are
all unique types. There is no <em>sub-typing</em>. They are dumb data.</p>
<p>So how <em>does</em> one establish relationships between types? This is where <em>traits</em> come in.</p>
<p><code>rustc</code> often talks about <code>implementing X trait</code> and so it's time to talk about traits
properly.</p>
<p>Here's a little example of defining a trait and <em>implementing</em> it for a particular type.</p>
<pre><pre class="playpen"><code class="language-rust">// trait1.rs

trait Show {
    fn show(&amp;self) -&gt; String;
}

impl Show for i32 {
    fn show(&amp;self) -&gt; String {
        format!(&quot;four-byte signed {}&quot;, self)
    }
}

impl Show for f64 {
    fn show(&amp;self) -&gt; String {
        format!(&quot;eight-byte float {}&quot;, self)
    }
}

fn main() {
    let answer = 42;
    let maybe_pi = 3.14;
    let s1 = answer.show();
    let s2 = maybe_pi.show();
    println!(&quot;show {}&quot;, s1);
    println!(&quot;show {}&quot;, s2);
}
// show four-byte signed 42
// show eight-byte float 3.14
</code></pre></pre>
<p>It's pretty cool; we have <em>added a new method</em> to both <code>i32</code> and <code>f64</code>!</p>
<p>Getting comfortable with Rust involves learning the basic traits of the
standard library (they tend to hunt in packs.)</p>
<p><code>Debug</code> is very common.
We gave <code>Person</code> a default implementation with the
convenient <code>#[derive(Debug)]</code>, but say we want a <code>Person</code> to display as its full name:</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
# 
#fn main() {
use std::fmt;

impl fmt::Debug for Person {
    fn fmt(&amp;self, f: &amp;mut fmt::Formatter) -&gt; fmt::Result {
        write!(f, &quot;{}&quot;, self.full_name())
    }
}
...
    println!(&quot;{:?}&quot;, p);
    // John Smith

#}</code></pre></pre>
<p><code>write!</code> is a very useful macro - here <code>f</code> is anything that implements <code>Write</code>.
(This would also work with a <code>File</code> - or even a <code>String</code>.)</p>
<p><code>Display</code> controls how values are printed out with &quot;{}&quot; and is implemented
just like <code>Debug</code>. As a useful side-effect, <code>ToString</code> is automatically
implemented for anything implementing <code>Display</code>. So if we implement
<code>Display</code> for <code>Person</code>, then <code>p.to_string()</code> also works.</p>
<p><code>Clone</code> defines the method <code>clone</code>, and can simply be defined with
&quot;#[derive(Clone)]&quot; if all the fields themselves implement <code>Clone</code>.</p>
<a class="header" href="print.html#example-iterator-over-floating-point-range" name="example-iterator-over-floating-point-range"><h2>Example: iterator over floating-point range</h2></a>
<p>We have met ranges before (<code>0..n</code>) but they don't work for floating-point values. (You
can <em>force</em> this but you'll end up with a step of 1.0 which is uninteresting.)</p>
<p>Recall the informal definition of an iterator; it is an struct with a <code>next</code> method
which may return <code>Some</code>-thing or <code>None</code>. In the process, the iterator itself gets modified,
it keeps the state for the iteration (like next index and so forth.) The data that
is being iterated over doesn't change usually, (But see <code>Vec::drain</code> for an
interesting iterator that does modify its data.)</p>
<p>And here is the formal definition: the <a href="https://doc.rust-lang.org/std/iter/trait.Iterator.html">Iterator trait</a>.</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
# 
#fn main() {
trait Iterator {
    type Item;
    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt;;
    ...
}

#}</code></pre></pre>
<p>Here we meet an <a href="https://doc.rust-lang.org/stable/book/associated-types.html">associated type</a> of the <code>Iterator</code> trait.
This trait must work for any type, so you must specify that return type somehow.
The method <code>next</code> can then be written without using a
particular type - instead it refers to that type parameter's <code>Item</code> via <code>Self</code>.</p>
<p>The iterator trait for <code>f64</code> is written <code>Iterator&lt;Item=f64&gt;</code>, which can be read as
&quot;an Iterator with its associated type Item set to f64&quot;.</p>
<p>The <code>...</code> refers to the <em>provided methods</em> of <code>Iterator</code>. You only need to define <code>Item</code>
and <code>next</code>, and the provided methods are defined for you.</p>
<pre><pre class="playpen"><code class="language-rust">// trait3.rs

struct FRange {
    val: f64,
    end: f64,
    incr: f64
}

fn range(x1: f64, x2: f64, skip: f64) -&gt; FRange {
    FRange {val: x1, end: x2, incr: skip}
}

impl Iterator for FRange {
    type Item = f64;

    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; {
        let res = self.val;
        if res &gt;= self.end {
            None
        } else {
            self.val += self.incr;
            Some(res)
        }
    }
}


fn main() {
    for x in range(0.0, 1.0, 0.1) {
        println!(&quot;{} &quot;, x);
    }
}
</code></pre></pre>
<p>And the rather messy looking result is</p>
<pre><code>0
0.1
0.2
0.30000000000000004
0.4
0.5
0.6
0.7
0.7999999999999999
0.8999999999999999
0.9999999999999999
</code></pre>
<p>This is because 0.1 is not precisely representable as a float, so a little formatting
help is needed. Replace the <code>println!</code> with this</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
# 
#fn main() {
println!(&quot;{:.1} &quot;, x);

#}</code></pre></pre>
<p>And we get cleaner output (this <a href="https://doc.rust-lang.org/std/fmt/index.html">format</a>
means 'one decimal after dot'.)</p>
<p>All of the default iterator methods are available, so we can collect these values into
a vector, map them, and so forth.</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
# 
#fn main() {
    let v: Vec&lt;f64&gt; = range(0.0, 1.0, 0.1).map(|x| x.sin()).collect();

#}</code></pre></pre>
<a class="header" href="print.html#generic-functions" name="generic-functions"><h2>Generic Functions</h2></a>
<p>We want a function which will dump out any value that implements <code>Debug</code>. Here is
a first attempt at a generic function, where we can pass a reference to <em>any</em> type
of value. <code>T</code> is a type parameter, which needs to be declared just after the
function name:</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
# 
#fn main() {
fn dump&lt;T&gt; (value: &amp;T) {
    println!(&quot;value is {:?}&quot;,value);
}

let n = 42;
dump(&amp;n);

#}</code></pre></pre>
<p>However, Rust clearly knows nothing about this generic type <code>T</code>:</p>
<pre><code>error[E0277]: the trait bound `T: std::fmt::Debug` is not satisfied
...
   = help: the trait `std::fmt::Debug` is not implemented for `T`
   = help: consider adding a `where T: std::fmt::Debug` bound
</code></pre>
<p>For this to work, Rust needs to be told that <code>T</code> does in fact implement <code>Debug</code>!</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
# 
#fn main() {
fn dump&lt;T&gt; (value: &amp;T)
where T: std::fmt::Debug {
    println!(&quot;value is {:?}&quot;,value);
}

let n = 42;
dump(&amp;n);
// value is 42

#}</code></pre></pre>
<p>Rust generic functions need <em>trait bounds</em> on types - we are saying here that
&quot;T is any type that implements Debug&quot;. <code>rustc</code> is being very helpful, and
suggests exactly what bound needs to be provided.</p>
<p>Now that Rust knows the trait bounds for <code>T</code>, it can give you sensible compiler messages:</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
# 
#fn main() {
struct Foo {
    name: String
}

let foo = Foo{name: &quot;hello&quot;.to_string()};

dump(&amp;foo)

#}</code></pre></pre>
<p>And the error is &quot;the trait <code>std::fmt::Debug</code> is not implemented for <code>Foo</code>&quot;.</p>
<p>Functions are already generic in dynamic languages because values carry their actual type around,
and the type checking happens at run-time - or fails miserably. For larger programs, we really
do want to know about problems at compile-time rather! Rather than sitting down calmly with
compiler errors, a programmer in these languages has to deal with problems that only
show up when the program is running. Murphy's Law then implies that these problems
will tend to happen at the most inconvenient/disastrous time.</p>
<p>The operation of squaring a number is generic:  <code>x*x</code> will work for integers,
floats and generally for anything that knows about the multiplication operator <code>*</code>.
But what are the type bounds?</p>
<pre><pre class="playpen"><code class="language-rust">// gen1.rs

fn sqr&lt;T&gt; (x: T) -&gt; T {
    x * x
}

fn main() {
    let res = sqr(10.0);
    println!(&quot;res {}&quot;,res);
}
</code></pre></pre>
<p>The first problem is that Rust does not know that <code>T</code> can be multiplied:</p>
<pre><code>error[E0369]: binary operation `*` cannot be applied to type `T`
 --&gt; gen1.rs:4:5
  |
4 |     x * x
  |     ^
  |
note: an implementation of `std::ops::Mul` might be missing for `T`
 --&gt; gen1.rs:4:5
  |
4 |     x * x
  |     ^
</code></pre>
<p>Following the advice of the compiler, let's constrain that type parameter using
<a href="https://doc.rust-lang.org/std/ops/trait.Mul.html">that trait</a>, which is used to implement the multiplication operator <code>*</code>:</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
# 
#fn main() {
fn sqr&lt;T&gt; (x: T) -&gt; T
where T: std::ops::Mul {
    x * x
}

#}</code></pre></pre>
<p>Which still doesn't work:</p>
<pre><code>rror[E0308]: mismatched types
 --&gt; gen2.rs:6:5
  |
6 |     x * x
  |     ^^^ expected type parameter, found associated type
  |
  = note: expected type `T`
  = note:    found type `&lt;T as std::ops::Mul&gt;::Output`
</code></pre>
<p>What <code>rustc</code> is saying that the type of <code>x*x</code> is the associated type <code>T::Output</code>, not <code>T</code>.
There's actually no reason that the type of <code>x*x</code> is the same as the type of <code>x</code>, e.g. the dot product
of two vectors is a scalar.</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
# 
#fn main() {
fn sqr&lt;T&gt; (x: T) -&gt; T::Output
where T: std::ops::Mul {
    x * x
}

#}</code></pre></pre>
<p>and now the error is:</p>
<pre><code>error[E0382]: use of moved value: `x`
 --&gt; gen2.rs:6:7
  |
6 |     x * x
  |     - ^ value used here after move
  |     |
  |     value moved here
  |
  = note: move occurs because `x` has type `T`, which does not implement the `Copy` trait
</code></pre>
<p>So, we need to constrain the type even further!</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
# 
#fn main() {
fn sqr&lt;T&gt; (x: T) -&gt; T::Output
where T: std::ops::Mul + Copy {
    x * x
}

#}</code></pre></pre>
<p>And that (finally) works. Calmly listening to the compiler will often get you closer
to the magic point when ... things compile cleanly.</p>
<p>It <em>is</em> a bit simpler in C++:</p>
<pre><code class="language-cpp">template &lt;typename T&gt;
T sqr(x: T) {
    return x * x;
}
</code></pre>
<p>but (to be honest) C++ is adopting cowboy tactics here. C++ template errors are famously
bad, because all the compiler knows (ultimately) is that some operator or method is
not defined. The C++ committee knows this is a problem and so they are working
toward <a href="https://en.wikipedia.org/wiki/Concepts_(C%2B%2B)">concepts</a>, which are pretty
much like trait-constrained type parameters in Rust.</p>
<p>Rust generic functions may look a bit overwhelming at first, but being explicit means
you will know exactly what kind of values you can safely feed it, just by looking at the
definition.</p>
<p>These functions are called <em>monomorphic</em>, in constrast to <em>polymorphic</em>. The body of
the function is compiled separately for each unique type.  With polymorphic functions,
the same machine code works with each matching type, dynamically <em>dispatching</em>
the correct method.</p>
<p>Monomorphic produces faster code,
specialized for the particular type, and can often be <em>inlined</em>.  So when <code>sqr(x)</code> is
seen, it's effectively replaced with <code>x*x</code>.  The downside is that large generic
functions produce a lot of code, for each type used, which can result in <em>code bloat</em>.
As always, there are trade-offs; an experienced person learns to make the right choice
for the job.</p>
<a class="header" href="print.html#simple-enums" name="simple-enums"><h2>Simple Enums</h2></a>
<p>Enums are types which have a few definite values. For instance, a direction has
only four possible values.</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
# 
#fn main() {
enum Direction {
    Up,
    Down,
    Left,
    Right
}
...
    // `start` is type `Direction`
    let start = Direction::Left;

#}</code></pre></pre>
<p>They can have methods defined on them, just like structs.
The  <code>match</code> expression is the basic way to handle <code>enum</code> values.</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
# 
#fn main() {
impl Direction {
    fn as_str(&amp;self) -&gt; &amp;'static str {
        match *self { // *self has type Direction
            Direction::Up =&gt; &quot;Up&quot;,
            Direction::Down =&gt; &quot;Down&quot;,
            Direction::Left =&gt; &quot;Left&quot;,
            Direction::Right =&gt; &quot;Right&quot;
        }
    }
}

#}</code></pre></pre>
<p>Punctuation matters. Note that <code>*</code> before <code>self</code>. It's easy to forget, because often
Rust will assume it (we said <code>self.first_name</code>, not <code>(*self).first_name</code>). However,
matching is a more exact business. Leaving it out would give a whole spew of messages,
which boil down to this type mismatch:</p>
<pre><code>   = note: expected type `&amp;Direction`
   = note:    found type `Direction`
</code></pre>
<p>This is because <code>self</code> has type <code>&amp;Direction</code>, so we have to throw in the <code>*</code> to
<em>deference</em> the type.</p>
<p>Like structs, enums can implement traits, and our friend <code>#[derive(Debug)]</code> can
be added to <code>Direction</code>:</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
# 
#fn main() {
        println!(&quot;start {:?}&quot;,start);
        // start Left

#}</code></pre></pre>
<p>So that <code>as_str</code> method isn't really necessary, since we can always get the name from <code>Debug</code>.
(But <code>as_str</code> does <em>not allocate</em>, which may be important.)</p>
<p>You should not assume any particular ordering here - there's no implied integer
'ordinal' value.</p>
<p>Here's a method which defines the 'successor' of each <code>Direction</code> value. The
very handy <em>wildcard use</em> temporarily puts the enum names into the method context:</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
# 
#fn main() {
    fn next(&amp;self) -&gt; Direction {
        use Direction::*;
        match *self {
            Up =&gt; Right,
            Right =&gt; Down,
            Down =&gt; Left,
            Left =&gt; Up
        }
    }
    ...

    let mut d = start;
    for _ in 0..8 {
        println!(&quot;d {:?}&quot;, d);
        d = d.next();
    }
    // d Left
    // d Up
    // d Right
    // d Down
    // d Left
    // d Up
    // d Right
    // d Down

#}</code></pre></pre>
<p>So this will cycle endlessly through the various directions in this particular, arbitrary,
order. It is (in fact) a very simple <em>state machine</em>.</p>
<p>These enum values can't be compared:</p>
<pre><code>assert_eq!(start, Direction::Left);

error[E0369]: binary operation `==` cannot be applied to type `Direction`
  --&gt; enum1.rs:42:5
   |
42 |     assert_eq!(start, Direction::Left);
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
   |
note: an implementation of `std::cmp::PartialEq` might be missing for `Direction`
  --&gt; enum1.rs:42:5
</code></pre>
<p>The solution is to say <code>#[derive(Debug,PartialEq)]</code> in front of <code>enum Direction</code>.</p>
<p>This is an important point - Rust user-defined types start out fresh and unadorned.
You give them sensible default behaviours by implementing the common traits. This
applies also to structs - if you ask for Rust to derive <code>PartialEq</code> for a struct it
will do the sensible thing, assume that all fields implement it and build up
a comparison. If this isn't so, or you want to redefine equality, then you are free
to define <code>PartialEq</code> explicitly.</p>
<p>Rust does 'C style enums' as well:</p>
<pre><pre class="playpen"><code class="language-rust">// enum2.rs

enum Speed {
    Slow = 10,
    Medium = 20,
    Fast = 50
}

fn main() {
    let s = Speed::Slow;
    let speed = s as u32;
    println!(&quot;speed {}&quot;, speed);
}
</code></pre></pre>
<p>They are initialized with an integer value, and can be converted into that integer
with a type cast.</p>
<p>You only need to give the first name a value, and thereafter the
value goes up by one each time:</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
# 
#fn main() {
enum Difficulty {
    Easy = 1,
    Medium,  // is 2
    Hard   // is 3
}

#}</code></pre></pre>
<p>By the way, 'name' is too vague, like saying 'thingy' all the time. The proper term here
is <em>variant</em> - <code>Speed</code> has variants <code>Slow</code>,<code>Medium</code> and <code>Fast</code>.</p>
<p>These enums <em>do</em> have a natural ordering, but you have to ask nicely.
After placing <code>#[derive(PartialEq,PartialOrd)]</code> in front of <code>enum Speed</code>, then it's indeed
true that <code>Speed::Fast &gt; Speed::Slow</code> and <code>Speed::Medium != Speed::Slow</code>.</p>
<a class="header" href="print.html#enums-in-their-full-glory" name="enums-in-their-full-glory"><h2>Enums in their Full Glory</h2></a>
<p>Rust enums in their full form are like C unions on steroids, like a Ferrari compared
to a Fiat Uno. Consider the problem of storing different values in a type-safe way.</p>
<pre><pre class="playpen"><code class="language-rust">// enum3.rs

#[derive(Debug)]
enum Value {
    Number(f64),
    Str(String),
    Bool(bool)
}

fn main() {
    use Value::*;
    let n = Number(2.3);
    let s = Str(&quot;hello&quot;.to_string());
    let b = Bool(true);

    println!(&quot;n {:?} s {:?} b {:?}&quot;, n,s,b);
}
// n Number(2.3) s Str(&quot;hello&quot;) b Bool(true)
</code></pre></pre>
<p>Again, this enum can only contain <em>one</em> of these values; its size will be the size of
the largest variant.</p>
<p>So far, not really a supercar, although it's cool that enums know how to print themselves
out. But they also know how <em>what kind</em> of value they contain, and <em>that</em> is the
superpower of <code>match</code>:</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
# 
#fn main() {
fn eat_and_dump(v: Value) {
    use Value::*;
    match v {
        Number(n) =&gt; println!(&quot;number is {}&quot;, n),
        Str(s) =&gt; println!(&quot;string is '{}'&quot;, s),
        Bool(b) =&gt; println!(&quot;boolean is {}&quot;, b)
    }
}
....
eat_and_dump(n);
eat_and_dump(s);
eat_and_dump(b);
//number is 2.3
//string is 'hello'
//boolean is true

#}</code></pre></pre>
<p>(And that's what <code>Option</code> and <code>Result</code> are - enums.)</p>
<p>We like this <code>eat_and_dump</code> function, but we want to pass the value as a reference, because currently
a move takes place and the value is 'eaten':</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
# 
#fn main() {
fn dump(v: &amp;Value) {
    use Value::*;
    match *v {  // type of *v is Value
        Number(n) =&gt; println!(&quot;number is {}&quot;, n),
        Str(s) =&gt; println!(&quot;string is '{}'&quot;, s),
        Bool(b) =&gt; println!(&quot;boolean is {}&quot;, b)
    }
}

error[E0507]: cannot move out of borrowed content
  --&gt; enum3.rs:12:11
   |
12 |     match *v {
   |           ^^ cannot move out of borrowed content
13 |     Number(n) =&gt; println!(&quot;number is {}&quot;,n),
14 |     Str(s) =&gt; println!(&quot;string is '{}'&quot;,s),
   |         - hint: to prevent move, use `ref s` or `ref mut s`

#}</code></pre></pre>
<p>There are things you cannot do with borrowed references. Rust is not letting
you <em>extract</em> the string contained in the original value. It did not complain about <code>Number</code>
because it's happy to copy <code>f64</code>, but <code>String</code> does not implement <code>Copy</code>.</p>
<p>I mentioned earlier that <code>match</code> is picky about <em>exact</em> types;
here we follow the hint and things will work; now we are just borrowing a reference
to that contained string.</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
# 
#fn main() {
fn dump(v: &amp;Value) {
    use Value::*;
    match *v {
        Number(n) =&gt; println!(&quot;number is {}&quot;, n),
        Str(ref s) =&gt; println!(&quot;string is '{}'&quot;, s),
        Bool(b) =&gt; println!(&quot;boolean is {}&quot;, b)
    }
}
    ....

    dump(&amp;s);
    // string is 'hello'

#}</code></pre></pre>
<p>Before we move on, filled with the euphoria of a successful Rust compilation, let's
pause a little. <code>rustc</code> is unusually good at generating errors that have enough
context for a human to <em>fix</em> the error without necessarily <em>understanding</em> the error.</p>
<p>The issue is a combination of the exactness of matching, with the determination of the
borrow checker to foil any attempt to break the Rules.  One of those Rules is that
you cannot yank out a value which belongs to some owning type. Some knowledge of
C++ is a hindrance here, since C++ will copy its way out of the problem, whether that
copy even <em>makes sense</em>.  You will get exactly the same error if you try to pull out
a string from a vector, say with <code>*v.get(0).unwrap()</code> (<code>*</code> because indexing returns references.)
It will simply not let you do this. (Sometimes <code>clone</code> isn't such a bad solution to this.)</p>
<p>(By the way, <code>v[0]</code> does not work for non-copyable values like strings for precisely this reason.
You must either borrow with <code>&amp;v[0]</code> or clone with <code>v[0].clone()</code>)</p>
<p>As for <code>match</code>, you can see <code>Str(s) =&gt;</code> as short for <code>Str(s: String) =&gt;</code>. A local variable
(often called a <em>binding</em>) is created.  Often that inferred type is cool, when you
eat up a value and extract its contents. But here we really needed is <code>s: &amp;String</code>, and the
<code>ref</code> is a hint that ensures this: we just want to borrow that string.</p>
<p>Here we do want to extract that string, and don't care about
the enum value afterwards. <code>_</code> as usual will match anything.</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
# 
#fn main() {
impl Value {
    fn to_str(self) -&gt; Option&lt;String&gt; {
        match self {
        Value::Str(s) =&gt; Some(s),
        _ =&gt; None
        }
    }
}
    ...
    println!(&quot;s? {:?}&quot;, s.to_str());
    // s? Some(&quot;hello&quot;)
    // println!(&quot;{:?}&quot;, s) // error! s has moved...

#}</code></pre></pre>
<p>Naming matters - this is called <code>to_str</code>, not <code>as_str</code>. You can write a
method that just borrows that string as an <code>Option&lt;&amp;String&gt;</code> (The reference will need
the same lifetime as the enum value.)  But you would not call it <code>to_str</code>.</p>
<p>You can write <code>to_str</code> like this - it is completely equivalent:</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
# 
#fn main() {
    fn to_str(self) -&gt; Option&lt;String&gt; {
        if let Value::Str(s) = self {
            Some(s)
        } else {
            None
        }
    }

#}</code></pre></pre>
<a class="header" href="print.html#more-about-matching" name="more-about-matching"><h2>More about Matching</h2></a>
<p>Recall that the values of a tuple can be extracted with '()':</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
# 
#fn main() {
    let t = (10,&quot;hello&quot;.to_string());
    ...
    let (n,s) = t;
    // t has been moved. It is No More
    // n is i32, s is String

#}</code></pre></pre>
<p>This is a special case of <em>destructuring</em>; we have some
data and wish to either pull it apart (like here) or just borrow its values.
Either way, we get the parts of a structure.</p>
<p>The syntax is like that used in <code>match</code>. Here
we are explicitly borrowing the values.</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
# 
#fn main() {
    let (ref n,ref s) = t;
    // n and s are borrowed from t. It still lives!
    // n is &amp;i32, s is &amp;String

#}</code></pre></pre>
<p>Destructuring works with structs as well:</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
# 
#fn main() {
    struct Point {
        x: f32,
        y: f32
    }

    let p = Point{x:1.0,y:2.0};
    ...
    let Point{x,y} = p;
    // p still lives, since x and y can and will be copied
    // both x and y are f32

#}</code></pre></pre>
<p>Time to revisit <code>match</code> with some new patterns. The first two patterns are exactly like <code>let</code>
destructuring - it only matches tuples with first element zero, but <em>any</em> string;
the second adds an <code>if</code> so that it only matches <code>(1,&quot;hello&quot;)</code>.
Finally, just a variable matches <em>anything</em>. This is useful if the <code>match</code> applies
to an expression and you don't want to bind a variable to that expression. <code>_</code> works
like a variable but is ignored. It's a common
way to finish off a <code>match</code>.</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
# 
#fn main() {
fn match_tuple(t: (i32,String)) {
    let text = match t {
        (0, s) =&gt; format!(&quot;zero {}&quot;, s),
        (1, ref s) if s == &quot;hello&quot; =&gt; format!(&quot;hello one!&quot;),
        tt =&gt; format!(&quot;no match {:?}&quot;, tt),
        // or say _ =&gt; format!(&quot;no match&quot;) if you're not interested in the value
     };
    println!(&quot;{}&quot;, text);
}

#}</code></pre></pre>
<p>Why not just match against <code>(1,&quot;hello&quot;)</code>? Matching is an exact business, and the compiler
will complain:</p>
<pre><code>  = note: expected type `std::string::String`
  = note:    found type `&amp;'static str`
</code></pre>
<p>Why do we need <code>ref s</code>? It's a slightly obscure gotcha (look up the E00008 error) where
if you have an <em>if guard</em> you need to borrow, since the if guard happens in a different
context, a move will take place otherwise. It's a case of the implementation leaking
ever so slightly.</p>
<p>If the type <em>was</em> <code>&amp;str</code> then we match it directly:</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
# 
#fn main() {
    match (42,&quot;answer&quot;) {
        (42,&quot;answer&quot;) =&gt; println!(&quot;yes&quot;),
        _ =&gt; println!(&quot;no&quot;)
    };

#}</code></pre></pre>
<p>What applies to <code>match</code> applies to <code>if let</code>. This is a cool example, since if we
get a <code>Some</code>, we can match inside it and only extract the string from the tuple. So it
isn't necessary to have nested <code>if let</code> statements here. We use <code>_</code> because we aren't interested
in the first part of the tuple.</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
# 
#fn main() {
    let ot = Some((2,&quot;hello&quot;.to_string());

    if let Some((_,ref s)) = ot {
        assert_eq!(s, &quot;hello&quot;);
    }
    // we just borrowed the string, no 'destructive destructuring'

#}</code></pre></pre>
<p>An interesting problem happens when using <code>parse</code> (or any function which needs to work
out its return type from context)</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
# 
#fn main() {
    if let Ok(n) = &quot;42&quot;.parse() {
        ...
    }

#}</code></pre></pre>
<p>So what's the type of <code>n</code>? You have to give a hint somehow - what kind of integer? Is it
even an integer?</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
# 
#fn main() {
    if let Ok(n) = &quot;42&quot;.parse::&lt;i32&gt;() {
        ...
    }

#}</code></pre></pre>
<p>This somewhat non-elegant syntax is called the 'turbofish operator'.</p>
<p>If you are in a function returning <code>Result</code>, then the question-mark operator provides a much
more elegant solution:</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
# 
#fn main() {
    let n: i32 = &quot;42&quot;.parse()?;

#}</code></pre></pre>
<p>However, the parse error needs to be convertible to the error type of the <code>Result</code>, which is a topic
we'll take up later when discussing <a href="6-error-handling.html">error handling</a>.</p>
<a class="header" href="print.html#closures" name="closures"><h2>Closures</h2></a>
<p>A great deal of Rust's power comes from <em>closures</em>. In their simplest form, they
act like shortcut functions:</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
# 
#fn main() {
    let f = |x| x * x;

    let res = f(10);

    println!(&quot;res {}&quot;, res);
    // res 100

#}</code></pre></pre>
<p>There are no explicit types in this example - everything is deduced, starting with the
integer literal 10.</p>
<p>We get an error if we call <code>f</code> on different types - Rust has already decided that
<code>f</code> must be called on an integer type:</p>
<pre><code>    let res = f(10);

    let resf = f(1.2);
  |
8 |     let resf = f(1.2);
  |                  ^^^ expected integral variable, found floating-point variable
  |
  = note: expected type `{integer}`
  = note:    found type `{float}`

</code></pre>
<p>So, the first call fixes the type of the argument <code>x</code>. It's equivalent to this function:</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
# 
#fn main() {
    fn f (x: i32) -&gt; i32 {
        x * x
    }

#}</code></pre></pre>
<p>But there's a big difference between functions and closures, <em>apart</em> from the need for explicit typing.
Here we evaluate a linear function:</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
# 
#fn main() {
    let m = 2.0;
    let c = 1.0;

    let lin = |x| m*x + c;

    println!(&quot;res {} {}&quot;, lin(1.0), lin(2.0));
    // res 3 5

#}</code></pre></pre>
<p>You cannot do this with the explicit <code>fn</code> form - it does not know about variables
in the enclosing scope. The closure has <em>borrowed</em> <code>m</code> and <code>c</code> from its context.</p>
<p>Now, what's the type of <code>lin</code>? Only <code>rustc</code> knows.
Under the hood, a closure is a <em>struct</em> that is callable ('implements the call operator').
It behaves as if it was written out like this:</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
# 
#fn main() {
struct MyAnonymousClosure1&lt;'a&gt; {
    m: &amp;'a f64,
    c: &amp;'a f64
}

impl &lt;'a&gt;MyAnonymousClosure1&lt;'a&gt; {
    fn call(&amp;self, x: f64) -&gt; f64 {
        self.m * x  + self.c
    }
}

#}</code></pre></pre>
<p>The compiler is certainly being helpful, turning simple closure syntax into all
that code! You do need to know that a closure is a <em>struct</em> and it <em>borrows</em> values
from its environment. And that therefore it has a <em>lifetime</em>.</p>
<p>All closures are unique types, but they have traits in common.
So even though we don't know the exact type, we know the generic constraint:</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
# 
#fn main() {
fn apply&lt;F&gt;(x: f64, f: F) -&gt; f64
where F: Fn(f64)-&gt;f64  {
    f(x)
}
...
    let res1 = apply(3.0,lin);
    let res2 = apply(3.14, |x| x.sin());

#}</code></pre></pre>
<p>In English: <code>apply</code> works for <em>any</em> type <code>T</code> such that <code>T</code> implements <code>Fn(f64)-&gt;f64</code> - that
is, is a function which takes <code>f64</code> and returns <code>f64</code>.</p>
<p>After the call to <code>apply(3.0,lin)</code>, trying to access <code>lin</code> gives an interesting error:</p>
<pre><code>    let l = lin;
error[E0382]: use of moved value: `lin`
  --&gt; closure2.rs:22:9
   |
16 |     let res = apply(3.0,lin);
   |                         --- value moved here
...
22 |     let l = lin;
   |         ^ value used here after move
   |
   = note: move occurs because `lin` has type
    `[closure@closure2.rs:12:15: 12:26 m:&amp;f64, c:&amp;f64]`,
     which does not implement the `Copy` trait

</code></pre>
<p>That's it, <code>apply</code> ate our closure. And there's the actual type of the struct that
<code>rustc</code> made up to implement it. Always thinking of closures as structs is helpful.</p>
<p>Calling a closure is a <em>method call</em>:  the three kinds of function traits
correspond to the three kinds of methods:</p>
<ul>
<li><code>Fn</code> struct passed as <code>&amp;self</code></li>
<li><code>FnMut</code> struct passed as <code>&amp;mut self</code></li>
<li><code>FnOnce</code> struct passed as <code>self</code></li>
</ul>
<p>So it's possible for a closure to mutate its <em>captured</em> references:</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
# 
#fn main() {
    fn mutate&lt;F&gt;(mut f: F)
    where F: FnMut() {
        f()
    }
    let mut s = &quot;world&quot;;
    mutate(|| s = &quot;hello&quot;);
    assert_eq!(s, &quot;hello&quot;);

#}</code></pre></pre>
<p>Note that <code>mut</code> - <code>f</code> needs to be mutable for this to work.</p>
<p>However, you cannot escape the rules for borrowing. Consider this:</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
# 
#fn main() {
let mut s = &quot;world&quot;;

// closure does a mutable borrow of s
let mut changer = || s = &quot;world&quot;;

changer();
// does an immutable borrow of s
assert_eq!(s, &quot;world&quot;);

#}</code></pre></pre>
<p>Can't be done! The error is that we cannot borrow <code>s</code>
in the assert statement, because it has been previously borrowed by the
closure <code>changer</code> as mutable. As long as that closure lives, no other
code can access <code>s</code>, so the solution is to control that lifetime by
putting the closure in a limited scope:</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
# 
#fn main() {
let mut s = &quot;world&quot;;
{
    let mut changer = || s = &quot;world&quot;;
    changer();
}
assert_eq!(s, &quot;world&quot;);

#}</code></pre></pre>
<p>At this point, if you are used to languages like JavaScript or Lua, you may wonder at the
complexity of Rust closures compared with how straightforward they are in those languages.
This is the necessary cost of Rust's promise to not sneakily make any allocations. In JavaScript,
the equivalent <code>mutate(function() {s = &quot;hello&quot;;})</code> will always result in a dynamically
allocated closure.</p>
<p>Sometimes you don't want a closure to borrow those variables, but instead <em>move</em> them.</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
# 
#fn main() {
    let name = &quot;dolly&quot;.to_string();
    let age = 42;

    let c = move || {
        println!(&quot;name {} age {}&quot;, name,age);
    };

    c();

    println!(&quot;name {}&quot;,name);

#}</code></pre></pre>
<p>And the error at the last <code>println</code> is: &quot;use of moved value: <code>name</code>&quot;. So one solution
here - if we <em>did</em> want to keep <code>name</code> alive - is to move a cloned copy into the closure:</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
# 
#fn main() {
    let cname = name.to_string();
    let c = move || {
        println!(&quot;name {} age {}&quot;,cname,age);
    };

#}</code></pre></pre>
<p>Why are moved closures needed? Because we might need to call them at a point where
the original context no longer exists.
A classic case is when creating a <em>thread</em>.
A moved closure does not borrow, so does not have a lifetime.</p>
<p>A major use of closures is within iterator methods. Recall the <code>range</code> iterator we
defined to go over a range of floating-point numbers. It's straightforward to operate
on this (or any other iterator) using closures:</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
# 
#fn main() {
    let sine: Vec&lt;f64&gt; = range(0.0,1.0,0.1).map(|x| x.sin()).collect();

#}</code></pre></pre>
<p><code>map</code> isn't defined on vectors (although it's easy enough to create a trait that does this),
because then <em>every</em> map  will create a new vector.  This way, we have a choice. In this
sum, no temporary objects are created:</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
# 
#fn main() {
 let sum: f64 = range(0.0,1.0,0.1).map(|x| x.sin()).sum();

#}</code></pre></pre>
<p>It will (in fact) be as fast as writing it out as an explicit loop! That performance
guarantee would be impossible if Rust closures were as 'frictionless'
as Javascript closures.</p>
<p><code>filter</code> is another useful iterator method - it only lets through values that match
a condition:</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
# 
#fn main() {
    let tuples = [(10,&quot;ten&quot;),(20,&quot;twenty&quot;),(30,&quot;thirty&quot;),(40,&quot;forty&quot;)];
    let iter = tuples.iter().filter(|t| t.0 &gt; 20).map(|t| t.1);

    for name in iter {
        println!(&quot;{} &quot;, name);
    }
    // thirty
    // forty

#}</code></pre></pre>
<a class="header" href="print.html#the-three-kinds-of-iterators" name="the-three-kinds-of-iterators"><h2>The Three Kinds of Iterators</h2></a>
<p>The three kinds correspond (again) to the three basic argument types. Assume we
have a vector of <code>String</code> values. Here are the iterator types explicitly, and
then <em>implicitly</em>, together with the actual type returned by the iterator.</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
# 
#fn main() {
for s in vec.iter() {...} // &amp;String
for s in vec.iter_mut() {...} // &amp;mut String
for s in vec.into_iter() {...} // String

// implicit!
for s in &amp;vec {...} // &amp;String
for s in &amp;mut vec {...} // &amp;mut String
for s in vec {...} // String

#}</code></pre></pre>
<p>Personally I prefer being explicit, but it's important to understand both forms,
and their implications.</p>
<p><code>into_iter</code> <em>consumes</em> the vector and extracts its strings,
and so afterwards the vector is no longer available - it has been moved. It's
a definite gotcha for Pythonistas used to saying <code>for s in vec</code>!</p>
<p>So the
implicit form <code>for s in &amp;vec</code> is usually the one you want, just as <code>&amp;T</code> is a good
default in passing arguments to functions.</p>
<p>It's important to understand how the three kinds works because Rust relies heavily
on type deduction - you won't often see explicit types in closure arguments. And this
is a Good Thing, because it would be noisy if all those types were explicitly
<em>typed out</em>. However, the price of this compact code is that you need to know
what the implicit types actually are!</p>
<p><code>map</code> takes whatever value the iterator returns and converts it into something else,
but <code>filter</code> takes a <em>reference</em> to that value. In this case, we're using <code>iter</code> so
the iterator item type is <code>&amp;String</code>. Note that <code>filter</code> receives a reference to this type.</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
# 
#fn main() {
for n in vec.iter().map(|x: &amp;String| x.len()) {...} // n is usize
....
}

for s in vec.iter().filter(|x: &amp;&amp;String| x.len() &gt; 2) { // s is &amp;String
...
}

#}</code></pre></pre>
<p>When calling methods, Rust will derefence automatically, so the problem isn't obvious.
But <code>|x: &amp;&amp;String| x == &quot;one&quot;|</code> will <em>not</em> work, because operators are more strict
about type matching. <code>rustc</code> will complain that there is no such operator that
compares <code>&amp;&amp;String</code> and <code>&amp;str</code>. So you need an explicit deference to make that <code>&amp;&amp;String</code>
into a <code>&amp;String</code> which <em>does</em> match.</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
# 
#fn main() {
for s in vec.iter().filter(|x: &amp;&amp;String| *x == &quot;one&quot;) {...}
// same as implicit form:
for s in vec.iter().filter(|x| *x == &quot;one&quot;) {...}

#}</code></pre></pre>
<p>If you leave out the explicit type, you can modify the argument so that the type of <code>s</code>
is now <code>&amp;String</code>:</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
# 
#fn main() {
for s in vec.iter().filter(|&amp;x| x == &quot;one&quot;)

#}</code></pre></pre>
<p>And that's usually how you will see it written.</p>
<a class="header" href="print.html#structs-with-dynamic-data" name="structs-with-dynamic-data"><h2>Structs with Dynamic Data</h2></a>
<p>A most powerful technique is <em>a struct that contain references to itself</em>.</p>
<p>Here is the basic building block of a <em>binary tree</em>, expressed in C (everyone's
favourite old relative with a frightening fondness for using power tools without
protection.)</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
# 
#fn main() {
    struct Node {
        const char *payload;
        struct Node *left;
        struct Node *right;
    };

#}</code></pre></pre>
<p>You can not do this by <em>directly</em> including <code>Node</code> fields, because then the size of
<code>Node</code> depends on the size of <code>Node</code>... it just doesn't compute. So we use pointers
to <code>Node</code> structs, since the size of a pointer is always known.</p>
<p>If <code>left</code> isn't <code>NULL</code>, the <code>Node</code> will have a left pointing to another node, and so
moreorless indefinitely.</p>
<p>Rust does not do <code>NULL</code> (at least not <em>safely</em>) so it's clearly a job for <code>Option</code>.
But you cannot just put a <code>Node</code> in that <code>Option</code>, because we don't know the size
of <code>Node</code> (and so forth.)  This is a job for <code>Box</code>, since it contains an allocated
pointer to the data, and always has a fixed size.</p>
<p>So here's the Rust equivalent, using <code>type</code> to create an alias:</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
# 
#fn main() {
type NodeBox = Option&lt;Box&lt;Node&gt;&gt;;

#[derive(Debug)]
struct Node {
    payload: String,
    left: NodeBox,
    right: NodeBox
}

#}</code></pre></pre>
<p>(Rust is forgiving in this way - no need for forward declarations.)</p>
<p>And a first test program:</p>
<pre><pre class="playpen"><code class="language-rust">impl Node {
    fn new(s: &amp;str) -&gt; Node {
        Node{payload: s.to_string(), left: None, right: None}
    }

    fn boxer(node: Node) -&gt; NodeBox {
        Some(Box::new(node))
    }

    fn set_left(&amp;mut self, node: Node) {
        self.left = Self::boxer(node);
    }

    fn set_right(&amp;mut self, node: Node) {
        self.right = Self::boxer(node);
    }

}


fn main() {
    let mut root = Node::new(&quot;root&quot;);
    root.set_left(Node::new(&quot;left&quot;));
    root.set_right(Node::new(&quot;right&quot;));

    println!(&quot;arr {:#?}&quot;, root);
}
</code></pre></pre>
<p>The output is surprisingly pretty, thanks to &quot;{:#?}&quot; ('#' means 'extended'.)</p>
<pre><code>root Node {
    payload: &quot;root&quot;,
    left: Some(
        Node {
            payload: &quot;left&quot;,
            left: None,
            right: None
        }
    ),
    right: Some(
        Node {
            payload: &quot;right&quot;,
            left: None,
            right: None
        }
    )
}
</code></pre>
<p>Now, what happens when <code>root</code> is dropped? All fields are dropped; if the 'branches' of
the tree are dropped, they drop <em>their</em> fields and so on. <code>Box::new</code> may be the
closest you will get to a <code>new</code> keyword, but we have no need for <code>delete</code> or <code>free</code>.</p>
<p>We must now work out a use for this tree. Note that strings can be ordered:
'bar' &lt; 'foo', 'abba' &gt; 'aardvark'; so-called 'alphabetical order'. (Strictly speaking, this
is <em>lexical order</em>, since human languages are very diverse and have strange rules.)</p>
<p>Here is a method which inserts nodes in lexical order of the strings. We compare the new data
to the current node - if it's less, then we try to insert on the left, otherwise try to insert
on the right. There may be no node on the left, so then <code>set_left</code> and so forth.</p>
<pre><pre class="playpen"><code class="language-rust">    fn insert(&amp;mut self, data: &amp;str) {
        if data &lt; &amp;self.payload {
            match self.left {
                Some(ref mut n) =&gt; n.insert(data),
                None =&gt; self.set_left(Self::new(data)),
            }
        } else {
            match self.right {
                Some(ref mut n) =&gt; n.insert(data),
                None =&gt; self.set_right(Self::new(data)),
            }
        }
    }

    ...
    fn main() {
        let mut root = Node::new(&quot;root&quot;);
        root.insert(&quot;one&quot;);
        root.insert(&quot;two&quot;);
        root.insert(&quot;four&quot;);

        println!(&quot;root {:#?}&quot;, root);
    }
</code></pre></pre>
<p>Note the <code>match</code> - we're pulling out a mutable reference to the box, if the <code>Option</code>
is <code>Some</code>, and applying the <code>insert</code> method. Otherwise, we need to create a new <code>Node</code>
for the left side and so forth. <code>Box</code> is a <em>smart</em> pointer; note that no 'unboxing' was
needed to call <code>Node</code> methods on it!</p>
<p>And here's the output tree:</p>
<pre><code>root Node {
    payload: &quot;root&quot;,
    left: Some(
        Node {
            payload: &quot;one&quot;,
            left: Some(
                Node {
                    payload: &quot;four&quot;,
                    left: None,
                    right: None
                }
            ),
            right: None
        }
    ),
    right: Some(
        Node {
            payload: &quot;two&quot;,
            left: None,
            right: None
        }
    )
}
</code></pre>
<p>The strings that are 'less' than other strings get put down the left side, otherwise
the right side.</p>
<p>Time for a visit. This is <em>in-order traversal</em> - we visit the left, do something on
the node, and then visit the right.</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
# 
#fn main() {
    fn visit(&amp;self) {
        if let Some(ref left) = self.left {
            left.visit();
        }
        println!(&quot;'{}'&quot;, self.payload);
        if let Some(ref right) = self.right {
            right.visit();
        }
    }
    ...
    ...
    root.visit();
    // 'four'
    // 'one'
    // 'root'
    // 'two'

#}</code></pre></pre>
<p>So we're visiting the strings in order! Please note the reappearance of <code>ref</code> - <code>if let</code>
uses exactly the same rules as <code>match</code>.</p>
<a class="header" href="print.html#generic-structs" name="generic-structs"><h2>Generic Structs</h2></a>
<p>Consider the previous example of a binary tree. It would be <em>seriously irritating</em> to
have to rewrite it for all possible kinds of payload.
So here's our generic <code>Node</code> with its type parameter <code>T</code>.</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
# 
#fn main() {
type NodeBox&lt;T&gt; = Option&lt;Box&lt;Node&lt;T&gt;&gt;&gt;;

#[derive(Debug)]
struct Node&lt;T&gt; {
    payload: T,
    left: NodeBox&lt;T&gt;,
    right: NodeBox&lt;T&gt;
}

#}</code></pre></pre>
<p>The implementation shows the difference between the languages. The fundamental operation
on the payload is comparison, so T must be comparable with <code>&lt;</code>, i.e. implements <code>PartialOrd</code>.
The type parameter must be declared in the <code>impl</code> block with its constraints:</p>
<pre><pre class="playpen"><code class="language-rust">impl &lt;T: PartialOrd&gt; Node&lt;T&gt; {
    fn new(s: T) -&gt; Node&lt;T&gt; {
        Node{payload: s, left: None, right: None}
    }

    fn boxer(node: Node&lt;T&gt;) -&gt; NodeBox&lt;T&gt; {
        Some(Box::new(node))
    }

    fn set_left(&amp;mut self, node: Node&lt;T&gt;) {
        self.left = Self::boxer(node);
    }

    fn set_right(&amp;mut self, node: Node&lt;T&gt;) {
        self.right = Self::boxer(node);
    }

    fn insert(&amp;mut self, data: T) {
        if data &lt; self.payload {
            match self.left {
                Some(ref mut n) =&gt; n.insert(data),
                None =&gt; self.set_left(Self::new(data)),
            }
        } else {
            match self.right {
                Some(ref mut n) =&gt; n.insert(data),
                None =&gt; self.set_right(Self::new(data)),
            }
        }
    }
}


fn main() {
    let mut root = Node::new(&quot;root&quot;.to_string());
    root.insert(&quot;one&quot;.to_string());
    root.insert(&quot;two&quot;.to_string());
    root.insert(&quot;four&quot;.to_string());

    println!(&quot;root {:#?}&quot;, root);
}
</code></pre></pre>
<p>So generic structs need their type parameter(s) specified
in angle brackets, like C++. Rust is usually smart enough to work out
that type parameter from context - it knows it has a <code>Node&lt;T&gt;</code>, and knows
that its <code>insert</code> method is passed <code>T</code>. The first call of <code>insert</code> nails
down <code>T</code> to be <code>String</code>. If any further calls are inconsistent it will complain.</p>
<p>But you do need to constrain that type appropriately!</p>
<a class="header" href="print.html#filesystem-and-processes" name="filesystem-and-processes"><h1>Filesystem and Processes</h1></a>
<a class="header" href="print.html#another-look-at-reading-files" name="another-look-at-reading-files"><h2>Another look at Reading Files</h2></a>
<p>At the end of Part 1, I showed how to read a whole file into a string. Naturally
this isn't always such a good idea, so here is how to read a file line-by-line.</p>
<p><code>fs::File</code> implements <code>io::Read</code>, which is the trait for anything readable.
This trait defines a <code>read</code> method which will fill a slice of <code>u8</code> with bytes -
this is the only <em>required</em> method of the trait, and you get some <em>provided</em> methods
for free, much like with <code>Iterator</code>.  You can use <code>read_to_end</code> to fill a vector of
bytes with contents from the readable, and <code>read_to_string</code> to fill a string - which
must be UTF-8 encoded.</p>
<p>This is a 'raw' read, with no buffering. For buffered reading there is the
<code>io::BufRead</code> trait which gives us <code>read_line</code> and a <code>lines</code> iterator.
<code>io::BufReader</code> will provide an implementation of <code>io::BufRead</code> for <em>any</em> readable.</p>
<p><code>fs::File</code> <em>also</em> implements <code>io::Write</code>.</p>
<p>The easiest way to make sure all these traits are visible is <code>use std::io::prelude::*</code>.</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
# 
#fn main() {
use std::fs::File;
use std::io;
use std::io::prelude::*;

fn read_all_lines(filename: &amp;str) -&gt; io::Result&lt;()&gt; {
    let file = File::open(&amp;filename)?;

    let reader = io::BufReader::new(file);

    for line in reader.lines() {
        let line = line?;
        println!(&quot;{}&quot;, line);
    }
    Ok(())
}

#}</code></pre></pre>
<p>The <code>let line = line?</code> may look a bit strange. The <code>line</code> returned by the
iterator is actually an <code>io::Result&lt;String&gt;</code> which we unwrap with <code>?</code>.
Because things <em>can</em> go wrong during this iteration - I/O errors, swallowing
a chunk of bytes that aren't UTF-8, and so forth.</p>
<p><code>lines</code> being an iterator, it is straightforward to read a file into a vector
of strings using <code>collect</code>, or print out the line with line numbers using the
<code>enumerate</code> iterator.</p>
<p>It isn't the most efficient way to read all the lines, however, because a new
string is allocated for each line. It is more efficient to use <code>read_line</code>, although
more awkward. Note that the returned line includes the linefeed, which
can be removed using <code>trim_right</code>.</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
# 
#fn main() {
    let mut reader = io::BufReader::new(file);
    let mut buf = String::new();
    while reader.read_line(&amp;mut buf)? &gt; 0 {
        {
            let line = buf.trim_right();
            println!(&quot;{}&quot;, line);
        }
        buf.clear();
    }

#}</code></pre></pre>
<p>This results in far less allocations, because <em>clearing</em> that string does not free its
allocated memory; once the string has enough capacity, no more allocations will take
place.</p>
<p>This is one of those cases where we use a block to control a borrow. <code>line</code> is
borrowed from <code>buf</code>, and this borrow must finish before we modify <code>buf</code>.  Again,
Rust is trying to stop us doing something stupid, which is to access <code>line</code> <em>after</em>
we've cleared the buffer. (The borrow checker can be restrictive sometimes.
Rust is due to get 'non-lexical lifetimes', where
it will analyze the code and see that <code>line</code> isn't used after <code>buf.clear()</code>.)</p>
<p>This isn't very pretty. I cannot give you a proper iterator that returns references
to a buffer, but I can give you something that <em>looks</em> like an iterator.</p>
<p>First define a generic struct;
the type parameter <code>R</code> is 'any type that implements Read'. It contains the reader
and the buffer which we are going to borrow from.</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
# 
#fn main() {
// file5.rs
use std::fs::File;
use std::io;
use std::io::prelude::*;

struct Lines&lt;R&gt; {
    reader: io::BufReader&lt;R&gt;,
    buf: String
}

impl &lt;R: Read&gt; Lines&lt;R&gt; {
    fn new(r: R) -&gt; Lines&lt;R&gt; {
        Lines{reader: io::BufReader::new(r), buf: String::new()}
    }
    ...
}

#}</code></pre></pre>
<p>Then the <code>next</code> method. It returns an <code>Option</code> - just like an iterator, when it
returns <code>None</code> the iterator finishes. The returned type is a <code>Result</code> because
<code>read_line</code> might fail, and we <em>never throw errors away</em>. So if fails, we
wrap up its error in a <code>Some&lt;Result&gt;</code>.  Otherwise, it may have read zero bytes,
which is the natural end of the file - not an error, just a <code>None</code>.</p>
<p>At this point, the buffer contains the line with a linefeed (`\n') appended.
Trim this away, and package up the string slice.</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
# 
#fn main() {
    fn next&lt;'a&gt;(&amp;'a mut self) -&gt; Option&lt;io::Result&lt;&amp;'a str&gt;&gt;{
        self.buf.clear();
        match self.reader.read_line(&amp;mut self.buf) {
            Ok(nbytes) =&gt; if nbytes == 0 {
                None // no more lines!
            } else {
                let line = self.buf.trim_right();
                Some(Ok(line))
            },
            Err(e) =&gt; Some(Err(e))
        }
    }

#}</code></pre></pre>
<p>Now, note how the lifetimes work. We need an explicit lifetime because Rust will never
allow us to hand out borrowed string slices without knowing their lifetime. And here
we say that the lifetime of this borrowed string is within the lifetime of <code>self</code>.</p>
<p>And this signature, with the lifetime, is incompatible with the interface of <code>Iterator</code>.
But it's easy to see problems if it were compatible; consider <code>collect</code> trying to make
a vector of these string slices. There's no way this could work, since they're all
borrowed from the same mutable string! (If you had read <em>all</em> the file into a string, then
the string's <code>lines</code> iterator can return string slices because they are all borrowed from
<em>distinct</em> parts of the original string.)</p>
<p>The resulting loop is much cleaner, and the file buffering is invisible to the user.</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
# 
#fn main() {
fn read_all_lines(filename: &amp;str) -&gt; io::Result&lt;()&gt; {
    let file = File::open(&amp;filename)?;

    let mut lines = Lines::new(file);
    while let Some(line) = lines.next() {
        let line = line?;
        println!(&quot;{}&quot;, line);
    }

    Ok(())
}

#}</code></pre></pre>
<p>You can even write the loop like this, since the explicit match can pull out the
string slice:</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
# 
#fn main() {
    while let Some(Ok(line)) = lines.next() {
        println!(&quot;{}&quot;, line)?;
    }

#}</code></pre></pre>
<p>It's tempting, but you are throwing away a possible error here; this loop will
silently stop whenever an error occurs. In particular, it will stop at the first place
where Rust can't convert a line to UTF-8.  Fine for casual code, bad for production code!</p>
<a class="header" href="print.html#writing-to-files" name="writing-to-files"><h2>Writing To Files</h2></a>
<p>We met the <code>write!</code> macro when implementing <code>Debug</code> - it also works with anything
that implements <code>Write</code>. So here's a another way of saying <code>print!</code>:</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
# 
#fn main() {
    let mut stdout = io::stdout();
    ...
    write!(stdout,&quot;answer is {}\n&quot;, 42).expect(&quot;write failed&quot;);

#}</code></pre></pre>
<p>If an error is <em>possible</em>, you must handle it. It may not be
very <em>likely</em> but it can happen. It's usually fine, because if you
are doing file i/o you should be in a context where <code>?</code> works.</p>
<p>But there is a difference: <code>print!</code> locks stdout for each write. This is usually
what you want for output, because without that locking multithreaded
programs can mix up that output in interesting ways. But if you are pumping out
a lot of text, then <code>write!</code> is going to be faster.</p>
<p>For arbitrary files we need <code>write!</code>. The
file is closed when <code>out</code> is dropped at the end of <code>write_out</code>, which is
both convenient and important.</p>
<pre><pre class="playpen"><code class="language-rust">// file6.rs
use std::fs::File;
use std::io;
use std::io::prelude::*;

fn write_out(f: &amp;str) -&gt; io::Result&lt;()&gt; {
    let mut out = File::create(f)?;
    write!(out,&quot;answer is {}\n&quot;, 42)?;
    Ok(())
}

fn main() {
  write_out(&quot;test.txt&quot;).expect(&quot;write failed&quot;);
}
</code></pre></pre>
<p>If you care about performance, you need to know that Rust files are unbuffered
by default. So each little write request goes straight to the OS, and this is
going to be significantly slower. I mention this because this default is different
from other programming languages, and could lead to the shocking discovery that Rust
can be left in the dust by scripting languages!
Just as with <code>Read</code> and <code>io::BufReader</code>, there is <code>io::BufWriter</code> for
buffering any <code>Write</code>.</p>
<a class="header" href="print.html#files-paths-and-directories" name="files-paths-and-directories"><h2>Files, Paths and Directories</h2></a>
<p>Here is a little program for printing out the Cargo directory on a machine. The
simplest case is that it's '~/.cargo'. This is a Unix shell expansion,
so we use <code>env::home_dir</code> because it's cross-platform. (It might fail, but a
computer without a home directory isn't going to be hosting Rust tools anyway.)</p>
<p>We then create a <a href="https://doc.rust-lang.org/std/ops/trait.Mul.html">PathBuf</a>
and use its <code>push</code> method to build up the full file path from its <em>components</em>.
(This is much easier than fooling around with '/','' or whatever, depending on
the system.)</p>
<pre><pre class="playpen"><code class="language-rust">// file7.rs
use std::env;
use std::path::PathBuf;

fn main() {
    let home = env::home_dir().expect(&quot;no home!&quot;);
    let mut path = PathBuf::new();
    path.push(home);
    path.push(&quot;.cargo&quot;);

    if path.is_dir() {
        println!(&quot;{}&quot;, path.display());
    }
}
</code></pre></pre>
<p>A <code>PathBuf</code> is like <code>String</code> - it owns a growable set of characters, but with methods
specialized to building up paths.  Most of its functionality however comes from
the borrowed version <code>Path</code>, which is like <code>&amp;str</code>.  So, for instance, <code>is_dir</code> is
a <code>Path</code> method.</p>
<p>This might sound suspiciously like a form of inheritance, but the magic <a href="https://doc.rust-lang.org/book/deref-coercions.html">Deref</a>
trait works differently. It works just like it does with <code>String/&amp;str</code> -
a reference to <code>PathBuf</code> can be <em>coerced</em> into a reference to <code>Path</code>.
('Coerce' is a strong word, but this really
is one of the few places where Rust does conversions for you.)</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
# 
#fn main() {
fn foo(p: &amp;Path) {...}
...
let path = PathBuf::from(home);
foo(&amp;path);

#}</code></pre></pre>
<p><code>PathBuf</code> has an intimate relationship with <code>OsString</code>, which represents strings we get
directly from the system. (There is a corresponding <code>OsString/&amp;OsStr</code> relationship.)</p>
<p>Such strings are not <em>guaranteed</em> to be representable as UTF-8!
Real life is a <a href="https://news.ycombinator.com/item?id=10519932">complicated matter</a>,
particularly see the answer to 'Why are they so hard?'.  To summarize, first there are
years of ASCII legacy coding, and multiple special encodings for other languages. Second,
human languages are complicated. For instance 'noël' is <em>five</em> Unicode code points!</p>
<p>It's true that most of the time
with modern operating systems file names will be Unicode (UTF-8 on the Unix side, UTF-16
for Windows), except when they're not. And Rust must handle that possibility
rigorously. For instance,
<code>Path</code> has a method <code>as_os_str</code> which returns a <code>&amp;OsStr</code>, but the <code>to_str</code> method
returns an <code>Option&lt;&amp;str&gt;</code>. Not always possible!</p>
<p>People have trouble at this point because they have become too attached to 'string' and
'character' as the only necessary abstractions.  As Einstein could have said, a programming language
has to be as simple as possible, but no simpler. A systems language <em>needs</em> a
<code>String/&amp;str</code> distinction (owned versus borrowed: this is also very convenient)
and if it wishes to standardize on Unicode strings then it needs another type to handle
text which isn't valid Unicode - hence <code>OsString/&amp;OsStr</code>. Notice that there aren't
any interesting string-like methods for these types, precisely because we don't know the
encoding.</p>
<p>But, people are used to processing filenames as if they were strings, which is why
Rust makes it easier to manipulate file paths using <code>PathBuf</code> methods.</p>
<p>You can <code>pop</code> to successively remove path components. Here we start with the
current directory of the program:</p>
<pre><pre class="playpen"><code class="language-rust">// file8.rs
use std::env;

fn main() {
    let mut path = env::current_dir().expect(&quot;can't access current dir&quot;);
    loop {
        println!(&quot;{}&quot;, path.display());
        if ! path.pop() {
            break;
        }
    }
}
// /home/steve/rust/gentle-intro/code
// /home/steve/rust/gentle-intro
// /home/steve/rust
// /home/steve
// /home
// /
</code></pre></pre>
<p>Here's a useful variation. I have a program which searches for a configuration file,
and the rule is that it may appear in any subdirectory of the current directory.
So I create <code>/home/steve/rust/config.txt</code> and start this program up in <code>/home/steve/rust/gentle-intro/code</code>:</p>
<pre><pre class="playpen"><code class="language-rust">// file9.rs
use std::env;

fn main() {
    let mut path = env::current_dir().expect(&quot;can't access current dir&quot;);
    loop {
        path.push(&quot;config.txt&quot;);
        if path.is_file() {
            println!(&quot;gotcha {}&quot;, path.display());
            break;
        } else {
            path.pop();
        }
        if ! path.pop() {
            break;
        }
    }
}
// gotcha /home/steve/rust/config.txt
</code></pre></pre>
<p>This is pretty much how <strong>git</strong> works when it wants to know what the current repo is.</p>
<p>The details about a file (its size, type, etc) are called its <em>metadata</em>. As always,
there may be an error - not just 'not found' but also if we don't have permission
to read this file.</p>
<pre><pre class="playpen"><code class="language-rust">// file10.rs
use std::env;
use std::path::Path;

fn main() {
    let file = env::args().skip(1).next().unwrap_or(&quot;file10.rs&quot;.to_string());
    let path = Path::new(&amp;file);
    match path.metadata() {
        Ok(data) =&gt; {
            println!(&quot;type {:?}&quot;, data.file_type());
            println!(&quot;len {}&quot;, data.len());
            println!(&quot;perm {:?}&quot;, data.permissions());
            println!(&quot;modified {:?}&quot;, data.modified());
        },
        Err(e) =&gt; println!(&quot;error {:?}&quot;, e)
    }
}
// type FileType(FileType { mode: 33204 })
// len 488
// perm Permissions(FilePermissions { mode: 436 })
// modified Ok(SystemTime { tv_sec: 1483866529, tv_nsec: 600495644 })
</code></pre></pre>
<p>The length of the file (in bytes) and modified time are straightforward to interpret.
(Note we may not be able to get this time!)  The file type has methods <code>is_dir</code>,
<code>is_file</code> and <code>is_symlink</code>.</p>
<p><code>permissions</code> is an interesting one. Rust strives to be cross-platform, and so it's
a case of the 'lowest common denominator'. In general, all you can query is whether
the file is read-only - the 'permissions' concept is extended in Unix and encodes
read/write/executable for user/group/others.</p>
<p>But, if you are not interested in Windows, then bringing in a platform-specific trait will give
us at least the permission mode bits. (As usual, a trait only kicks in when it is
visible.) Then, applying the program to its own executable gives:</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
# 
#fn main() {
use std::os::unix::fs::PermissionsExt;
...
println!(&quot;perm {:o}&quot;,data.permissions().mode());
// perm 755

#}</code></pre></pre>
<p>(Note '{:o}' for printing out in <em>octal</em>)</p>
<p>(Whether a file is executable on Windows is determined by its extension. The executable
extensions are found in the <code>PATHEXT</code> environment variable - '.exe','.bat' and so forth).</p>
<p><code>std::fs</code> contains a number of useful functions for working with files, such as copying or
moving files, making symbolic links and creating directories.</p>
<p>To find the contents of a directory, <code>std::fs::read_dir</code> provides an iterator.
Here are all files with extension '.rs' and size greater than 1024 bytes:</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
# 
#fn main() {
fn dump_dir(dir: &amp;str) -&gt; io::Result&lt;()&gt; {
    for entry in fs::read_dir(dir)? {
        let entry = entry?;
        let data = entry.metadata()?;
        let path = entry.path();
        if data.is_file() {
            if let Some(ex) = path.extension() {
                if ex == &quot;rs&quot; &amp;&amp; data.len() &gt; 1024 {
                    println!(&quot;{} length {}&quot;, path.display(),data.len());
                }
            }
        }
    }
    Ok(())
}
// ./enum4.rs length 2401
// ./struct7.rs length 1151
// ./sexpr.rs length 7483
// ./struct6.rs length 1359
// ./new-sexpr.rs length 7719

#}</code></pre></pre>
<p>Obviously <code>read_dir</code> might fail (usually 'not found' or 'no permission'), but
also getting each new entry might fail (it's like the <code>lines</code> iterator over a buffered
reader's contents).  Plus, we might not be able to get the metadata corresponding to
the entry.  A file might have no extension, so we have to check for that as well.</p>
<p>Why not just an iterator over paths? On Unix this is the way the <code>opendir</code> system call works,
but on Windows you cannot iterate over a directory's contents without getting the
metadata. So this is a reasonably elegant compromise that allows cross-platform
code to be as efficient as possible.</p>
<p>You can be forgiven for feeling 'error fatigue' at this point. But please note that
the <em>errors always existed</em> - it's not that Rust is inventing new ones. It's just
trying hard to make it impossible for you to ignore them.  Any operating system call
may fail.</p>
<p>Languages like Java and Python throw exceptions; languages like Go and Lua return two
values, where the first is the result and the second is the error: like Rust it is
considered bad manners for library functions to raise errors. So there is a lot
of error checking and early-returns from functions.</p>
<p>Rust uses <code>Result</code> because it's either-or: you cannot get both a result and an error.
And the question-mark operator makes handling errors much cleaner.</p>
<a class="header" href="print.html#processes" name="processes"><h2>Processes</h2></a>
<p>A fundamental need is for programs to run programs, or to <em>launch processes</em>.
Your program can <em>spawn</em> as many child processes it likes, and as the name
suggests they have a special relationship with their parent.</p>
<p>To run a program is straightforward using the <code>Command</code> struct, which builds up
arguments to pass to the program:</p>
<pre><pre class="playpen"><code class="language-rust">use std::process::Command;

fn main() {
    let status = Command::new(&quot;rustc&quot;)
        .arg(&quot;-V&quot;)
        .status()
        .expect(&quot;no rustc?&quot;);

    println!(&quot;cool {} code {}&quot;, status.success(), status.code().unwrap());
}
// rustc 1.15.0-nightly (8f02c429a 2016-12-15)
// cool true code 0
</code></pre></pre>
<p>So <code>new</code> receives the name of the program (it will be looked up on <code>PATH</code> if not
an absolute filename), <code>arg</code> adds a new argument, and <code>status</code> causes it to be run.
This returns a <code>Result</code>, which is <code>Ok</code> if the program actually run, containing an
<code>ExitStatus</code>. In this case, the program succeeded, and returned an exit code 0. (The
<code>unwrap</code> is because we can't always get the code if the program was killed by
a signal).</p>
<p>If we change the <code>-V</code> to <code>-v</code> (an easy mistake) then <code>rustc</code> fails:</p>
<pre><code>error: no input filename given

cool false code 101
</code></pre>
<p>So there are three possibilities:</p>
<ul>
<li>program didn't exist, was bad, or we were not allowed to run it</li>
<li>program ran, but was not successful - non-zero exit code</li>
<li>program ran, with zero exit code. Success!</li>
</ul>
<p>By default, the program's standard output and standard error streams
go to the terminal.</p>
<p>Often we are very interested in capturing that output, so there's the <code>output</code>
method.</p>
<pre><pre class="playpen"><code class="language-rust">// process2.rs
use std::process::Command;

fn main() {
    let output = Command::new(&quot;rustc&quot;)
        .arg(&quot;-V&quot;)
        .output()
        .expect(&quot;no rustc?&quot;);

    if output.status.success() {
        println!(&quot;ok!&quot;);
    }
    println!(&quot;len stdout {} stderr {}&quot;, output.stdout.len(), output.stderr.len());
}
// ok!
// len stdout 44 stderr 0
</code></pre></pre>
<p>As with <code>status</code> our program blocks until the child process is finished, and we get
back three things - the status (as before), the contents of stdout and the contents
of stderr.</p>
<p>The captured output is simply <code>Vec&lt;u8&gt;</code> - just bytes.  Recall we have no guarantee
that data we receive from the operating system is a properly encoded UTF-8 string. In
fact, we have no guarantee that it <em>even</em> is a string - programs may return arbitrary
binary data.</p>
<p>If we are pretty sure the output is UTF-8, then <code>String::from_utf8</code> will convert those
vectors or bytes - it returns a <code>Result</code> because this conversion may not succeed.
A more sloppy function is <code>String::from_utf8_lossy</code> which will make a good attempt at
conversion and insert the invalid Unicode mark � where it failed.</p>
<p>Here is a useful function which runs a program using the shell. This uses the usual
shell mechanism for joining stderr to stdout. The name of the shell is different
on Windows, but otherwise things work as expected.</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
# 
#fn main() {
fn shell(cmd: &amp;str) -&gt; (String,bool) {
    let cmd = format!(&quot;{} 2&gt;&amp;1&quot;,cmd);
    let shell = if cfg!(windows) {&quot;cmd.exe&quot;} else {&quot;/bin/sh&quot;};
    let flag = if cfg!(windows) {&quot;/c&quot;} else {&quot;-c&quot;};
    let output = Command::new(shell)
        .arg(flag)
        .arg(&amp;cmd)
        .output()
        .expect(&quot;no shell?&quot;);
    (
        String::from_utf8_lossy(&amp;output.stdout).trim_right().to_string(),
        output.status.success()
    )
}


fn shell_success(cmd: &amp;str) -&gt; Option&lt;String&gt; {
    let (output,success) = shell(cmd);
    if success {Some(output)} else {None}
}

#}</code></pre></pre>
<p>I'm trimming any whitespace from the right so that if you said <code>shell(&quot;which rustc&quot;)</code>
you will get the path without any extra linefeed.</p>
<p>You can control the execution of a program launched by <code>Process</code>
by specifying the directory it will run
in using the <code>current_dir</code> method and the environment variables it sees using <code>env</code>.</p>
<p>Up to now, our program simply waits for the child process to finish. If you use
the <code>spawn</code> method then we return immediately, and must explicitly wait for it to
finish - or go off and do something else in the meantime!  This example also
shows how to suppress both standard out and standard error:</p>
<pre><pre class="playpen"><code class="language-rust">// process5.rs
use std::process::{Command,Stdio};

fn main() {
    let mut child = Command::new(&quot;rustc&quot;)
        .stdout(Stdio::null())
        .stderr(Stdio::null())
        .spawn()
        .expect(&quot;no rustc?&quot;);

    let res = child.wait();
    println!(&quot;res {:?}&quot;, res);
}
</code></pre></pre>
<p>By default, the child 'inherits' the standard input and output of the parent. In this case,
we redirect the child's output handles into 'nowhere'. It's equivalent to saying
<code>&gt; /dev/null 2&gt; /dev/null</code> in the Unix shell.</p>
<p>Now, it's possible to do these things using the shell (<code>sh</code> or <code>cmd</code>) in Rust.
But this way you get full programmatic control of process creation.</p>
<p>For example, if we just had <code>.stdout(Stdio::piped())</code> then the child's standard output
is redirected to a pipe. Then <code>child.stdout</code> is something you can use to directly
read the output (i.e. implements <code>Read</code>). Likewise, you can use the <code>.stdout(Stdio::piped())</code>
method so you can write to <code>child.stdin</code>.</p>
<p>But if we used <code>wait_with_output</code> instead of <code>wait</code> then
it returns a <code>Result&lt;Output&gt;</code> and the child's output is captured into the <code>stdout</code>
field of that <code>Output</code> as a <code>Vec&lt;u8&gt;</code> just as before.</p>
<p>The <code>Child</code> struct also gives you an explicit <code>kill</code> method.</p>
<a class="header" href="print.html#modules-and-cargo" name="modules-and-cargo"><h1>Modules and Cargo</h1></a>
<a class="header" href="print.html#modules" name="modules"><h2>Modules</h2></a>
<p>As programs get larger, it's necessary to spread them over more than one file
and put functions and types in different <em>namespaces</em>.
The Rust solution for both of these is <em>modules</em>.</p>
<p>C does the first, and not
the second, so you end up with awful names like <code>primitive_display_set_width</code> and
so forth. The actual filenames can be named arbitrarily.</p>
<p>In Rust the full name would look like <code>primitive::display::set_width</code>,
and after saying <code>use primitive::display</code> you can then refer to it as <code>display::set_width</code>.
You can even say <code>use primitive::display::set_width</code> and then just say <code>set_width</code>, but
it's not a good idea to get carried away with this. <code>rustc</code> will not be confused, but <em>you</em>
may get confused later. But for this to work, filenames must follow some simple rules.</p>
<p>A new keyword <code>mod</code> is used to define a module as a block
where Rust types or functions can be written:</p>
<pre><pre class="playpen"><code class="language-rust">mod foo {
    #[derive(Debug)]
    struct Foo {
        s: &amp;'static str
    }
}

fn main() {
    let f = foo::Foo{s: &quot;hello&quot;};
    println!(&quot;{:?}&quot;, f);
}
</code></pre></pre>
<p>But it's still not quite right - we get 'struct Foo is private'. To solve this, we need the <code>pub</code> keyword
to export <code>Foo</code>. The error then changes to 'field s of struct foo::Foo is private', so put <code>pub</code>
before the field <code>s</code> to export <code>Foo::s</code>. Then things will work.</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
# 
#fn main() {
    pub struct Foo {
        pub s: &amp;'static str
    }

#}</code></pre></pre>
<p>Needing an explicit <code>pub</code> means that you must <em>choose</em> what items to make public from a module.
The set of functions and types exported from a module is called its <em>interface</em>.</p>
<p>It is usually better to hide the insides of a struct, and only allow access through methods:</p>
<pre><pre class="playpen"><code class="language-rust">mod foo {
    #[derive(Debug)]
    pub struct Foo {
        s: &amp;'static str
    }

    impl Foo {
        pub fn new(s: &amp;'static str) -&gt; Foo {
            Foo{s: s}
        }
    }
}

fn main() {
    let f = foo::Foo::new(&quot;hello&quot;);
    println!(&quot;{:?}&quot;, f);
}
</code></pre></pre>
<p>Why is hiding the implementation a good thing?  Because it means you may change it later
without breaking the interface, without consumers of a module getting too dependent on its details.
The great enemy of large-scale programing is a tendency for code to get entangled, so that understanding
a piece of code is impossible in isolation.</p>
<p>In a perfect world a module does one thing, does it well, and keeps its own secrets.</p>
<p>When not to hide? As Stroustrup says, when the interface <em>is</em> the implementation, like
<code>struct Point{x: f32, y: f32}</code>.</p>
<p><em>Within</em> a module, all items are visible to all other items. It's a cozy place where
everyone can be friends and know intimate details about each other.</p>
<p>Everyone gets to a point where they want to break a program up into separate files,
depending on taste. I start getting uncomfortable around 500 lines, but we all agree
that more than 2000 lines is pushing it.</p>
<p>So how to break this program into separate files?</p>
<p>We put the <code>foo</code> code into <code>foo.rs</code>:</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
# 
#fn main() {
// foo.rs
#[derive(Debug)]
pub struct Foo {
    s: &amp;'static str
}

impl Foo {
    pub fn new(s: &amp;'static str) -&gt; Foo {
        Foo{s: s}
    }
}

#}</code></pre></pre>
<p>And use a <code>mod foo</code> statement <em>without</em> a block in the main program:</p>
<pre><pre class="playpen"><code class="language-rust">// mod3.rs
mod foo;

fn main() {
    let f = foo::Foo::new(&quot;hello&quot;);
    println!(&quot;{:?}&quot;, f);
}
</code></pre></pre>
<p>Now <code>rustc mod3.rs</code> will cause <code>foo.rs</code> to be compiled as well. There is no need to fool around
with makefiles!</p>
<p>The compiler will also look at <code>MODNAME/mod.rs</code>, so this will work
if I create a directory <code>boo</code> containing a file <code>mod.rs</code>:</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
# 
#fn main() {
// boo/mod.rs
pub fn answer()-&gt;u32 {
    42
}

#}</code></pre></pre>
<p>And now the main program can use both modules as separate files:</p>
<pre><code>// mod3.rs
mod foo;
mod boo;

fn main() {
    let f = foo::Foo::new(&quot;hello&quot;);
    let res = boo::answer();
    println!(&quot;{:?} {}&quot;, f,res);
}
</code></pre>
<p>So far, there's <code>mod3.rs</code>, containing <code>main</code>, a module <code>foo.rs</code> and a directory <code>boo</code> containing
<code>mod.rs</code>.  The usual convention is that the file containing <code>main</code> is just called <code>main.rs</code>.</p>
<p>Why two ways to do the same thing? Because <code>boo/mod.rs</code> can refer to other modules defined in <code>boo</code>,
Update <code>boo/mod.rs</code> and add a new module - note that this is explicitly exported. (Without the <code>pub</code>,
<code>bar</code> can only be seen inside the <code>boo</code> module.)</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
# 
#fn main() {
// boo/mod.rs
pub fn answer()-&gt;u32 {
    42
}

pub mod bar {
    pub fn question() -&gt; &amp;'static str {
        &quot;the meaning of everything&quot;
    }
}

#}</code></pre></pre>
<p>and then we have the question corresponding to the answer (the <code>bar</code> module is inside <code>boo</code>):</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
# 
#fn main() {
let q = boo::bar::question();

#}</code></pre></pre>
<p>That module block can be pulled out as <code>boo/bar.rs</code>:</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
# 
#fn main() {
// boo/bar.rs
pub fn question() -&gt; &amp;'static str {
    &quot;the meaning of everything&quot;
}

#}</code></pre></pre>
<p>And <code>boo/mod.rs</code> becomes:</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
# 
#fn main() {
// boo/mod.rs
pub fn answer()-&gt;u32 {
    42
}

pub mod bar;

#}</code></pre></pre>
<p>In summary, modules are about organization and visibility,
and this may or may not involve separate files.</p>
<p>Please note that <code>use</code> has nothing to do with importing, and simply specifies visibility
of module names. For example:</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
# 
#fn main() {
{
    use boo::bar;
    let q = bar::question();
    ...
}
{
    use boo::bar::question();
    let q = question();
    ...
}


#}</code></pre></pre>
<p>An important point to note is there is no <em>separate compilation</em> here. The main program and its
module files will be recompiled each time. Larger programs will take a fair amount of time to build,
although <code>rustc</code> is getting better at incremental compilation.</p>
<a class="header" href="print.html#crates" name="crates"><h2>Crates</h2></a>
<p>The 'compilation unit' for Rust is the <em>crate</em>, which is either an executable or a library.</p>
<p>To separately compile the files from the last section,
first build <code>foo.rs</code> as a Rust <em>static library</em> crate:</p>
<pre><code>src$ rustc foo.rs --crate-type=lib
src$ ls -l libfoo.rlib
-rw-rw-r-- 1 steve steve 7888 Jan  5 13:35 libfoo.rlib
</code></pre>
<p>We can now <em>link</em> this into our main program:</p>
<pre><code>src$ rustc mod4.rs --extern foo=libfoo.rlib
</code></pre>
<p>But the main program must now look like this, where the <code>extern</code> name is the same
as the one used when linking. There is an implicit top-level module <code>foo</code> associated
with the library crate:</p>
<pre><code>// mod4.rs
extern crate foo;

fn main() {
    let f = foo::Foo::new(&quot;hello&quot;);
    println!(&quot;{:?}&quot;, f);
}
</code></pre>
<p>Before people start chanting 'Cargo! Cargo!' let me justify this lower-level look at building Rust.
I'm a great believer in 'Know Thy Toolchain', and this will reduce the amount of new magic you need
to learn when we look at managing projects with Cargo. Modules are basic language features and can be
used outside Cargo projects.</p>
<p>It's time to understand why Rust binaries are so large:</p>
<pre><code>src$ ls -lh mod4
-rwxrwxr-x 1 steve steve 3,4M Jan  5 13:39 mod4
</code></pre>
<p>That's rather fat! There is a <em>lot</em> of debug information in that executable. This is not a Bad Thing,
if you want to use a debugger and actually want meaningful backtraces when your program panics.</p>
<p>So let's strip that debug information and see:</p>
<pre><code>src$ strip mod4
src$ ls -lh mod4
-rwxrwxr-x 1 steve steve 300K Jan  5 13:49 mod4
</code></pre>
<p>Still feels a little large for something so simple, but this program links <em>statically</em> against
the Rust standard library. This is a Good Thing, since you can hand this executable to anyone
with the right operating system - they will not need a 'Rust runtime'. (And <code>rustup</code> will even let
you cross-compile for other operating systems and platforms as well.)</p>
<p>We can link dynamically against the Rust runtime and get truly tiny exes:</p>
<pre><code>src$ rustc -C prefer-dynamic mod4.rs --extern foo=libfoo.rlib
src$ ls -lh mod4
-rwxrwxr-x 1 steve steve 14K Jan  5 13:53 mod4
src$ ldd mod4
    linux-vdso.so.1 =&gt;  (0x00007fffa8746000)
    libstd-b4054fae3db32020.so =&gt; not found
    libc.so.6 =&gt; /lib/x86_64-linux-gnu/libc.so.6 (0x00007f3cd47aa000)
    /lib64/ld-linux-x86-64.so.2 (0x00007f3cd4d72000)
</code></pre>
<p>That 'not found' is because <code>rustup</code> doesn't install the dynamic libraries globally. We
can hack our way to happiness, at least on Unix (yes, I know the best solution is a symlink.)</p>
<pre><code>src$ export LD_LIBRARY_PATH=~/.rustup/toolchains/nightly-x86_64-unknown-linux-gnu/lib
src$ ./mod4
Foo { s: &quot;hello&quot; }
</code></pre>
<p>Rust does not have a <em>philosophical</em> problem with dynamic linking, in the same way as Go does. It's
just that when there's a stable release every 6 weeks it becomes inconvenient to have to recompile
everything. If you have a stable version that Works For You, then cool. As stable versions of Rust
get increasingly delivered by the OS package manager, dynamic linking will become more popular.</p>
<a class="header" href="print.html#cargo" name="cargo"><h2>Cargo</h2></a>
<p>The Rust standard library is not very large, compared to Java or Python; although much more fully
featured than C or C++, which lean heavily on operating system provided libraries.</p>
<p>But it is straightforward to access community-provided libraries in <a href="https://crates.io">crates.io</a>
using <strong>Cargo</strong>.  Cargo will look up the correct version and download the source for you, and
ensures that any other needed crates are downloaded as well.</p>
<p>Let's create a simple program which needs to read JSON. This data format is very widely used,
but is too specialized for inclusion in the standard library. So we initialize a Cargo project,
using '--bin' because the default is to create a library project.</p>
<pre><code>test$ cargo init --bin test-json
     Created binary (application) project
test$ cd test-json
test$ cat Cargo.toml
[package]
name = &quot;test-json&quot;
version = &quot;0.1.0&quot;
authors = [&quot;Your Name &lt;you@example.org&gt;&quot;]

[dependencies]
</code></pre>
<p>To make the project depend on the <a href="http://json.rs/doc/json/">JSON crate</a>, edit the
'Cargo.toml' file so:</p>
<pre><code>[dependencies]
json=&quot;0.11.4&quot;
</code></pre>
<p>Then do a first build with Cargo:</p>
<pre><code>test-json$ cargo build
    Updating registry `https://github.com/rust-lang/crates.io-index`
 Downloading json v0.11.4
   Compiling json v0.11.4
   Compiling test-json v0.1.0 (file:///home/steve/c/rust/test/test-json)
    Finished debug [unoptimized + debuginfo] target(s) in 1.75 secs
</code></pre>
<p>The main file of this project has already been created - it's 'main.rs' in the 'src'
directory. It starts out just as a 'hello world' app, so let's edit it to be a proper test program.</p>
<p>Note the very convenient 'raw' string literal - otherwise we would need to escape those double quotes
and end up with ugliness:</p>
<pre><pre class="playpen"><code class="language-rust">// test-json/src/main.rs
extern crate json;

fn main() {
    let doc = json::parse(r#&quot;
    {
        &quot;code&quot;: 200,
        &quot;success&quot;: true,
        &quot;payload&quot;: {
            &quot;features&quot;: [
                &quot;awesome&quot;,
                &quot;easyAPI&quot;,
                &quot;lowLearningCurve&quot;
            ]
        }
    }
    &quot;#).expect(&quot;parse failed&quot;);

    println!(&quot;debug {:?}&quot;, doc);
    println!(&quot;display {}&quot;, doc);
}
</code></pre></pre>
<p>You can now build and run this project - only <code>main.rs</code> has changed.</p>
<pre><code>test-json$ cargo run
   Compiling test-json v0.1.0 (file:///home/steve/c/rust/test/test-json)
    Finished debug [unoptimized + debuginfo] target(s) in 0.21 secs
     Running `target/debug/test-json`
debug Object(Object { store: [(&quot;code&quot;, Number(Number { category: 1, exponent: 0, mantissa: 200 }),
 0, 1), (&quot;success&quot;, Boolean(true), 0, 2), (&quot;payload&quot;, Object(Object { store: [(&quot;features&quot;,
 Array([Short(&quot;awesome&quot;), Short(&quot;easyAPI&quot;), Short(&quot;lowLearningCurve&quot;)]), 0, 0)] }), 0, 0)] })
display {&quot;code&quot;:200,&quot;success&quot;:true,&quot;payload&quot;:{&quot;features&quot;:[&quot;awesome&quot;,&quot;easyAPI&quot;,&quot;lowLearningCurve&quot;]}}
</code></pre>
<p>The debug output shows some internal details of the JSON document, but a
plain '{}', using the <code>Display</code> trait, regenerates JSON from the parsed document.</p>
<p>Let's explore the JSON API.
It would not be useful if we could not extract values. The <code>as_TYPE</code> methods
return <code>Option&lt;TYPE&gt;</code> since we cannot be sure that the field exists or is of the correct type.
(see the <a href="http://json.rs/doc/json/enum.JsonValue.html">docs for JsonValue</a>)</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
# 
#fn main() {
    let code = doc[&quot;code&quot;].as_u32().unwrap_or(0);
    let success = doc[&quot;success&quot;].as_bool().unwrap_or(false);

    assert_eq!(code, 200);
    assert_eq!(success, true);

    let features = &amp;doc[&quot;payload&quot;][&quot;features&quot;];
    for v in features.members() {
        println!(&quot;{}&quot;, v.as_str().unwrap()); // MIGHT explode
    }
    // awesome
    // easyAPI
    // lowLearningCurve

#}</code></pre></pre>
<p><code>features</code> here is a reference to <code>JsonValue</code> - it has to be a reference because otherwise
we would be trying to move a <em>value</em> out of the JSON document.  Here we know it's an array,
so <code>members()</code> will return a non-empty iterator over <code>&amp;JsonValue</code>.</p>
<p>What if the 'payload' object didn't have a 'features' key? Then <code>features</code> would be set to <code>Null</code>.
There will be no explosion. This convenience expresses the free-form, anything-goes nature of JSON
very well. It is up to you to examine the structure of any document you receive and create your own
errors if the structure does not match.</p>
<p>You can modify these structures. If we had <code>let mut doc</code> then this would do what you expect:</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
# 
#fn main() {
    let features = &amp;mut doc[&quot;payload&quot;][&quot;features&quot;];
    features.push(&quot;cargo!&quot;).expect(&quot;couldn't push&quot;);

#}</code></pre></pre>
<p>The <code>push</code> will fail if <code>features</code> wasn't an array, hence it returns <code>Result&lt;()&gt;</code>.</p>
<p>Here's a truly beautiful use of macros to generate <em>JSON literals</em>:</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
# 
#fn main() {
    let data = object!{
        &quot;name&quot;    =&gt; &quot;John Doe&quot;,
        &quot;age&quot;     =&gt; 30,
        &quot;numbers&quot; =&gt; array![10,53,553]
    };
    assert_eq!(
        data.dump(),
        r#&quot;{&quot;name&quot;:&quot;John Doe&quot;,&quot;age&quot;:30,&quot;numbers&quot;:[10,53,553]}&quot;#
    );

#}</code></pre></pre>
<p>For this to work, you need to explicitly import macros from the JSON crate thus:</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
# 
#fn main() {
#[macro_use]
extern crate json;

#}</code></pre></pre>
<p>There is a downside to using this crate, because of the mismatch between the amorphous, dynamically-typed
nature of JSON and the structured, static nature of Rust. (The readme explicitly speaks of 'friction')
So if you <em>did</em> want to map JSON to Rust data structures, you would end up doing a lot of checking,
because you can not assume that the received structure matches your structs! For that, a better
solution is <a href="https://github.com/serde-rs/json">serde_json</a> where you <em>serialize</em> Rust data structures
into JSON and <em>deserialize</em> JSON into Rust.</p>
<p>For this, create a another Cargo binary project with <code>cargo new --bin test-serde-json</code>, go into
the <code>test-serde-json</code> directory and edit <code>Cargo.toml</code>. Edit it like so:</p>
<pre><code>[dependencies]
serde=&quot;0.9&quot;
serde_derive=&quot;0.9&quot;
serde_json=&quot;0.9&quot;
</code></pre>
<p>And edit <code>src/main.rs</code> to be this:</p>
<pre><pre class="playpen"><code class="language-rust">#[macro_use]
extern crate serde_derive;
extern crate serde_json;

#[derive(Serialize, Deserialize, Debug)]
struct Person {
    name: String,
    age: u8,
    address: Address,
    phones: Vec&lt;String&gt;,
}

#[derive(Serialize, Deserialize, Debug)]
struct Address {
    street: String,
    city: String,
}

fn main() {
    let data = r#&quot; {
     &quot;name&quot;: &quot;John Doe&quot;, &quot;age&quot;: 43,
     &quot;address&quot;: {&quot;street&quot;: &quot;main&quot;, &quot;city&quot;:&quot;Downtown&quot;},
     &quot;phones&quot;:[&quot;27726550023&quot;]
    } &quot;#;
    let p: Person = serde_json::from_str(data).expect(&quot;deserialize error&quot;);
    println!(&quot;Please call {} at the number {}&quot;, p.name, p.phones[0]);

    println!(&quot;{:#?}&quot;,p);
}
</code></pre></pre>
<p>You have seen the <code>derive</code> attribute before, but the <code>serde_derive</code> crate defines <em>custom derives</em>
for the special <code>Serialize</code> and <code>Deserialize</code> traits. And the result shows the generated Rust struct:</p>
<pre><code>Please call John Doe at the number 27726550023
Person {
    name: &quot;John Doe&quot;,
    age: 43,
    address: Address {
        street: &quot;main&quot;,
        city: &quot;Downtown&quot;
    },
    phones: [
        &quot;27726550023&quot;
    ]
}
</code></pre>
<p>Now, if you did this using the <code>json</code> crate, you would need a few hundred lines of custom conversion
code, mostly error handling. Tedious, easy to mess up, and not where you want to put effort anyway.</p>
<p>This is clearly the best solution if you are processing well-structured JSON from outside sources (it's
possible to remap field names if needed) and provides a robust way for Rust programs to share data
with other programs over the network (since everything understands JSON these days.) The cool thing
about <code>serde</code> (for SERialization DEserialization) is that other file formats are also supported, such
as <code>toml</code>, which is the popular configuration-friendly format used in Cargo. So your program can read .toml
files into structs, and write those structs out as .json.</p>
<p>Serialization is an important technique and similar solutions exist for Java and Go - but with a big
difference. In those languages the structure of the data is found at <em>run-time</em> using <em>reflection</em>, but
in this case the serialization code is generated at <em>compile-time</em> - altogether more efficient!</p>
<p>Cargo is considered to be one of the great strengths of the Rust ecosystem, because it does
a lot of work for us. Otherwise we would have had to download these libraries from Github,
build as static library crates, and link them against the program. It's painful to do this for
C++ projects, and would be nearly as painful for Rust projects if Cargo did not exist.
C++ is somewhat unique in its painfullness here, so we should compare this with
other languages' package managers. npm (for JavaScript) and pip (for Python) manage dependencies
and downloads for you, but the distribution story is harder, since the user of your program
needs NodeJS or Python installed.
But Rust programs are statically linked against their dependencies, so again they can be handed
out to your buddies without external dependencies.</p>
<a class="header" href="print.html#more-gems" name="more-gems"><h2>More Gems</h2></a>
<p>When processing anything except simple text, regular expressions make your life much easier.
These are commonly available for most languages and I'll here assume a basic familiarity with
regex notation.  To use the <a href="https://github.com/rust-lang/regex">regex</a> crate, put 'regex = &quot;0.2.1&quot;'
after &quot;[dependencies]&quot; in your Cargo.toml.</p>
<p>We'll use 'raw strings' again so that the backslashes don't have to be escaped. In English, this
regular expression is &quot;match exactly two digits, the character ':', and then any number of digits.
Capture both sets of digits&quot;:</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
# 
#fn main() {
extern crate regex;
use regex::Regex;

let re = Regex::new(r&quot;(\d{2}):(\d+)&quot;).unwrap();
println!(&quot;{:?}&quot;, re.captures(&quot;  10:230&quot;));
println!(&quot;{:?}&quot;, re.captures(&quot;[22:2]&quot;));
println!(&quot;{:?}&quot;, re.captures(&quot;10:x23&quot;));
// Some(Captures({0: Some(&quot;10:230&quot;), 1: Some(&quot;10&quot;), 2: Some(&quot;230&quot;)}))
// Some(Captures({0: Some(&quot;22:2&quot;), 1: Some(&quot;22&quot;), 2: Some(&quot;2&quot;)}))
// None

#}</code></pre></pre>
<p>The successful output actually has three <em>captures</em> - the whole match, and the two sets of digits.
These regular expressions are not <em>anchored</em> by default, so <strong>regex</strong> will hunt for the first
occurring match, skipping anything that doesn't match.  (If you left out the '()' it would just
give us the whole match.)</p>
<p>It's possible to <em>name</em> those captures, and spread the regular expression over several lines,
even including comments!  Compiling the regex might fail (the first <em>expect</em>) or the match
might fail (the second <em>expect</em>). Here we can use the result as an associative array and look
up captures by name.</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
# 
#fn main() {
let re = Regex::new(r&quot;(?x)
(?P&lt;year&gt;\d{4})  # the year
-
(?P&lt;month&gt;\d{2}) # the month
-
(?P&lt;day&gt;\d{2})   # the day
&quot;).expect(&quot;bad regex&quot;);
let caps = re.captures(&quot;2010-03-14&quot;).expect(&quot;match failed&quot;);

assert_eq!(&quot;2010&quot;, &amp;caps[&quot;year&quot;]);
assert_eq!(&quot;03&quot;, &amp;caps[&quot;month&quot;]);
assert_eq!(&quot;14&quot;, &amp;caps[&quot;day&quot;]);

#}</code></pre></pre>
<p>Regular expressions can break up strings that match a pattern, but won't check whether they make sense.
That is, you can specify and match the <em>syntax</em> of ISO-style dates, but <em>semantically</em> they may be nonsense,
like &quot;2014-24-52&quot;.</p>
<p>For this, you need dedicated date-time processing, which is provided by <a href="https://github.com/lifthrasiir/rust-chrono">chrono</a>.
You need to decide on a time zone when doing dates:</p>
<pre><pre class="playpen"><code class="language-rust">extern crate chrono;
use chrono::*;

fn main() {
    let date = Local.ymd(2010,3,14);
    println!(&quot;date was {}&quot;, date);
}
// date was 2010-03-14+02:00
</code></pre></pre>
<p>However, this isn't recommended because feeding it bad dates will cause a panic! (try a bogus date
to see this.) The method you need here is <code>ymd_opt</code> which returns <code>LocalResult&lt;Date&gt;</code></p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
# 
#fn main() {
    let date = Local.ymd_opt(2010,3,14);
    println!(&quot;date was {:?}&quot;, date);
    // date was Single(2010-03-14+02:00)

    let date = Local.ymd_opt(2014,24,52);
    println!(&quot;date was {:?}&quot;, date);
    // date was None

#}</code></pre></pre>
<p>You can also directly parse date-times, either in standard UTC format or using custom <a href="https://lifthrasiir.github.io/rust-chrono/chrono/format/strftime/index.html#specifiers">formats</a>.
These self-same formats allow you to print out dates in exactly the format you want.</p>
<p>I specifically highlighted these two useful crates because they would be part of the standard
library in most other languages. And, in fact, the embryonic form of these crates was
once part of the Rust stdlib, but were cut loose. This was a deliberate decision: the Rust team takes
stdlib stability very seriously so features only arrive in stable once they have gone through
incubation in unstable nightly versions, and only then beta and stable.  For libraries that need
experimentation and refinement, it's much better that they remain independent and get tracked
with Cargo. For all practical purposes, these two crates <em>are</em> standard - they are not going away and
may be folded back into the stdlib at some point.</p>
<a class="header" href="print.html#standard-library-containers" name="standard-library-containers"><h1>Standard Library Containers</h1></a>
<a class="header" href="print.html#reading-the-documentation" name="reading-the-documentation"><h2>Reading the Documentation</h2></a>
<p>In this section I'll briefly introduce some common parts of the Rust standard
library. The documentation is excellent but a little context and a few examples is
always useful.</p>
<p>Initially, reading the Rust documentation can be challenging, so I'll go through <code>Vec</code> as an
example.  A useful tip is to tick the '[-]' box to collapse the docs. (If you download the
standard library source using <code>rustup component add rust-src</code> a '[src]' link will appear next to this.)
This gives you a bird's eye view of all the available methods.</p>
<p>The first point to notice is that <em>not all possible methods</em> are defined on <code>Vec</code> itself. They are (mostly)
mutable methods that change the vector, e.g. <code>push</code>. Some methods are only implemented for vectors where
the type matches some constraint. For example, you can only call <code>dedup</code> (remove duplicates) if the
type is indeed something that can be compared for equality.  There are multiple <code>impl</code> blocks that
define <code>Vec</code> for different type constraints.</p>
<p>Then there's the very special relationship between <code>Vec&lt;T&gt;</code> and <code>&amp;[T]</code>.  Any method that works on
slices will also directly work on vectors, without explicitly having to use the <code>as_slice</code> method.
This relationship is expressed by <code>Deref&lt;Target=[T]&gt;</code>. This also kicks in when you pass a vector by
reference to something that expects a slice - this is one of the few places where
a conversion between types happens automatically. So slice methods like <code>first</code>, which maybe-returns
a reference to the first element, or <code>last</code>, work for vectors as well. Many of the methods are similar
to the corresponding string methods, so there's <code>split_at</code> for getting a pair of slices split at an index,
<code>starts_with</code> to check whether a vector starts with sequence of values, and <code>contains</code> to check whether
a vector contains a particular value.</p>
<p>There's no <code>search</code> method for finding the index of a particular value, but here's a rule of thumb:
if you can't find a method on the container, look for a method on the iterator:</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
# 
#fn main() {
    let v = vec![10,20,30,40,50];
    assert_eq!(v.iter().position(|&amp;i| i == 30).unwrap(), 2);

#}</code></pre></pre>
<p>(The <code>&amp;</code> is because this is an iterator over <em>references</em> - alternatively you could say <code>*i == 30</code> for
the comparison.)</p>
<p>Likewise, there's no <code>map</code> method on vectors, because <code>iter().map(...).collect()</code> will do the job
just as well. Rust does not like to allocate unnecessarily - often you don't need the result of that <code>map</code>
as an actual allocated vector.</p>
<p>So I'd suggest you become familiar with all the iterator methods, because they are crucial to writing
good Rust code without having to write loops out all the time. As always, write little programs to explore
iterator methods, rather than wrestling with them in the context of a more complicated program.</p>
<p>The <code>Vec&lt;T&gt;</code> and <code>&amp;[T]</code> methods are followed by the common traits: vectors know how to do a debug display of themselves
(but only if the elements implement <code>Debug</code>). Likewise, they are clonable if their elements are clonable.
They implement <code>Drop</code>, which happens when vectors get to finally die; memory is released,
and all the elements are dropped as well.</p>
<p>The <code>Extend</code> trait means values from iterators can be added to a vector without a loop:</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
# 
#fn main() {
v.extend([60,70,80].iter());
let mut strings = vec![&quot;hello&quot;.to_string(), &quot;dolly&quot;.to_string()];
strings.extend([&quot;you&quot;,&quot;are&quot;,&quot;fine&quot;].iter().map(|s| s.to_string()));

#}</code></pre></pre>
<p>There's also <code>FromIterator</code>, which lets vectors be <em>constructed</em> from iterators. (The iterator <code>collect</code>
method leans on this.)</p>
<p>Any container needs to be iterable as well. Recall that there are <a href="2-structs-enums-lifetimes.html#the-three-kinds-of-iterators">three kinds of iterators</a></p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
# 
#fn main() {
for x in v {...} // returns T, consumes v
for x in &amp;v {...} // returns &amp;T
for x in &amp;mut v {...} // returns &amp;mut T

#}</code></pre></pre>
<p>The <code>for</code> statement relies on the <code>IntoIterator</code> trait, and there's indeed three implementations.</p>
<p>Then there is indexing, controlled by <code>Index</code> (reading from a vector) and <code>IndexMut</code> (modifying a
vector.)  There are many possibilities, because there's slice indexing as well, like <code>v[0..2]</code>,
returning these return slices, as well as plain <code>v[0]</code> which returns a reference to the first element.</p>
<p>There's a few implementations of the <code>From</code> trait. For instance <code>Vec::from(&quot;hello&quot;.to_string())</code>
will give you a vector of the underlying bytes of the string <code>Vec&lt;u8&gt;</code>.
Now, there's already a method <code>into_bytes</code> on <code>String</code>, so why the redundancy?
It seems confusing to have multiple ways of doing the same thing.
But it's needed because explicit traits make generic methods possible.</p>
<p>Sometimes limitations of the Rust type system make things clumsy. An example here is how <code>PartialEq</code>
is <em>separately</em> defined for arrays up to size 32!  (This will get better.) This allows the convenience
of directly comparing vectors with arrays, but beware the size limit.</p>
<p>And there are <a href="http://xion.io/post/code/rust-iter-patterns.html">Hidden Gems</a> buried
deep in the documentation. As Karol Kuczmarski says &quot;Because let’s be honest: no one scrolls that far&quot;.
How does one handle errors in an iterator? Say you map over some operation that might
fail and so returns <code>Result</code>, and then want to collect the results:</p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    let nums = [&quot;5&quot;,&quot;52&quot;,&quot;65&quot;];
    let iter = nums.iter().map(|s| s.parse::&lt;i32&gt;());
    let converted: Vec&lt;_&gt; = iter.collect();
    println!(&quot;{:?}&quot;,converted);
}
//[Ok(5), Ok(52), Ok(65)]
</code></pre></pre>
<p>Fair enough, but now you have to unwrap these errors - carefully!.
But Rust already knows how to do the Right Thing,
if you ask for the vector to be <em>contained</em> in a <code>Result</code> - that is,
either is a vector or an error:</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
# 
#fn main() {
    let converted: Result&lt;Vec&lt;_&gt;,_&gt; = iter.collect();
//Ok([5, 52, 65])

#}</code></pre></pre>
<p>And if there was a bad conversion? Then you would just get <code>Err</code> with the first
error encountered. It's a good example of how extremely flexible <code>collect</code> is.
(The notation here can be intimidating - <code>Vec&lt;_&gt;</code> means &quot;this is a vector, work
out the actual type for me<code>and</code>Result&lt;Vec&lt;<em>&gt;,</em>&gt;` is furthermore asking
Rust to work out the error type as well.)</p>
<p>So there's a <em>lot</em> of detail in the documentation.
But it's certainly clearer than what the C++ docs say about <code>std::vector</code></p>
<blockquote>
<p>The requirements that are imposed on the elements depend on the actual operations performed
on the container. Generally, it is required that element type is a complete type and meets
the requirements of Erasable, but many member functions impose stricter requirements.</p>
</blockquote>
<p>With C++, you're on your own. The explicitness of Rust is daunting at first, but as you learn to
read the constraints you will know exactly what any particular method of <code>Vec</code> requires.</p>
<p>I would suggest that you get the source using <code>rustup component add rust-src</code>, since the
standard library source is very readable and the method implementations are usually less scary than the
method declarations.</p>
<a class="header" href="print.html#maps" name="maps"><h2>Maps</h2></a>
<p><em>Maps</em>  (sometimes called <em>associative arrays</em> or <em>dicts</em>) let you look up values
associated with a <em>key</em>.  It's not really a fancy concept, and can be done with
an array of tuples:</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
# 
#fn main() {
    let entries = [(&quot;one&quot;,&quot;eins&quot;),(&quot;two&quot;,&quot;zwei&quot;),(&quot;three&quot;,&quot;drei&quot;)];

    if let Some(val) = entries.iter().find(|t| t.0 == &quot;two&quot;) {
        assert_eq!(val.1,&quot;zwei&quot;);
    }

#}</code></pre></pre>
<p>This is fine for small maps and just requires equality to be defined for the keys,
but the search takes linear time - proportional to the size of the map.</p>
<p>A <code>HashMap</code> does much better when there are a <em>lot</em> of key/value pairs to be
searched:</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
# 
#fn main() {
use std::collections::HashMap;

let mut map = HashMap::new();
map.insert(&quot;one&quot;,&quot;eins&quot;);
map.insert(&quot;two&quot;,&quot;zwei&quot;);
map.insert(&quot;three&quot;,&quot;drei&quot;);

assert_eq! (map.contains_key(&quot;two&quot;), true);
assert_eq! (map.get(&quot;two&quot;), Some(&amp;&quot;zwei&quot;));

#}</code></pre></pre>
<p><code>&amp;&quot;zwei&quot;</code>? This is because <code>get</code> returns a <em>reference</em> to the value, not the value
itself. Here the value type is <code>&amp;str</code>, so we get a <code>&amp;&amp;str</code>. In general it <em>has</em> to be
a reference, because we can't just <em>move</em> a value out of its owning type.</p>
<p><code>get_mut</code> is like <code>get</code> but returns a possible mutable reference. Here we have
a map from strings to integers, and wish to update the value for the key 'two':</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
# 
#fn main() {
let mut map = HashMap::new();
map.insert(&quot;one&quot;,1);
map.insert(&quot;two&quot;,2);
map.insert(&quot;three&quot;,3);

println!(&quot;before {}&quot;, map.get(&quot;two&quot;).unwrap());

{
    let mut mref = map.get_mut(&quot;two&quot;).unwrap();
    *mref = 20;
}

println!(&quot;after {}&quot;, map.get(&quot;two&quot;).unwrap());
// before 2
// after 20

#}</code></pre></pre>
<p>Note that getting that writable reference takes place in its own block - otherwise,
we would have a mutable borrow lasting until the end, and then Rust won't allow
you to borrow from <code>map</code> again with <code>map.get(&quot;two&quot;)</code>; it cannot allow any readable
references while there's already a writable reference in scope. (If it did, it could
not guarantee that those readable references would remain valid.)
So the solution is to make
sure that mutable borrow doesn't last very long.</p>
<p>It is not the most elegant API possible, but we can't throw away any possible
errors. Python would bail out with an exception, and C++ would just create
a default value. (This is convenient but sneaky; easy to forget that the price
of <code>a_map[&quot;two&quot;]</code> always returning an integer is that we can't tell the difference
between zero and 'not found', <em>plus</em> an extra entry is created!)</p>
<p>And no-one just calls <code>unwrap</code>, except in examples. However, most Rust code you see consists
of little standalone examples!  Much more likely for a match to take place:</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
# 
#fn main() {
if let Some(v) = map.get(&quot;two&quot;) {
    let res = v + 1;
    assert_eq!(res, 3);
}
...
match map.get_mut(&quot;two&quot;) {
    Some(mref) =&gt; *mref = 20,
    None =&gt; panic!(&quot;_now_ we can panic!&quot;)
}

#}</code></pre></pre>
<p>We can iterate over the key/value pairs, but not in any particular order.</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
# 
#fn main() {
for (k,v) in map.iter() {
    println!(&quot;key {} value {}&quot;, k,v);
}
// key one value eins
// key three value drei
// key two value zwei

#}</code></pre></pre>
<p>There are also <code>keys</code> and <code>values</code> methods returning iterators over the keys and
values respectively, which makes creating vectors of values easy.</p>
<a class="header" href="print.html#example-counting-words" name="example-counting-words"><h2>Example: Counting Words</h2></a>
<p>An entertaining thing to do with text is count word frequency. It is straightforward
to break text into words with <code>split_whitespace</code>, but really we must respect punctuation.
So the words should be defined as consisting only of alphabetic characters.
And the words need to be compared as lower-case as well.</p>
<p>Doing a mutable lookup on a map is straightforward, but also handling the case where the
lookup fails is a little awkward.  Fortunately there's an elegant
way to update the values of a map:</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
# 
#fn main() {
let mut map = HashMap::new();

for s in text.split(|c: char| ! c.is_alphabetic()) {
    let word = s.to_lowercase();
    let mut count = map.entry(word).or_insert(0);
    *count += 1;
}

#}</code></pre></pre>
<p>If there's no existing count corresponding to a word, then let's create a new entry
containing zero for that word and <em>insert</em> it into the map. Its exactly what a C++
map does, except it's done explicitly and not sneakily.</p>
<p>There is exactly one explicit type in this snippet, and that's the <code>char</code> needed
because of a quirk of the string <code>Pattern</code> trait used by <code>split</code>.
But we can deduce that the key type is <code>String</code> and the value type is <code>i32</code>.</p>
<p>Using <a href="http://www.gutenberg.org/cache/epub/1661/pg1661.txt">The Adventures of Sherlock Holmes</a>
from Project Gutenberg, we can test this out
more thoroughly.  The total number of unique words (<code>map.len()</code>) is 8071.</p>
<p>How to find the twenty most common words? First, convert the map into a vector
of (key,value) tuples. (This consumes the map, since we used <code>into_iter</code>.)</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
# 
#fn main() {
let mut entries: Vec&lt;_&gt; = map.into_iter().collect();

#}</code></pre></pre>
<p>Next we can sort in descending order. <code>sort_by</code> expects the result of the <code>cmp</code>
method that comes from the <code>Ord</code> trait, which is implemented by the
integer value type:</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
# 
#fn main() {
    entries.sort_by(|a,b| b.1.cmp(&amp;a.1));

#}</code></pre></pre>
<p>And finally print out the first twenty entries:</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
# 
#fn main() {
    for e in entries.iter().take(20) {
        println!(&quot;{} {}&quot;, e.0, e.1);
    }

#}</code></pre></pre>
<p>(Well, you <em>could</em> just loop over <code>0..20</code> and index the vector here - it isn't wrong,
just a little un-idiomatic - and potentially more expensive for big iterations.)</p>
<pre><code> 38765
the 5810
and 3088
i 3038
to 2823
of 2778
a 2701
in 1823
that 1767
it 1749
you 1572
he 1486
was 1411
his 1159
is 1150
my 1007
have 929
with 877
as 863
had 830
</code></pre>
<p>A little surprise - what's that empty word? It is because <code>split</code> works on single-character
delimiters, so any punctuation or extra spaces causes a new split.</p>
<a class="header" href="print.html#sets" name="sets"><h2>Sets</h2></a>
<p>Sets are maps where you care only about the keys, not any associated values.
So <code>insert</code> only takes one value, and you use <code>contains</code> for testing whether a value
is in a set.</p>
<p>Like all containers, you can create a <code>HashSet</code> from an iterator. And this
is exactly what <code>collect</code> does, once you have given it the necessary type hint.</p>
<pre><pre class="playpen"><code class="language-rust">// set1.rs
use std::collections::HashSet;

fn make_set(words: &amp;str) -&gt; HashSet&lt;&amp;str&gt; {
    words.split_whitespace().collect()
}

fn main() {
    let fruit = make_set(&quot;apple orange pear orange&quot;);

    println!(&quot;{:?}&quot;, fruit);
}
// {&quot;orange&quot;, &quot;pear&quot;, &quot;apple&quot;}
</code></pre></pre>
<p>Note (as expected) that repeated insertions of the same key have no effect, and the order
of values in a set are not important.</p>
<p>They would not be sets without the usual operations:</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
# 
#fn main() {
let fruit = make_set(&quot;apple orange pear&quot;);
let colours = make_set(&quot;brown purple orange yellow&quot;);

for c in fruit.intersection(&amp;colours) {
    println!(&quot;{:?}&quot;,c);
}
// &quot;orange&quot;

#}</code></pre></pre>
<p>They all create iterators, and you can use <code>collect</code> to make these into sets.</p>
<p>Here's a shortcut, just as we defined for vectors:</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
# 
#fn main() {
use std::hash::Hash;

trait ToSet&lt;T&gt; {
    fn to_set(self) -&gt; HashSet&lt;T&gt;;
}

impl &lt;T,I&gt; ToSet&lt;T&gt; for I
where T: Eq + Hash, I: Iterator&lt;Item=T&gt; {

    fn to_set(self) -&gt; HashSet&lt;T&gt; {
       self.collect()
    }
}

...

let intersect = fruit.intersection(&amp;colours).to_set();

#}</code></pre></pre>
<p>As with all Rust generics, you do need to constrain types - this can only be
implemented for types that understand equality (<code>Eq</code>) and for which a 'hash function'
exists (<code>Hash</code>). Remember that there is no <em>type</em> called <code>Iterator</code>, so <code>I</code> represents
any type that <em>implements</em> <code>Iterator</code>.</p>
<p>This technique for implementing our own methods on standard library types may appear
to be a little too powerful, but again, there are Rules. We can only do this for our
own traits. If both the struct and the trait came from the same crate (particularly,
the stdlib) then such implemention would not be allowed. In this way, you are
saved from creating confusion.</p>
<p>Before congratulating ourselves on such a clever, convenient shortcut, you should be
aware of the consequences. If <code>make_set</code> was written so, so that these are sets
of owned strings, then the actual type of <code>intersect</code> could come as a surprise:</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
# 
#fn main() {
fn make_set(words: &amp;str) -&gt; HashSet&lt;String&gt; {
    words.split_whitespace().map(|s| s.to_string()).collect()
}
...
// intersect is HashSet&lt;&amp;String&gt;!
let intersect = fruit.intersection(&amp;colours).to_set();

#}</code></pre></pre>
<p>And it cannot be otherwise, since Rust will not suddenly start making copies of owned
strings. <code>intersect</code> contains a single <code>&amp;String</code> borrowed from <code>fruit</code>. I can promise
you that this will cause you trouble later, when you start patching up lifetimes!
A better solution is to use the iterator's <code>cloned</code> method to make owned string copies
of the intersection.</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
# 
#fn main() {
// intersect is HashSet&lt;String&gt; - much better
let intersect = fruit.intersection(&amp;colours).cloned().to_set();

#}</code></pre></pre>
<p>A more robust definition of <code>to_set</code> might be <code>self.cloned().collect()</code>,
which I invite you to try out.</p>
<a class="header" href="print.html#example-interactive-command-processing" name="example-interactive-command-processing"><h2>Example: Interactive command processing</h2></a>
<p>It's often useful to have an interactive session with a program. Each line is read in and
split into words; the command is looked up on the first word, and the rest of the words
are passed as an argument to that command.</p>
<p>A natural implementation is a map from command names to closures. But how do we store
closures, given that they will all have different sizes? Boxing them will copy them
onto the heap:</p>
<p>Here's a first try:</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
# 
#fn main() {
    let mut v = Vec::new();
    v.push(Box::new(|x| x * x));
    v.push(Box::new(|x| x / 2.0));

    for f in v.iter() {
        let res = f(1.0);
        println!(&quot;res {}&quot;, res);
    }

#}</code></pre></pre>
<p>We get a very definite error on the second push:</p>
<pre><code>  = note: expected type `[closure@closure4.rs:4:21: 4:28]`
  = note:    found type `[closure@closure4.rs:5:21: 5:28]`
note: no two closures, even if identical, have the same type
</code></pre>
<p><code>rustc</code> has deduced a type which is too specific, so it's necessary to force that
vector to have the <em>boxed trait type</em> before things just work:</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
# 
#fn main() {
    let mut v: Vec&lt;Box&lt;Fn(f64)-&gt;f64&gt;&gt; = Vec::new();

#}</code></pre></pre>
<p>We can now use the same trick and keep these boxed closures in a <code>HashMap</code>. We still
have to watch out for lifetimes, since closures can borrow from their environment.</p>
<p>It's tempting as first to make them <code>FnMut</code> - that is, they can modify any captured variables. But we will
have more than one command, each with its own closure, and you cannot then mutably borrow
the same variables.</p>
<p>So the closures are passed a <em>mutable reference</em> as an argument, plus
a slice of string slices (<code>&amp;[&amp;str]</code>) representing the command arguments.
They will return some <code>Result</code> - We'll use <code>String</code> errors at first.</p>
<p><code>D</code> is the data type, which can be anything with a size.</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
# 
#fn main() {
type CliResult = Result&lt;String,String&gt;;

struct Cli&lt;'a,D&gt; {
    data: D,
    callbacks: HashMap&lt;String, Box&lt;Fn(&amp;mut D,&amp;[&amp;str])-&gt;CliResult + 'a&gt;&gt;
}

impl &lt;'a,D: Sized&gt; Cli&lt;'a,D&gt; {
    fn new(data: D) -&gt; Cli&lt;'a,D&gt; {
        Cli{data: data, callbacks: HashMap::new()}
    }

    fn cmd&lt;F&gt;(&amp;mut self, name: &amp;str, callback: F)
    where F: Fn(&amp;mut D, &amp;[&amp;str])-&gt;CliResult + 'a {
        self.callbacks.insert(name.to_string(),Box::new(callback));
    }

#}</code></pre></pre>
<p><code>cmd</code> is passed a name and any closure that matches our signature, which is boxed
and entered into the map.  <code>Fn</code> means that our closures borrow their environment
but can't modify it. It's one of those generic methods where the declaration is scarier than
the actual implementation!  Forgetting the explicit lifetime is a common error
here - Rust won't let us forget that these closures have a lifetime limited to
their environment!</p>
<p>Now for reading and running commands:</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
# 
#fn main() {
    fn process(&amp;mut self,line: &amp;str) -&gt; CliResult {
        let parts: Vec&lt;_&gt; = line.split_whitespace().collect();
        if parts.len() == 0 {
            return Ok(&quot;&quot;.to_string());
        }
        match self.callbacks.get(parts[0]) {
            Some(callback) =&gt; callback(&amp;mut self.data,&amp;parts[1..]),
            None =&gt; Err(&quot;no such command&quot;.to_string())
        }
    }

    fn go(&amp;mut self) {
        let mut buff = String::new();
        while io::stdin().read_line(&amp;mut buff).expect(&quot;error&quot;) &gt; 0 {
            {
                let line = buff.trim_left();
                let res = self.process(line);
                println!(&quot;{:?}&quot;, res);

            }
            buff.clear();
        }
    }


#}</code></pre></pre>
<p>This is all reasonably straightforward - split the line into words as a vector,
look up the first word in the map and call the closure with our stored mutable
data and the rest of the words. An empty line is ignored and not considered an error.</p>
<p>Next, let's define some helper functions to make it easier for our closures to
return correct and incorrect results. There's a <em>little</em> bit of cleverness going on;
they are generic functions that work for any type that can be converted to a <code>String</code>.</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
# 
#fn main() {
fn ok&lt;T: ToString&gt;(s: T) -&gt; CliResult {
    Ok(s.to_string())
}

fn err&lt;T: ToString&gt;(s: T) -&gt; CliResult {
    Err(s.to_string())
}

#}</code></pre></pre>
<p>So finally, the Main Program. Look at how <code>ok(answer)</code> works - because
integers know how to convert themselves to strings!</p>
<pre><pre class="playpen"><code class="language-rust">use std::error::Error;

fn main() {
    println!(&quot;Welcome to the Interactive Prompt! &quot;);

    struct Data {
        answer: i32
    }

    let mut cli = Cli::new(Data{answer: 42});

    cli.cmd(&quot;go&quot;,|data,args| {
        if args.len() == 0 { return err(&quot;need 1 argument&quot;); }
        data.answer = match args[0].parse::&lt;i32&gt;() {
            Ok(n) =&gt; n,
            Err(e) =&gt; return err(e.description())
        };
        println!(&quot;got {:?}&quot;, args);
        ok(data.answer)
    });

    cli.cmd(&quot;show&quot;,|data,_| {
        ok(data.answer)
    });

    cli.go();
}
</code></pre></pre>
<p>The error handling is a bit clunky here, and we'll later see how to use the question
mark operator in cases like this.
Basically, the particular error <code>std::num::ParseIntError</code> implements
the trait <code>std::error::Error</code>, which we must bring into scope to use the <code>description</code>
method - Rust doesn't let traits operate unless they're visible.</p>
<p>And in action:</p>
<pre><code>Welcome to the Interactive Prompt!
go 32
got [&quot;32&quot;]
Ok(&quot;32&quot;)
show
Ok(&quot;32&quot;)
goop one two three
Err(&quot;no such command&quot;)
go 42 one two three
got [&quot;42&quot;, &quot;one&quot;, &quot;two&quot;, &quot;three&quot;]
Ok(&quot;42&quot;)
go boo!
Err(&quot;invalid digit found in string&quot;)
</code></pre>
<p>Here are some obvious improvements for you to try. First, if we give <code>cmd</code> three
arguments with the second being a help line, then we can store these help lines
and automatically implement a 'help' command. Second, having some command editing and
history is <em>very</em> convenient, so use the <a href="https://crates.io/crates/rustyline">rustyline</a> crate
from Cargo.</p>
<a class="header" href="print.html#error-handling" name="error-handling"><h1>Error Handling</h1></a>
<a class="header" href="print.html#basic-error-handling" name="basic-error-handling"><h2>Basic Error Handling</h2></a>
<p>Error handling in Rust can be clumsy if you can't use the question-mark operator.
To achieve happiness, we need to return a <code>Result</code> which can accept any error.
All errors implement the trait <code>std::error::Error</code>, and
so <em>any</em> error can convert into a <code>Box&lt;Error&gt;</code>.</p>
<p>Say we needed to handle <em>both</em> i/o errors and errors from converting
strings into numbers:</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
# 
#fn main() {
// box-error.rs
use std::fs::File;
use std::io::prelude::*;
use std::error::Error;

fn run(file: &amp;str) -&gt; Result&lt;i32,Box&lt;Error&gt;&gt; {
    let mut file = File::open(file)?;
    let mut contents = String::new();
    file.read_to_string(&amp;mut contents)?;
    Ok(contents.trim().parse()?)
}

#}</code></pre></pre>
<p>So that's two question-marks for the i/o errors (can't open file, or can't read as string)
and one question-mark for the conversion error. Finally, we wrap the result in <code>Ok</code>.
Rust can work out from the return type that <code>parse</code> should convert to <code>i32</code>.</p>
<p>It's easy to create a shortcut for this <code>Result</code> type:</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
# 
#fn main() {
type BoxResult&lt;T&gt; = Result&lt;T,Box&lt;Error&gt;&gt;;

#}</code></pre></pre>
<p>However, our programs will have application-specific error conditions, and so
we need to create our own error type. The basic requirements
are straightforward:</p>
<ul>
<li>May implement <code>Debug</code></li>
<li>Must implement <code>Display</code></li>
<li>Must implement <code>Error</code></li>
</ul>
<p>Otherwise, your error can do pretty much what it likes.</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
# 
#fn main() {
// error1.rs
use std::error::Error;
use std::fmt;

#[derive(Debug)]
struct MyError {
    details: String
}

impl MyError {
    fn new(msg: &amp;str) -&gt; MyError {
        MyError{details: msg.to_string()}
    }
}

impl fmt::Display for MyError {
    fn fmt(&amp;self, f: &amp;mut fmt::Formatter) -&gt; fmt::Result {
        write!(f,&quot;{}&quot;,self.details)
    }
}

impl Error for MyError {
    fn description(&amp;self) -&gt; &amp;str {
        &amp;self.details
    }
}

// a test function that returns our error result
fn raises_my_error(yes: bool) -&gt; Result&lt;(),MyError&gt; {
    if yes {
        Err(MyError::new(&quot;borked&quot;))
    } else {
        Ok(())
    }
}

#}</code></pre></pre>
<p>Typing <code>Result&lt;T,MyError&gt;</code> gets tedious and many Rust modules define their own
<code>Result</code> - e.g. <code>io::Result&lt;T&gt;</code> is short for <code>Result&lt;T,io::Error&gt;</code>.</p>
<p>In this next example we need to handle the specific error when a string can't be parsed
as a floating-point number.</p>
<p>Now the way that <code>?</code> works
is to look for a conversion from the error of the <em>expression</em> to the error that must
be <em>returned</em>.  And this conversion is expressed by the <code>From</code> trait. <code>Box&lt;Error&gt;</code>
works as it does because it implements <code>From</code> for all types implementing <code>Error</code>.</p>
<p>At this point you can continue to use the convenient alias <code>BoxResult</code> and catch everything
as before; there will be a conversion from our error into <code>Box&lt;Error&gt;</code>.
This is a good option for smaller applications. But I want to show other errors can
be explicitly made to cooperate with our error type.</p>
<p><code>ParseFloatError</code> implements <code>Error</code> so <code>description()</code> is defined.</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
# 
#fn main() {
use std::num::ParseFloatError;

impl From&lt;ParseFloatError&gt; for MyError {
    fn from(err: ParseFloatError) -&gt; Self {
        MyError::new(err.description())
    }
}

// and test!
fn parse_f64(s: &amp;str, yes: bool) -&gt; Result&lt;f64,MyError&gt; {
    raises_my_error(yes)?;
    let x: f64 = s.parse()?;
    Ok(x)
}

#}</code></pre></pre>
<p>The first <code>?</code> is fine (a type always converts to itself with <code>From</code>) and the
second <code>?</code> will convert the <code>ParseFloatError</code> to <code>MyError</code>.</p>
<p>And the results:</p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    println!(&quot; {:?}&quot;, parse_f64(&quot;42&quot;,false));
    println!(&quot; {:?}&quot;, parse_f64(&quot;42&quot;,true));
    println!(&quot; {:?}&quot;, parse_f64(&quot;?42&quot;,false));
}
//  Ok(42)
//  Err(MyError { details: &quot;borked&quot; })
//  Err(MyError { details: &quot;invalid float literal&quot; })
</code></pre></pre>
<p>Not too complicated, although a little long-winded. The tedious bit is having to
write <code>From</code> conversions for all the other error types that need to play nice
with <code>MyError</code> - or you simply lean on <code>Box&lt;Error&gt;</code>. Newcomers get confused
by the multitude of ways to do the same thing in Rust; there is always another
way to peel the avocado (or skin the cat, if you're feeling bloodthirsty). The price
of flexibility is having many options. Error-handling for a 200 line program can afford
to be simpler than for a large application. And if you ever want to package your precious
droppings as a Cargo crate, then error handling becomes crucial.</p>
<p>Currently, the question-mark operator only works for <code>Result</code>, not <code>Option</code>, and this is
a feature, not a limitation.  <code>Option</code> has a <code>ok_or_else</code> which converts itself into a <code>Result</code>.
For example, say we had a <code>HashMap</code> and must fail if a key isn't defined:</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
# 
#fn main() {
    let val = map.get(&quot;my_key&quot;).ok_or_else(|| MyError::new(&quot;my_key not defined&quot;))?;

#}</code></pre></pre>
<p>Now here the error returned is completely clear! (This form uses a closure, so the error value
is only created if the lookup fails.)</p>
<a class="header" href="print.html#simple-error-for-simple-errors" name="simple-error-for-simple-errors"><h2>simple-error for Simple Errors</h2></a>
<p>The <a href="https://docs.rs/simple-error/0.1.9/simple_error/">simple-error</a> crate provides you with
a basic error type based on a string, as we have defined it here, and a few convenient macros.
Like any error, it works fine with <code>Box&lt;Error&gt;</code>:</p>
<pre><pre class="playpen"><code class="language-rust">#[macro_use]
extern crate simple_error;

use std::error::Error;

type BoxResult&lt;T&gt; = Result&lt;T,Box&lt;Error&gt;&gt;;

fn run(s: &amp;str) -&gt; BoxResult&lt;i32&gt; {
    if s.len() == 0 {
        bail!(&quot;empty string&quot;);
    }
    Ok(s.trim().parse()?)
}

fn main() {
    println!(&quot;{:?}&quot;, run(&quot;23&quot;));
    println!(&quot;{:?}&quot;, run(&quot;2x&quot;));
    println!(&quot;{:?}&quot;, run(&quot;&quot;));
}
// Ok(23)
// Err(ParseIntError { kind: InvalidDigit })
// Err(StringError(&quot;empty string&quot;))

</code></pre></pre>
<p><code>bail!(s)</code> expands to <code>return SimpleError::new(s).into();</code> - return early with a conversion <em>into</em>
the receiving type.</p>
<p>You need to use <code>BoxResult</code> for mixing the <code>SimpleError</code> type with other errors, since
we can't implement <code>From</code> for it, since both the trait and the type come from other crates.</p>
<a class="header" href="print.html#error-chain-for-serious-errors" name="error-chain-for-serious-errors"><h2>error-chain for Serious Errors</h2></a>
<p>For non-trivial applications have a look
at the <a href="http://brson.github.io/2016/11/30/starting-with-error-chain">error_chain</a> crate.
A little macro magic can go a long way in Rust...</p>
<p>Create a binary crate with <code>cargo new --bin test-error-chain</code> and
change to this directory. Edit <code>Cargo.toml</code> and add <code>error-chain=&quot;0.8.1&quot;</code> to the end.</p>
<p>What <strong>error-chain</strong> does for you is create all the definitions we needed for manually implementing
an error type; creating a struct, and implementing the necessary traits: <code>Display</code>, <code>Debug</code> and <code>Error</code>.
It also by default implements <code>From</code> so strings can be converted into errors.</p>
<p>Our first <code>src/main.rs</code> file looks like this. All the main program does is call <code>run</code>, print out any
errors, and end the program with a non-zero exit code.  The macro <code>error_chain</code> generates all the
definitions needed, within an <code>error</code> module - in a larger program you would put this in its own file.
We need to bring everything in <code>error</code> back into global scope because our code will need to see
the generated traits. By default, there will be an <code>Error</code> struct and a <code>Result</code> defined with that
error.</p>
<p>Here we also ask for <code>From</code> to be implemented so that <code>std::io::Error</code> will convert into
our error type using <code>foreign_links</code>:</p>
<pre><pre class="playpen"><code class="language-rust">#[macro_use]
extern crate error_chain;

mod errors {
    error_chain!{
        foreign_links {
            Io(::std::io::Error);
        }
    }
}
use errors::*;

fn run() -&gt; Result&lt;()&gt; {
    use std::fs::File;

    File::open(&quot;file&quot;)?;

    Ok(())
}


fn main() {
    if let Err(e) = run() {
        println!(&quot;error: {}&quot;, e);

        std::process::exit(1);
    }
}
// error: No such file or directory (os error 2)
</code></pre></pre>
<p>The 'foreign_links' has made our life easier, since the question mark operator now knows how to
convert <code>std::io::Error</code> into our <code>error::Error</code>.  (Under the hood, the macro is creating a
<code>From&lt;std::io::Error&gt;</code> conversion, exactly as spelt out earlier.)</p>
<p>All the action happens in <code>run</code>; let's make it print out the first 10 lines of a file given as the
first program argument.  There may or may not be such an argument, which isn't necessarily an
error. Here we want to convert an <code>Option&lt;String&gt;</code> into a <code>Result&lt;String&gt;</code>. There are two <code>Option</code>
methods for doing this conversion, and I've picked the simplest one.  Our <code>Error</code> type implements
<code>From</code> for <code>&amp;str</code>, so it's straightforward to make an error with a simple text message.</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
# 
#fn main() {
fn run() -&gt; Result&lt;()&gt; {
    use std::env::args;
    use std::fs::File;
    use std::io::BufReader;
    use std::io::prelude::*;

    let file = args().skip(1).next()
        .ok_or(Error::from(&quot;provide a file&quot;))?;

    let f = File::open(&amp;file)?;
    let mut l = 0;
    for line in BufReader::new(f).lines() {
        let line = line?;
        println!(&quot;{}&quot;, line);
        l += 1;
        if l == 10 {
            break;
        }
    }

    Ok(())
}

#}</code></pre></pre>
<p>There is (again) a useful little macro <code>bail!</code> for 'throwing' errors.
An alternative to the <code>ok_or</code> method here could be:</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
# 
#fn main() {
    let file = match args().skip(1).next() {
        Some(s) =&gt; s,
        None =&gt; bail!(&quot;provide a file&quot;)
    };

#}</code></pre></pre>
<p>Like <code>?</code> it does an <em>early return</em>.</p>
<p>The returned error contains an enum <code>ErrorKind</code>, which allows us to distinguish between various
kinds of errors. There's always a variant <code>Msg</code> (when you say <code>Error::from(str)</code>) and the <code>foreign_links</code>
has declared <code>Io</code> which wraps I/O errors:</p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    if let Err(e) = run() {
        match e.kind() {
            &amp;ErrorKind::Msg(ref s) =&gt; println!(&quot;msg {}&quot;,s),
            &amp;ErrorKind::Io(ref s) =&gt; println!(&quot;io {}&quot;,s),
        }
        std::process::exit(1);
    }
}
// $ cargo run
// msg provide a file
// $ cargo run foo
// io No such file or directory (os error 2)
</code></pre></pre>
<p>It's straightforward to add new kinds of errors. Add an <code>errors</code> section to the <code>error_chain!</code> macro:</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
# 
#fn main() {
    error_chain!{
        foreign_links {
            Io(::std::io::Error);
        }

        errors {
            NoArgument(t: String) {
                display(&quot;no argument provided: '{}'&quot;, t)
            }
        }

    }

#}</code></pre></pre>
<p>This defines how <code>Display</code> works for this new kind of error. And now we can handle
'no argument' errors more specifically, feeding <code>ErrorKind::NoArgument</code> a <code>String</code> value:</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
# 
#fn main() {
    let file = args().skip(1).next()
        .ok_or(ErrorKind::NoArgument(&quot;filename needed&quot;.to_string()))?;


#}</code></pre></pre>
<p>There's now an extra <code>ErrorKind</code> variant that you must match:</p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    if let Err(e) = run() {
        println!(&quot;error {}&quot;,e);
        match e.kind() {
            &amp;ErrorKind::Msg(ref s) =&gt; println!(&quot;msg {}&quot;, s),
            &amp;ErrorKind::Io(ref s) =&gt; println!(&quot;io {}&quot;, s),
            &amp;ErrorKind::NoArgument(ref s) =&gt; println!(&quot;no argument {:?}&quot;, s),
        }
        std::process::exit(1);
    }
}
// cargo run
// error no argument provided: 'filename needed'
// no argument &quot;filename needed&quot;
</code></pre></pre>
<p>Generally, it's useful to make errors as specific as possible, <em>particularly</em> if this is a library
function! This match-on-kind technique is pretty much the equivalent of traditional exception handling,
where you match on exception types in a <code>catch</code> or <code>except</code> block.</p>
<p>In summary, <strong>error-chain</strong> creates a type <code>Error</code> for you, and defines <code>Result&lt;T&gt;</code> to be <code>std::result::Result&lt;T,Error&gt;</code>.
<code>Error</code> contains an enum <code>ErrorKind</code> and by default there is one variant <code>Msg</code> for errors created from
strings. You define external errors with <code>foreign_links</code> which does two things. First, it creates a new
<code>ErrorKind</code> variant. Second, it defines <code>From</code> on these external errors so they can be converted to our
error.  New error variants can be easily added.  A lot of irritating boilerplate code is eliminated.</p>
<a class="header" href="print.html#chaining-errors" name="chaining-errors"><h2>Chaining Errors</h2></a>
<p>But the really cool thing that this crate provides is <em>error chaining</em>.</p>
<p>As a <em>library user</em>, it's irritating when a method simply just 'throws' a generic I/O error. OK, it
could not open a file, fine, but what file? Basically, what use is this information to me?</p>
<p><code>error_chain</code> does <em>error chaining</em> which helps solve this problem of over-generic errors. When we
try to open the file, we can lazily lean on the conversion to <code>io::Error</code> using <code>?</code>, or <em>chain</em> the error.</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
# 
#fn main() {
// non-specific error
let f = File::open(&amp;file)?;

// a specific chained error
let f = File::open(&amp;file).chain_err(|| &quot;unable to read the damn file&quot;)?;

#}</code></pre></pre>
<p>Here's a new version of the program, with <em>no</em> imported 'foreign' errors, just the defaults:</p>
<pre><pre class="playpen"><code class="language-rust">#[macro_use]
extern crate error_chain;

mod errors {
    error_chain!{
    }

}
use errors::*;

fn run() -&gt; Result&lt;()&gt; {
    use std::env::args;
    use std::fs::File;
    use std::io::BufReader;
    use std::io::prelude::*;

    let file = args().skip(1).next()
        .ok_or(Error::from(&quot;filename needed&quot;))?;

    ///////// chain explicitly! ///////////
    let f = File::open(&amp;file).chain_err(|| &quot;unable to read the damn file&quot;)?;

    let mut l = 0;
    for line in BufReader::new(f).lines() {
        let line = line.chain_err(|| &quot;cannot read a line&quot;)?;
        println!(&quot;{}&quot;, line);
        l += 1;
        if l == 10 {
            break;
        }
    }

    Ok(())
}


fn main() {
    if let Err(e) = run() {
        println!(&quot;error {}&quot;, e);

        /////// look at the chain of errors... ///////
        for e in e.iter().skip(1) {
            println!(&quot;caused by: {}&quot;, e);
        }

        std::process::exit(1);
    }
}
// $ cargo run foo
// error unable to read the damn file
// caused by: No such file or directory (os error 2)
</code></pre></pre>
<p>So the <code>chain_err</code> method takes the original error, and creates a new error which contains the
original error - this can be continued indefinitely.  The closure is expected to return any
value which can be <em>converted</em> into an error.</p>
<p>Rust macros can clearly save you a lot of typing.  <code>error-chain</code> even provides a shortcut that
replaces the whole main program:</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
# 
#fn main() {
quick_main!(run);

#}</code></pre></pre>
<p>(<code>run</code> is where all the action takes place, anyway.)</p>
<a class="header" href="print.html#threads-networking-and-sharing" name="threads-networking-and-sharing"><h1>Threads, Networking and Sharing</h1></a>
<a class="header" href="print.html#changing-the-unchangeable" name="changing-the-unchangeable"><h2>Changing the Unchangeable</h2></a>
<p>If you're feeling pig-headed (as I get) you wonder if it's <em>ever</em> possible to get
around the restrictions of the borrow checker.</p>
<p>Consider the following little program, which compiles and runs without problems.</p>
<pre><pre class="playpen"><code class="language-rust">// cell.rs
use std::cell::Cell;

fn main() {
    let answer = Cell::new(42);

    assert_eq!(answer.get(), 42);

    answer.set(77);

    assert_eq!(answer.get(), 77);
}
</code></pre></pre>
<p>The answer was changed - and yet the <em>variable</em> <code>answer</code> was not mutable!</p>
<p>This is obviously perfectly safe, since the value inside the cell is only accessed
through <code>set</code> and <code>get</code>.  This goes by the grand name of <em>interior mutability</em>. The
usual is called <em>inherited mutability</em>: if I have a struct value <code>v</code>, then I can only
write to a field <code>v.a</code> if <code>v</code> itself is writeable. <code>Cell</code> values relax this rule, since
we can change the value contained within them with <code>set</code> even if the cell itself is
not mutable.</p>
<p>However, <code>Cell</code> only works with <code>Copy</code> types
(e.g primitive types and user types deriving the <code>Copy</code> trait).</p>
<p>For other values, we have to get a reference we can work on, either mutable or immutable.
This is what <code>RefCell</code> provides - you ask it explicitly for a reference to the contained
value:</p>
<pre><pre class="playpen"><code class="language-rust">// refcell.rs
use std::cell::RefCell;

fn main() {
    let greeting = RefCell::new(&quot;hello&quot;.to_string());

    assert_eq!(*greeting.borrow(), &quot;hello&quot;);
    assert_eq!(greeting.borrow().len(), 5);

    *greeting.borrow_mut() = &quot;hola&quot;.to_string();

    assert_eq!(*greeting.borrow(), &quot;hola&quot;);
}
</code></pre></pre>
<p>Again, <code>greeting</code> was not declared as mutable!</p>
<p>The explicit dereference operator <code>*</code> can be a bit confusing in Rust, because
often you don't need it - for instance <code>greeting.borrow().len()</code> is fine since method
calls will dereference implicitly.  But you <em>do</em> need <code>*</code> to pull out the underlying
<code>&amp;String</code> from <code>greeting.borrow()</code> or the <code>&amp;mut String</code> from <code>greeting.borrow_mut()</code>.</p>
<p>Using a <code>RefCell</code> isn't always safe, because any references returned from these
methods must follow the usual rules.</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
# 
#fn main() {
    let mut gr = greeting.borrow_mut(); // gr is a mutable borrow
    *gr = &quot;hola&quot;.to_string();

    assert_eq!(*greeting.borrow(), &quot;hola&quot;); // &lt;== we blow up here!
....
thread 'main' panicked at 'already mutably borrowed: BorrowError'

#}</code></pre></pre>
<p>You cannot borrow immutably if you have already borrowed mutably! Except - and this
is important - the violation of the rules happens at <em>runtime</em>.  The solution (as always)
is to keep the scope of mutable borrows as limited as possible - in this case, you could
put a block around the first two lines here so that the mutable reference <code>gr</code> gets
dropped before we borrow again.</p>
<p>So, this is not a feature you use without good reason, since you will <em>not</em> get a
compile-time error.  These types provide <em>dynamic borrowing</em> in cases where the usual
rules make some things impossible.</p>
<a class="header" href="print.html#shared-references" name="shared-references"><h2>Shared References</h2></a>
<p>Up to now, the relationship between a value and its borrowed references has been clear
and known at compile time.  The value is the owner, and the references cannot outlive it.
But many cases simply don't fit into this neat pattern. For example, say we have
a <code>Player</code> struct and a <code>Role</code> struct. A <code>Player</code> keeps a vector of references to <code>Role</code>
objects. There isn't a neat one-to-one relationship between these values, and persuading
<code>rustc</code> to cooperate becomes nasty.</p>
<p><code>Rc</code> works like <code>Box</code> - heap memory is allocated and the value is moved to it. If you
clone a <code>Box</code>, it allocates a full cloned copy of the value.  But cloning an <code>Rc</code> is
cheap, because each time you clone it just updates a <em>reference count</em> to the <em>same data</em>.
This is an old and very popular strategy for memory management,
for example it's used in the Objective C runtime on iOS/MacOS.
(In modern C++, it is implemented with <code>std::shared_ptr</code>.)</p>
<p>When a <code>Rc</code> is dropped, the reference count is decremented. When that count goes to zero
the owned value is dropped and the memory freed.</p>
<pre><pre class="playpen"><code class="language-rust">// rc1.rs
use std::rc::Rc;

fn main() {
    let s = &quot;hello dolly&quot;.to_string();
    let rs1 = Rc::new(s); // s moves to heap; ref count 1
    let rs2 = rs1.clone(); // ref count 2

    println!(&quot;len {}, {}&quot;, rs1.len(), rs2.len());
} // both rs1 and rs2 drop, string dies.
</code></pre></pre>
<p>You may make as many references as you like to the original value - it's <em>dynamic borrowing</em>
again. You do not have to carefully track the relationship between the value <code>T</code> and
its references <code>&amp;T</code>. There is some runtime cost involved, so it isn't the <em>first</em>
solution you choose, but it makes patterns of sharing possible which would fall foul
of the borrow checker.  Note that <code>Rc</code> gives you immutable shared references, since
otherwise that would break one of the very basic rules of borrowing.
A leopard can't change its spots without ceasing to be a leopard.</p>
<p>In the case of a <code>Player</code>, it can now keep its roles as a <code>Vec&lt;Rc&lt;Role&gt;&gt;</code> and things
work out fine - we can add or remove roles but not <em>change</em> them after their creation.</p>
<p>However, what if each <code>Player</code> needs to keep references to a <em>team</em> as a vector of
<code>Player</code> references? Then everything becomes immutable, because all the <code>Player</code> values
need to be stored as <code>Rc</code>!  This is the place where <code>RefCell</code> becomes necessary. The team
may be then defined as <code>Vec&lt;Rc&lt;RefCell&lt;Player&gt;&gt;&gt;</code>.  It is now possible to change
a <code>Player</code> value using <code>borrow_mut</code>, <em>provided</em> no-one has 'checked out' a reference
to a <code>Player</code> at the same time. For example, say we have a rule that if something special
happens to a player, then all of their team gets stronger:</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
# 
#fn main() {
    for p in &amp;self.team {
        p.borrow_mut().make_stronger();
    }

#}</code></pre></pre>
<p>So the application code isn't too bad, but the type signatures get a bit scary. You can
always simplify them with a <code>type</code> alias:</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
# 
#fn main() {
type PlayerRef = Rc&lt;RefCell&lt;Player&gt;&gt;;

#}</code></pre></pre>
<a class="header" href="print.html#multithreading" name="multithreading"><h2>Multithreading</h2></a>
<p>Over the last twenty years, there has been a shift away from raw processing speed
to CPUs having multiple cores. So the only way to get the most out of a modern computer
is to keep all of those cores busy. It's certainly possible to spawn child processes
in the background as we saw with <code>Command</code> but there's still a synchronization problem:
we don't know exactly when those children are finished without waiting on them.</p>
<p>There are other reasons for needing separate <em>threads of execution</em>, of course. You cannot
afford to lock up your whole process just to wait on blocking i/o, for instance.</p>
<p>Spawning threads is straightforward in Rust - you feed <code>spawn</code> a closure which is
executed in the background.</p>
<pre><pre class="playpen"><code class="language-rust">// thread1.rs
use std::thread;
use std::time;

fn main() {
    thread::spawn(|| println!(&quot;hello&quot;));
    thread::spawn(|| println!(&quot;dolly&quot;));

    println!(&quot;so fine&quot;);
    // wait a little bit
    thread::sleep(time::Duration::from_millis(100));
}
// so fine
// hello
// dolly
</code></pre></pre>
<p>Well obviously just 'wait a little bit' is not a very rigorous solution! It's better
to call <code>join</code> on the returned object - then the main thread waits for the
spawned thread to finish.</p>
<pre><pre class="playpen"><code class="language-rust">// thread2.rs
use std::thread;

fn main() {
    let t = thread::spawn(|| {
        println!(&quot;hello&quot;);
    });
    println!(&quot;wait {:?}&quot;, t.join());
}
// hello
// wait Ok(())
</code></pre></pre>
<p>Here's an interesting variation: force the new thread to panic.</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
# 
#fn main() {
    let t = thread::spawn(|| {
        println!(&quot;hello&quot;);
        panic!(&quot;I give up!&quot;);
    });
    println!(&quot;wait {:?}&quot;, t.join());

#}</code></pre></pre>
<p>We get a panic as expected, but only the panicking thread dies! We still manage
to print out the error message from the <code>join</code>. So yes, panics are not always fatal,
but threads are relatively expensive, so this should not be seen as a routine way
of handling panics.</p>
<pre><code>hello
thread '&lt;unnamed&gt;' panicked at 'I give up!', thread2.rs:7
note: Run with `RUST_BACKTRACE=1` for a backtrace.
wait Err(Any)
</code></pre>
<p>The returned objects can be used to keep track of multiple threads:</p>
<pre><pre class="playpen"><code class="language-rust">// thread4.rs
use std::thread;

fn main() {
    let mut threads = Vec::new();

    for i in 0..5 {
        let t = thread::spawn(move || {
            println!(&quot;hello {}&quot;, i);
        });
        threads.push(t);
    }

    for t in threads {
        t.join().expect(&quot;thread failed&quot;);
    }
}
// hello 0
// hello 2
// hello 4
// hello 3
// hello 1

</code></pre></pre>
<p>Rust insists that we handle the case where the join failed - i.e. that thread panicked.
(You would typically not bail out of the main program when this happens, just note the
error, retry etc)</p>
<p>There is no particular order to thread execution (this program gives different orders
for different runs), and this is key - they really are <em>independent threads of execution</em>.
Multithreading is easy; what's hard is <em>concurrency</em> - managing and synchronizing multiple
threads of execution.</p>
<a class="header" href="print.html#threads-dont-borrow" name="threads-dont-borrow"><h2>Threads Don't Borrow</h2></a>
<p>It's possible for the thread closure to capture values, but by <em>moving</em>,  not by <em>borrowing</em>!</p>
<pre><pre class="playpen"><code class="language-rust">// thread3.rs
use std::thread;

fn main() {
    let name = &quot;dolly&quot;.to_string();
    let t = thread::spawn(|| {
        println!(&quot;hello {}&quot;, name);
    });
    println!(&quot;wait {:?}&quot;, t.join());
}
</code></pre></pre>
<p>And here's the helpful error message:</p>
<pre><code>error[E0373]: closure may outlive the current function, but it borrows `name`, which is owned by the current function
 --&gt; thread3.rs:6:27
  |
6 |     let t = thread::spawn(|| {
  |                           ^^ may outlive borrowed value `name`
7 |         println!(&quot;hello {}&quot;, name);
  |                             ---- `name` is borrowed here
  |
help: to force the closure to take ownership of `name` (and any other referenced variables), use the `move` keyword, as shown:
  |     let t = thread::spawn(move || {
</code></pre>
<p>That's fair enough! Imagine spawning this thread from a function - it will exist
after the function call has finished and <code>name</code> gets dropped.  So adding <code>move</code> solves our
problem.</p>
<p>But this is a <em>move</em>, so <code>name</code> may only appear in one thread! I'd like to emphasize
that it <em>is</em> possible to share references, but they need to have <code>static</code> lifetime:</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
# 
#fn main() {
let name = &quot;dolly&quot;;
let t1 = thread::spawn(move || {
    println!(&quot;hello {}&quot;, name);
});
let t2 = thread::spawn(move || {
    println!(&quot;goodbye {}&quot;, name);
});

#}</code></pre></pre>
<p><code>name</code> exists for the whole duration of the program (<code>static</code>), so
<code>rustc</code> is satisfied that the closure will never outlive <code>name</code>. However, most interesting
references do not have <code>static</code> lifetimes!</p>
<p>Threads can't share the same environment - by <em>design</em> in Rust. In particular,
they cannot share regular references because the closures move their captured variables.</p>
<p><em>shared references</em> are fine however, because their lifetime is 'as long as needed' -
but you cannot use <code>Rc</code> for this. This is because
<code>Rc</code> is not <em>thread safe</em> - it's optimized to be fast for the non-threaded case.
Fortunately it is a compile error to use <code>Rc</code> here; the compiler is watching your
back as always.</p>
<p>For threads, you need <code>std::sync::Arc</code> - 'Arc' stands for 'Atomic Reference Counting'.
That is, it guarantees that the reference count will be modified in one logical operation.
To make this guarantee, it must ensure that the operation is locked so that only the current
thread has access. <code>clone</code> is still much cheaper than actually making a copy however.</p>
<pre><pre class="playpen"><code class="language-rust">// thread5.rs
use std::thread;
use std::sync::Arc;

struct MyString(String);

impl MyString {
    fn new(s: &amp;str) -&gt; MyString {
        MyString(s.to_string())
    }
}

fn main() {
    let mut threads = Vec::new();
    let name = Arc::new(MyString::new(&quot;dolly&quot;));

    for i in 0..5 {
        let tname = name.clone();
        let t = thread::spawn(move || {
            println!(&quot;hello {} count {}&quot;, tname.0, i);
        });
        threads.push(t);
    }

    for t in threads {
        t.join().expect(&quot;thread failed&quot;);
    }
}
</code></pre></pre>
<p>I&quot;ve deliberately created a wrapper type for <code>String</code> here (a 'newtype') since
our <code>MyString</code> does not implement <code>Clone</code>. But the <em>shared reference</em> can be cloned!</p>
<p>The shared reference <code>name</code> is passed to each new thread by making a new reference
with <code>clone</code> and moving it into the closure. It's a little verbose, but this is a safe
pattern. Safety is important in concurrency precisely because the problems are so
unpredictable. A program may run fine on your machine, but occasionally crash on the
server, usually on the weekend. Worse still, the symptoms of such problems are
not easy to diagnose.</p>
<a class="header" href="print.html#channels" name="channels"><h2>Channels</h2></a>
<p>There are ways to send data between threads. This
is done in Rust using <em>channels</em>. <code>std::sync::mpsc::channel()</code> returns a tuple consisting
of the <em>receiver</em> channel and the <em>sender</em> channel. Each thread is passed a copy
of the sender with <code>clone</code>, and calls <code>send</code>. Meanwhile the main thread calls
<code>recv</code> on the receiver.</p>
<p>'MPSC' stands for 'Multiple Producer Single Consumer'. We create multiple threads
which attempt to send to the channel, and the main thread 'consumes' the channel.</p>
<pre><pre class="playpen"><code class="language-rust">// thread9.rs
use std::thread;
use std::sync::mpsc;

fn main() {
    let nthreads = 5;
    let (tx, rx) = mpsc::channel();

    for i in 0..nthreads {
        let tx = tx.clone();
        thread::spawn(move || {
            let response = format!(&quot;hello {}&quot;, i);
            tx.send(response).unwrap();
        });
    }

    for _ in 0..nthreads {
        println!(&quot;got {:?}&quot;, rx.recv());
    }
}
// got Ok(&quot;hello 0&quot;)
// got Ok(&quot;hello 1&quot;)
// got Ok(&quot;hello 3&quot;)
// got Ok(&quot;hello 4&quot;)
// got Ok(&quot;hello 2&quot;)
</code></pre></pre>
<p>There's no need to join here since the threads send their response just before they
end execution, but obviously this can happen at any time. <code>recv</code> will block, and will
return an error if the sender channel is disconnected. <code>recv_timeout</code> will only block
for a given time period, and may return a timeout error as well.</p>
<p><code>send</code> never blocks, which is useful because threads can push out data without waiting
for the receiver to process. In addition, the channel is buffered so multiple
send operations can take place, which will be received in order.</p>
<p>However, not blocking means that <code>Ok</code> does not automatically mean 'successfully delivered message'!</p>
<p>A <code>sync_channel</code> <em>does</em> block on send. With an argument of zero, the send blocks until the
recv happens. The threads must meet up or <em>rendezvous</em> (on the sound principle that most things
sound better in French.)</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
# 
#fn main() {
    let (tx, rx) = mpsc::sync_channel(0);

    let t1 = thread::spawn(move || {
        for i in 0..5 {
            tx.send(i).unwrap();
        }
    });

    for _ in 0..5 {
        let res = rx.recv().unwrap();
        println!(&quot;{}&quot;,res);
    }
    t1.join().unwrap();

#}</code></pre></pre>
<p>We can easily cause an error here by calling <code>recv</code> when there has been no corresponding <code>send</code>, e.g
by looping <code>for i in 0..4</code>. The thread ends, and <code>tx</code> drops, and then <code>recv</code> will fail. This will also
happen if the thread panics, which causes its stack to be unwound, dropping any values.</p>
<p>If the <code>sync_channel</code> was created with a non-zero argument <code>n</code>, then it acts like a queue with a
maximum size of <code>n</code> - <code>send</code> will only block when it tries to add more than <code>n</code> values to the queue.</p>
<p>Channels are strongly typed - here the channel had type <code>i32</code> - but type inference makes this implicit.
If you need to pass different kinds of data, then enums are a good way to express this.</p>
<a class="header" href="print.html#synchronization" name="synchronization"><h2>Synchronization</h2></a>
<p>Let's look at <em>synchronization</em>. <code>join</code> is very basic, and merely waits until a
particular thread has finished.  A <code>sync_channel</code> synchronizes two threads - in the last example, the
spawned thread and the main thread are completely locked together.</p>
<p>Barrier synchronization is a checkpoint where the threads must wait until <em>all</em> of
them have reached that point. Then they can keep going as before. The barrier is
created with the number of threads that we want to wait for. As before we use use <code>Arc</code>
to share the barrier with all the threads.</p>
<pre><pre class="playpen"><code class="language-rust">// thread7.rs
use std::thread;
use std::sync::Arc;
use std::sync::Barrier;

fn main() {
    let nthreads = 5;
    let mut threads = Vec::new();
    let barrier = Arc::new(Barrier::new(nthreads));

    for i in 0..nthreads {
        let barrier = barrier.clone();
        let t = thread::spawn(move || {
            println!(&quot;before wait {}&quot;, i);
            barrier.wait();
            println!(&quot;after wait {}&quot;, i);
        });
        threads.push(t);
    }

    for t in threads {
        t.join().unwrap();
    }
}
// before wait 2
// before wait 0
// before wait 1
// before wait 3
// before wait 4
// after wait 4
// after wait 2
// after wait 3
// after wait 0
// after wait 1
</code></pre></pre>
<p>The threads do their semi-random thing, all meet up, and then continue. It's like a kind
of resumable <code>join</code> and useful when you need to farm off pieces of a job to
different threads and want to take some action when all the pieces are finished.</p>
<a class="header" href="print.html#shared-state" name="shared-state"><h2>Shared State</h2></a>
<p>How can threads <em>modify</em> shared state?</p>
<p>Recall the <code>Rc&lt;RefCell&lt;T&gt;&gt;</code> strategy for <em>dynamically</em> doing a
mutable borrow on shared references.  The threading equivalent to <code>RefCell</code> is
<code>Mutex</code> - you may get your mutable reference by calling <code>lock</code>. While this reference
exists, no other thread can access it. <code>mutex</code> stands for 'Mutual Exclusion' - we lock
a section of code so that only one thread can access it, and then unlock it. You get the
lock with the <code>lock</code> method, and it is unlocked when the reference is dropped.</p>
<pre><pre class="playpen"><code class="language-rust">// thread9.rs
use std::thread;
use std::sync::Arc;
use std::sync::Mutex;

fn main() {
    let answer = Arc::new(Mutex::new(42));

    let answer_ref = answer.clone();
    let t = thread::spawn(move || {
        let mut answer = answer_ref.lock().unwrap();
        *answer = 55;
    });

    t.join().unwrap();

    let ar = answer.lock().unwrap();
    assert_eq!(*ar, 55);

}
</code></pre></pre>
<p>This isn't so straightforward as using <code>RefCell</code> because asking for the lock on
the mutex might fail, if another thread has panicked while holding the lock.
(In this case, the documentation actually recommends just exiting the thread with <code>unwrap</code>
because things have gone seriously wrong!)</p>
<p>It's even more important to keep this mutable borrow as short as possible, because
as long as the mutex is locked, other threads are <em>blocked</em>. This is not the place for
expensive calculations! So typically such code would be used like this:</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
# 
#fn main() {
// ... do something in the thread
// get a locked reference and use it briefly!
{
    let mut data = data_ref.lock().unwrap();
    // modify data
}
//... continue with the thread

#}</code></pre></pre>
<a class="header" href="print.html#higher-level-operations" name="higher-level-operations"><h2>Higher-Level Operations</h2></a>
<p>It's better to find higher-level ways of doing threading, rather than managing the synchronization
yourself. An example is when you need to do things in parallel and collect the results. One very
cool crate is <a href="https://docs.rs/pipeliner/0.1.1/pipeliner/">pipeliner</a> which has a very straightforward
API. Here's the 'Hello, World!' - an iterator feeds us inputs and we execute up to <code>n</code> of the operations
on the values in parallel.</p>
<pre><pre class="playpen"><code class="language-rust">extern crate pipeliner;
use pipeliner::Pipeline;

fn main() {
    for result in (0..10).with_threads(4).map(|x| x + 1) {
        println!(&quot;result: {}&quot;, result);
    }
}
// result: 1
// result: 2
// result: 5
// result: 3
// result: 6
// result: 7
// result: 8
// result: 9
// result: 10
// result: 4
</code></pre></pre>
<p>It's a silly example of course, because the operation is so cheap to calculate, but shows how easy it is
to run code in parallel.</p>
<p>Here's something more useful. Doing network operations in parallel is very useful, because they can
take time, and you don't want to wait for them <em>all</em> to finish before starting to do work.</p>
<p>This example is pretty crude (believe me, there are better ways of doing it) but here we want to focus
on the principle. We reuse the <code>shell</code> function defined in section 4 to call <code>ping</code> on a range
of IP4 addresses.</p>
<pre><pre class="playpen"><code class="language-rust">extern crate pipeliner;
use pipeliner::Pipeline;

use std::process::Command;

fn shell(cmd: &amp;str) -&gt; (String,bool) {
    let cmd = format!(&quot;{} 2&gt;&amp;1&quot;,cmd);
    let output = Command::new(&quot;/bin/sh&quot;)
        .arg(&quot;-c&quot;)
        .arg(&amp;cmd)
        .output()
        .expect(&quot;no shell?&quot;);
    (
        String::from_utf8_lossy(&amp;output.stdout).trim_right().to_string(),
        output.status.success()
    )
}

fn main() {
    let addresses: Vec&lt;_&gt; = (1..40).map(|n| format!(&quot;ping -c1 192.168.0.{}&quot;,n)).collect();
    let n = addresses.len();

    for result in addresses.with_threads(n).map(|s| shell(&amp;s)) {
        if result.1 {
            println!(&quot;got: {}&quot;, result.0);
        }
    }

}
</code></pre></pre>
<p>And the result on my home network looks like this:</p>
<pre><code>got: PING 192.168.0.1 (192.168.0.1) 56(84) bytes of data.
64 bytes from 192.168.0.1: icmp_seq=1 ttl=64 time=43.2 ms

--- 192.168.0.1 ping statistics ---
1 packets transmitted, 1 received, 0% packet loss, time 0ms
rtt min/avg/max/mdev = 43.284/43.284/43.284/0.000 ms
got: PING 192.168.0.18 (192.168.0.18) 56(84) bytes of data.
64 bytes from 192.168.0.18: icmp_seq=1 ttl=64 time=0.029 ms

--- 192.168.0.18 ping statistics ---
1 packets transmitted, 1 received, 0% packet loss, time 0ms
rtt min/avg/max/mdev = 0.029/0.029/0.029/0.000 ms
got: PING 192.168.0.3 (192.168.0.3) 56(84) bytes of data.
64 bytes from 192.168.0.3: icmp_seq=1 ttl=64 time=110 ms

--- 192.168.0.3 ping statistics ---
1 packets transmitted, 1 received, 0% packet loss, time 0ms
rtt min/avg/max/mdev = 110.008/110.008/110.008/0.000 ms
got: PING 192.168.0.5 (192.168.0.5) 56(84) bytes of data.
64 bytes from 192.168.0.5: icmp_seq=1 ttl=64 time=207 ms
...
</code></pre>
<p>The active addresses come through pretty fast within the first half-second, and we then wait for the negative
results to come in. Otherwise, we would wait for the better part of a minute! You can now proceed
to scrape things like ping times from the output, although this would only work on Linux. <code>ping</code>
is universal, but the exact output format is different for each platform.  To do better we need to use
the cross-platform Rust networking API, and so let's move onto Networking.</p>
<a class="header" href="print.html#a-better-way-to-resolve-addresses" name="a-better-way-to-resolve-addresses"><h2>A Better Way to Resolve Addresses</h2></a>
<p>If you <em>just</em> want availability and not detailed ping statistics, the <code>std::net::ToSocketAddrs</code> trait
will do any DNS resolution for you:</p>
<pre><pre class="playpen"><code class="language-rust">use std::net::*;

fn main() {
    for res in &quot;google.com:80&quot;.to_socket_addrs().expect(&quot;bad&quot;) {
        println!(&quot;got {:?}&quot;, res);
    }
}
// got V4(216.58.223.14:80)
// got V6([2c0f:fb50:4002:803::200e]:80)
</code></pre></pre>
<p>It's an iterator because there is often more than one interface associated with a domain - there are
both IPV4 and IPV6 interfaces to Google.</p>
<p>So, let's naively use this method to rewrite the pipeliner example. Most networking protocols use both an
address and a port:</p>
<pre><pre class="playpen"><code class="language-rust">extern crate pipeliner;
use pipeliner::Pipeline;

use std::net::*;

fn main() {
    let addresses: Vec&lt;_&gt; = (1..40).map(|n| format!(&quot;192.168.0.{}:0&quot;,n)).collect();
    let n = addresses.len();

    for result in addresses.with_threads(n).map(|s| s.to_socket_addrs()) {
        println!(&quot;got: {:?}&quot;, result);
    }
}
// got: Ok(IntoIter([V4(192.168.0.1:0)]))
// got: Ok(IntoIter([V4(192.168.0.39:0)]))
// got: Ok(IntoIter([V4(192.168.0.2:0)]))
// got: Ok(IntoIter([V4(192.168.0.3:0)]))
// got: Ok(IntoIter([V4(192.168.0.5:0)]))
// ....
</code></pre></pre>
<p>This is much faster than the ping example because it's just checking that the IP address is valid - if we fed
it a list of actual domain names the DNS lookup could take some time, hence the importance of parallelism.</p>
<p>Suprisingly, it sort-of Just Works. The fact that everything in the standard library implements <code>Debug</code>
is great for exploration as well as debugging.  The iterator is returning <code>Result</code> (hence <code>Ok</code>) and
in that <code>Result</code> is an <code>IntoIter</code> into a <code>SocketAddr</code> which is an enum with either a ipv4 or a ipv6 address.
Why <code>IntoIter</code>? Because a socket may have multiple addresses (e.g. both ipv4 and ipv6).</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
# 
#fn main() {
    for result in addresses.with_threads(n)
        .map(|s| s.to_socket_addrs().unwrap().next().unwrap())
    {
        println!(&quot;got: {:?}&quot;, result);
    }
// got: V4(192.168.0.1:0)
// got: V4(192.168.0.39:0)
// got: V4(192.168.0.3:0)

#}</code></pre></pre>
<p>This also works, surprisingly enough, at least for our simple example. The first <code>unwrap</code> gets rid of
the <code>Result</code>, and then we explicitly pull the first value out of the iterator. The <code>Result</code> will get
bad typically when we give a nonsense address (like an address name without a port.)</p>
<a class="header" href="print.html#tcp-client-server" name="tcp-client-server"><h2>TCP Client Server</h2></a>
<p>Rust provides a straightforward interface to the most commonly used network protocol, TCP.
It is very fault-resistant and is the base on which our networked world is built - <em>packets</em> of
data are sent and received, with acknowledgement. By contrast, UDP sends packets out into the wild
without acknowledgement - there's a joke that goes &quot;I could tell you a joke about UDP but you
might not get it.&quot;
(Jokes about networking are only funny for a specialized meaning of the word 'funny')</p>
<p>However, error handling is <em>very</em> important with networking, because anything can happen, and will,
eventually.</p>
<p>TCP works as a client/server model; the server listens on a address and a particular <em>network port</em>,
and the client connects to that server. A connection is established and thereafter the client and server
can communicate with a socket.</p>
<p><code>TcpStream::connect</code> takes anything that can convert into a <code>SocketAddr</code>, in particular the plain strings
we have been using.</p>
<p>A simple TCP client in Rust is easy - a <code>TcpStream</code> struct is both readable and writeable. As usual, we
have to bring the <code>Read</code>, <code>Write</code> and other <code>std::io</code> traits into scope:</p>
<pre><pre class="playpen"><code class="language-rust">// client.rs
use std::net::TcpStream;
use std::io::prelude::*;

fn main() {
    let mut stream = TcpStream::connect(&quot;127.0.0.1:8000&quot;).expect(&quot;connection failed&quot;);

    write!(stream,&quot;hello from the client!\n&quot;).expect(&quot;write failed&quot;);
 }
</code></pre></pre>
<p>The server is not much more complicated; we set up a listener and wait for connections. When a
client connects, we get a <code>TcpStream</code> on the server side. In this
case, we read everything that the client has written into a string.</p>
<pre><pre class="playpen"><code class="language-rust">// server.rs
use std::net::TcpListener;
use std::io::prelude::*;

fn main() {

    let listener = TcpListener::bind(&quot;127.0.0.1:8000&quot;).expect(&quot;could not start server&quot;);

    // accept connections and get a TcpStream
    for connection in listener.incoming() {
        match connection {
            Ok(mut stream) =&gt; {
                let mut text = String::new();
                stream.read_to_string(&amp;mut text).expect(&quot;read failed&quot;);
                println!(&quot;got '{}'&quot;, text);
            }
            Err(e) =&gt; { println!(&quot;connection failed {}&quot;, e); }
        }
    }
}
</code></pre></pre>
<p>Here I've chosen a port number moreorless at random, but <a href="https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers">most ports</a>
are assigned some meaning.</p>
<p>Note that both parties have to agree on a protocol - the client expects it can write
text to the stream, and the server expects to read text from the stream.  If they don't play the same
game, then situations can occur where one party is blocked, waiting for bytes that never come.</p>
<p>Error checking is important - network I/O can fail for many reasons, and errors that might appear
once in a blue moon on a local filesystem can happen on a regular basis.
Someone can trip over the network cable, the other party could crash,  and so forth.
This little server isn't very robust, because it will fall over on the first read error.</p>
<p>Here is a more solid server that handles the error without failing. It also specifically reads a <em>line</em>
from the stream, which is done using <code>io::BufReader</code> to create an <code>io::BufRead</code> on which we can call
<code>read_line</code>.</p>
<pre><pre class="playpen"><code class="language-rust">// server2.rs
use std::net::{TcpListener, TcpStream};
use std::io::prelude::*;
use std::io;

fn handle_connection(stream: TcpStream) -&gt; io::Result&lt;()&gt;{
    let mut rdr = io::BufReader::new(stream);
    let mut text = String::new();
    rdr.read_line(&amp;mut text)?;
    println!(&quot;got '{}'&quot;, text.trim_right());
    Ok(())
}

fn main() {

    let listener = TcpListener::bind(&quot;127.0.0.1:8000&quot;).expect(&quot;could not start server&quot;);

    // accept connections and get a TcpStream
    for connection in listener.incoming() {
        match connection {
            Ok(stream) =&gt; {
                if let Err(e) = handle_connection(stream) {
                    println!(&quot;error {:?}&quot;, e);
                }
            }
            Err(e) =&gt; { print!(&quot;connection failed {}\n&quot;, e); }
        }
    }
}
</code></pre></pre>
<p><code>read_line</code> might fail in <code>handle_connection</code>, but the resulting error is safely handled.</p>
<p>One-way communications like this are certainly useful - for instance. a set of services across a
network which want to collect their status reports together in one central place. But it's
reasonable to expect a polite reply, even if just 'ok'!</p>
<p>A simple example is a basic 'echo' server. The client writes some text ending in a newline to the
server, and receives the same text back with a newline - the stream is readable and writeable.</p>
<pre><pre class="playpen"><code class="language-rust">// client_echo.rs
use std::io::prelude::*;
use std::net::TcpStream;

fn main() {
    let mut stream = TcpStream::connect(&quot;127.0.0.1:8000&quot;).expect(&quot;connection failed&quot;);
    let msg = &quot;hello from the client!&quot;;

    write!(stream,&quot;{}\n&quot;, msg).expect(&quot;write failed&quot;);

    let mut resp = String::new();
    stream.read_to_string(&amp;mut resp).expect(&quot;read failed&quot;);
    let text = resp.trim_right();
    assert_eq!(msg,text);
}
</code></pre></pre>
<p>The server has an interesting twist. Only <code>handle_connection</code> changes:</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
# 
#fn main() {
fn handle_connection(stream: TcpStream) -&gt; io::Result&lt;()&gt;{
    let mut ostream = stream.try_clone()?;
    let mut rdr = io::BufReader::new(stream);
    let mut text = String::new();
    rdr.read_line(&amp;mut text)?;
    ostream.write_all(text.as_bytes())?;
    Ok(())
}

#}</code></pre></pre>
<p>This is a common gotcha with simple two-way socket communication; we want to read a line, so
need to feed the readable stream to <code>BufReader</code> - but it <em>consumes</em> the stream! So we have to
clone the stream, creating a new struct which refers to the same underlying socket. Then we
have happiness.</p>
<a class="header" href="print.html#object-orientation-in-rust" name="object-orientation-in-rust"><h2>Object-Orientation in Rust</h2></a>
<p>Everyone comes from somewhere, and the chances are good that your previous programming language
implemented Object-Oriented Programming (OOP) in a particular way:</p>
<ul>
<li>'classes' act as factories for generating <em>objects</em> (often called <em>instances</em>)
and define unique types.</li>
<li>Classes may <em>inherit</em> from other classes (their <em>parents</em>), inheriting both data (<em>fields</em>)
and behaviour (<em>methods</em>)</li>
<li>If B inherits from A, then an instance of B can be passed to something expecting A
(<em>subtyping</em>)</li>
<li>An object should hide its data (<em>encapsulation</em>), which can only be operated on
with methods.</li>
</ul>
<p>Object-oriented <em>design</em> is then about identifying the classes (the 'nouns') and the methods
(the 'verbs') and then establishing relationships between them, <em>is-a</em> and <em>has-a</em>.</p>
<p>There was a point in the old Star Trek series where the doctor would say to the captain,
&quot;It's Life, Jim, just not Life as we know it&quot;. And this applies very much to Rust-flavoured
object-orientation: it comes as a shock, because Rust data aggregates (structs, enums
and tuples) are dumb. You can define methods on them, and make the data itself private,
all the usual tactics of encapsulation, but they are all <em>unrelated types</em>.
There is no subtyping and no inheritance of data (apart from the specialized
case of <code>Deref</code> coercions.)</p>
<p>The relationships between various data types in Rust are
established using <em>traits</em>.  A large part of learning Rust is understanding how the
standard library traits operate, because that's the web of meaning that glues all the
data types together.</p>
<p>Traits are interesting because there's no one-to-one correspondence between them and concepts
from mainstream languages. It depends if you're thinking dynamically or statically. In the
dynamic case, they're rather like Java or Go interfaces.</p>
<a class="header" href="print.html#trait-objects" name="trait-objects"><h3>Trait Objects</h3></a>
<p>Consider the example first used to introduce traits:</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
# 
#fn main() {
trait Show {
    fn show(&amp;self) -&gt; String;
}

impl Show for i32 {
    fn show(&amp;self) -&gt; String {
        format!(&quot;four-byte signed {}&quot;, self)
    }
}

impl Show for f64 {
    fn show(&amp;self) -&gt; String {
        format!(&quot;eight-byte float {}&quot;, self)
    }
}

#}</code></pre></pre>
<p>Here's a little program with big implications:</p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    let answer = 42;
    let maybe_pi = 3.14;
    let v: Vec&lt;&amp;Show&gt; = vec![&amp;answer,&amp;maybe_pi];
    for d in v.iter() {
        println!(&quot;show {}&quot;,d.show());
    }
}
// show four-byte signed 42
// show eight-byte float 3.14
</code></pre></pre>
<p>This is a case where Rust needs some type guidance - I specifically want a vector
of references to anything that implements <code>Show</code>.  Now note that <code>i32</code> and <code>f64</code>
have no relationship to each other, but they both understand the <code>show</code> method
because they both implement the same trait. This method is <em>virtual</em>, because
the actual method has different code for different types, and yet the correct
method is invoked based on <em>runtime</em> information. These references
are called <a href="https://doc.rust-lang.org/stable/book/trait-objects.html">trait objects</a>.</p>
<p>And <em>that</em> is how you can put objects of different types in the same vector. If
you come from a Java or Go background, you can think of <code>Show</code> as acting like an interface.</p>
<p>A little refinement of this example - we <em>box</em> the values. A box contains a reference to data
allocated on the heap, and acts very much like a reference - it's a <em>smart pointer</em>. When boxes
go out of scope and <code>Drop</code> kicks in, then that memory is released.</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
# 
#fn main() {
let answer = Box::new(42);
let maybe_pi = Box::new(3.14);

let show_list: Vec&lt;Box&lt;Show&gt;&gt; = vec![question,answer];
for d in &amp;show_list {
    println!(&quot;show {}&quot;,d.show());
}

#}</code></pre></pre>
<p>The difference is that you can now take this vector, pass it as a
reference or give it away without having to track any borrowed references.
When the vector is dropped, the boxes will be dropped, and all memory is reclaimed.</p>
<a class="header" href="print.html#animals" name="animals"><h2>Animals</h2></a>
<p>For some reason, any discussion of OOP and inheritance seems to end up talking about animals. It
makes for a nice story: &quot;See, a Cat is a Carnivore. And a Carnivore is an Animal&quot;. But I'll start
with a classic slogan from the Ruby universe: &quot;if it quacks, it's a duck&quot;. All your objects have
to do is define <code>quack</code> and they can be considered to be ducks, albeit in a very narrow way.</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
# 
#fn main() {

trait Quack {
    fn quack(&amp;self);
}

struct Duck ();

impl Quack for Duck {
    fn quack(&amp;self) {
        println!(&quot;quack!&quot;);
    }
}

struct RandomBird {
    is_a_parrot: bool
}

impl Quack for RandomBird {
    fn quack(&amp;self) {
        if ! self.is_a_parrot {
            println!(&quot;quack!&quot;);
        } else {
            println!(&quot;squawk!&quot;);
        }
    }
}

let duck1 = Duck();
let duck2 = RandomBird{is_a_parrot: false};
let parrot = RandomBird{is_a_parrot: true};

let ducks: Vec&lt;&amp;Quack&gt; = vec![&amp;duck1,&amp;duck2,&amp;parrot];

for d in &amp;ducks {
    d.quack();
}
// quack!
// quack!
// squawk!

#}</code></pre></pre>
<p>Here we have two completely different types (one is so dumb it doesn't even have data), and yes,
they all <code>quack()</code>. One is behaving a little odd (for a duck) but they share the same method name
and Rust can keep a collection of such objects in a type-safe way.</p>
<p>Type safety is a fantastic thing.  Without static typing, you could insert
a <em>cat</em> into that collection of Quackers, resulting in run-time chaos.</p>
<p>Here's a funny one:</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
# 
#fn main() {
// and why the hell not!
impl Quack for i32 {
    fn quack(&amp;self) {
        for i in 0..*self {
            print!(&quot;quack {} &quot;,i);
        }
        println!(&quot;&quot;);
    }
}

let int = 4;

let ducks: Vec&lt;&amp;Quack&gt; = vec![&amp;duck1,&amp;duck2,&amp;parrot,&amp;int];
...
// quack!
// quack!
// squawk!
// quack 0 quack 1 quack 2 quack 3

#}</code></pre></pre>
<p>What can I say? It quacks, it must be a duck. What's interesting is that you can apply your traits
to any Rust value, not just 'objects'. (Since <code>quack</code> is passed a reference, there's an explicit
dereference <code>*</code> to get the integer.)</p>
<p>However, you can only do this with a trait and a type from the same crate, so the standard library
cannot be 'monkey patched', which is another piece of Ruby folk practice (and not the most wildly
admired either.)</p>
<p>Up to this point, the trait <code>Quack</code> was behaving very much like a Java interface, and like
modern Java interfaces you can have <em>provided</em> methods which supply a default implementation
if you have implemented the <em>required</em> methods. (The <code>Iterator</code> trait is a good example.)</p>
<p>But, note that traits are not part of the <em>definition</em> of a type and you can define and implement
new traits on any type, subject to the same-crate restriction.</p>
<p>It's possible to pass a reference to any <code>Quack</code> implementor:</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
# 
#fn main() {
fn quack_ref (q: &amp;Quack) {
    q.quack();
}

quack_ref(&amp;d);

#}</code></pre></pre>
<p>And that's subtyping, Rust-style.</p>
<p>Since we're doing Programming Language Comparisons 101 here, I'll mention that Go has an interesting
take on the quacking business - if there's a Go interface <code>Quack</code>, and a type has a <code>quack</code> method,
then that type satisfies <code>Quack</code> without any need for explicit definition. This also breaks the
baked-into-definition Java model, and allows compile-time duck-typing, at the cost of some
clarity and type-safety.</p>
<p>But there is a problem with duck-typing.
One of the signs of bad OOP is too many methods which have some
generic name like <code>run</code>. &quot;If it has run(), it must be Runnable&quot; doesn't sound so catchy as
the original!  So it is possible for a Go interface to be <em>accidentally</em> valid. In Rust,
both the <code>Debug</code> and <code>Display</code> traits define <code>fmt</code> methods, but they really mean different
things.</p>
<p>So Rust traits allow traditional <em>polymorphic</em> OOP.  But what about inheritance? People usually
mean <em>implementation inheritance</em> whereas Rust does <em>interface inheritance</em>.  It's as if a Java
programmer never used <code>extend</code> and instead used <code>implements</code>. And this is actually
<a href="http://www.javaworld.com/article/2073649/core-java/why-extends-is-evil.html">recommended practice</a>
by Alan Holub. He says:</p>
<blockquote>
<p>I once attended a Java user group meeting where James Gosling (Java's inventor) was the featured
speaker. During the memorable Q&amp;A session, someone asked him: &quot;If you could do Java over again,
what would you change?&quot; &quot;I'd leave out classes,&quot; he replied. After the laughter died down,
he explained that the real problem wasn't classes per se, but rather implementation inheritance
(the extends relationship). Interface inheritance (the implements relationship) is preferable.
You should avoid implementation inheritance whenever possible</p>
</blockquote>
<p>So even in Java, you've probably been overdoing classes!</p>
<p>Implementation inheritance has some serious problems. But it does feel so very
<em>convenient</em>. There's this fat base class called <code>Animal</code> and it has loads of useful
functionality (it may even expose its innards!) which our derived class <code>Cat</code> can use. That is,
it is a form of code reuse. But code reuse is a separate concern.</p>
<p>Getting the distinction between implementation and interface inheritance is important when
understanding Rust.</p>
<p>Note that traits may have <em>provided</em> methods. Consider <code>Iterator</code> - you only <em>have</em> to override
<code>next</code>, but get a whole host of methods free.  This is similar to 'default' methods of modern
Java interfaces. Here we only define <code>name</code> and <code>upper_case</code> is defined for us. We <em>could</em>
override <code>upper_case</code> as well, but it isn't <em>required</em>.</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
# 
#fn main() {
trait Named {
    fn name(&amp;self) -&gt; String;

    fn upper_case(&amp;self) -&gt; String {
        self.name().to_uppercase()
    }
}

struct Boo();

impl Named for Boo {
    fn name(&amp;self) -&gt; String {
        &quot;boo&quot;.to_string()
    }
}

let f = Boo();

assert_eq!(f.name(),&quot;boo&quot;.to_string());
assert_eq!(f.upper_case(),&quot;BOO&quot;.to_string());

#}</code></pre></pre>
<p>This is a <em>kind</em> of code reuse, true, but note that it does not apply to the data, only the interface!</p>
<a class="header" href="print.html#ducks-and-generics" name="ducks-and-generics"><h2>Ducks and Generics</h2></a>
<p>An example of generic-friendly duck function in Rust would be this trivial one:</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
# 
#fn main() {
fn quack&lt;Q&gt; (q: &amp;Q)
where Q: Quack {
    q.quack();
}

let d = Duck();
quack(&amp;d);

#}</code></pre></pre>
<p>The type parameter is <em>any</em> type which implements <code>Quack</code>. There's an important difference
between <code>quack</code> and the <code>quack_ref</code> defined in the last section.
The body of this function is compiled for <em>each</em> of the calling
types and no virtual method is needed; such functions can be completely inlined. It
uses the trait <code>Quack</code> in a different way, as a <em>constraint</em> on generic types.</p>
<p>This is the C++ equivalent to the generic <code>quack</code> (note the <code>const</code>):</p>
<pre><code class="language-cpp">template &lt;class Q&gt;
void quack(const Q&amp; q) {
    q.quack();
}
</code></pre>
<p>Note that the type parameter is not constrained in any way.</p>
<p>This is very much compile-time duck-typing - if we pass a reference to a
non-quackable type, then the compiler will complain bitterly about no <code>quack</code> method.
At least the error is found at compile-time, but it's worse when a type is accidentally
Quackable, as happens with Go. More involved template functions and classes lead to
terrible error messages, because there are <em>no</em> constraints on the generic types.</p>
<p>You could define a function which could handle an iteration over Quacker pointers:</p>
<pre><code class="language-cpp">template &lt;class It&gt;
void quack_everyone (It start, It finish) {
    for (It i = start; i != finish; i++) {
        (*i)-&gt;quack();
    }
}
</code></pre>
<p>This would then be implemented for <em>each</em> iterator type <code>It</code>.
The Rust equivalent is a little more challenging:</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
# 
#fn main() {
fn quack_everyone &lt;I&gt; (iter: I)
where I: Iterator&lt;Item=Box&lt;Quack&gt;&gt; {
    for d in iter {
        d.quack();
    }
}

let ducks: Vec&lt;Box&lt;Quack&gt;&gt; = vec![Box::new(duck1),Box::new(duck2),Box::new(parrot),Box::new(int)];

quack_everyone(ducks.into_iter());

#}</code></pre></pre>
<p>Iterators in Rust aren't duck-typed but are types that must implement <code>Iterator</code>, and in
this case the iterator provides boxes of <code>Quack</code>.  There's no ambiguity about the types
involved, and the values must satisfy <code>Quack</code>. Often the function signature is the most challenging
thing about a generic Rust function, which is why I recommend reading
the source of the standard library - the implementation is often much simpler than the declaration!
Here the only type parameter is the actual iterator type,
which means that this will work with anything that can deliver a sequence of <code>Box&lt;Duck&gt;</code>, not just
a vector iterator.</p>
<a class="header" href="print.html#inheritance" name="inheritance"><h2>Inheritance</h2></a>
<p>A common problem with object-oriented design is trying to force things into a <em>is-a</em> relationship,
and neglecting <em>has-a</em> relationships. The <a href="https://en.wikipedia.org/wiki/Design_Patterns">GoF</a>
said &quot;Prefer Composition to Inheritance&quot; in their Design Patterns book, twenty-two years ago.</p>
<p>Here's an example: you want to model the employees of some company, and <code>Employee</code> seems a good
name for a class.  Then, Manager is-a Employee (this is true) so we start building our
hierarchy with a <code>Manager</code> subclass of <code>Employee</code>. This isn't as smart as it seems. Maybe we got
carried away with identifying important Nouns, maybe we (unconsciously) think that managers and
employees are different kinds of animals?  It's better for <code>Employee</code> to has-a <code>Roles</code> collection,
and then a manager is just an <code>Employee</code> with more responsibilities and capabilities.</p>
<p>Or consider Vehicles - ranging from bicycles to 300t ore trucks. There are multiple ways to think
about vehicles, road-worthiness (all-terrain, city, rail-bound, etc), power-source (electric,
diesel, diesel-electric, etc), cargo-or-people, and so forth.  Any fixed hierarchy of classes
you create based on one aspect ignores all other aspects. That is, there are multiple possible
classifications of vehicles!</p>
<p>Composition is more important in Rust for the obvious reason that you can't inherit functionality
in a lazy way from a base class.</p>
<p>Composition is also important because the borrow checker is smart enough
to know that borrowing different struct fields are separate borrows. You can have
a mutable borrow of one field while having an immutable borrow of another field,
and so forth. Rust cannot tell that a method only accesses one field, so the
fields should be structs with their own methods for implementation convenience.
(The <em>external</em> interface of the struct can be anything you like using suitable traits.)</p>
<p>A concrete example of 'split borrrowing' will make this clearer. We have a struct that
owns some strings, with a method for borrowing the first string mutably.</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
# 
#fn main() {
struct Foo {
    one: String,
    two: String
}

impl Foo {
    fn borrow_one_mut(&amp;mut self) -&gt; &amp;mut String {
        &amp;mut self.one
    }
    ....
}

#}</code></pre></pre>
<p>(This is an example of a Rust naming convention - such methods should end in <code>_mut</code>)</p>
<p>Now, a method for borrowing both strings, reusing the first method:</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
# 
#fn main() {
    fn borrow_both(&amp;self) -&gt; (&amp;str,&amp;str) {
        (self.borrow_one_mut(), &amp;self.two)
    }

#}</code></pre></pre>
<p>Which can't work!  We've borrrowed mutably from <code>self</code> and <em>also</em> borrowed immmutably from <code>self</code>.
If Rust allowed situations like this, then that immmutable reference can't be guaranteed not to
change.</p>
<p>The solution is simple:</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
# 
#fn main() {
    fn borrow_both(&amp;self) -&gt; (&amp;str,&amp;str) {
        (&amp;self.one, &amp;self.two)
    }

#}</code></pre></pre>
<p>And this is fine, because the borrow checker considers these to be independent borrows. So imagine
that the fields were some arbitrary types, and you can see that methods called on these fields
will not cause borrowing problems.</p>
<p>There is a restricted but very important kind of
'inheritance' with <a href="https://rust-lang.github.io/book/second-edition/ch15-02-deref.html">Deref</a>,
which is the trait for the 'dereference' operator <code>*</code>.
<code>String</code> implements <code>Deref&lt;Target=str&gt;</code> and so all the methods defined on <code>&amp;str</code> are automatically
available for <code>String</code> as well!  In a similar way, the methods of <code>Foo</code> can be directly
called on <code>Box&lt;Foo&gt;</code>.  Some find this a little ... magical, but it is tremendously convenient.
There is a simpler language inside modern Rust, but it would not be half as pleasant to use.
It really should be used for cases where there is an owned, mutable type and a simpler borrowed
type.</p>
<p>Generally in Rust there is <em>trait inheritance</em>:</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
# 
#fn main() {
trait Show {
    fn show(&amp;self) -&gt; String;
}

trait Location {
    fn location(&amp;self) -&gt; String;
}

trait ShowTell: Show + Location {}

#}</code></pre></pre>
<p>The last trait simply combines our two distinct traits into one, although it could specify
other methods.</p>
<p>Things now proceed as before:</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
# 
#fn main() {
#[derive(Debug)]
struct Foo {
    name: String,
    location: String
}

impl Foo {
    fn new(name: &amp;str, location: &amp;str) -&gt; Foo {
        Foo{
            name: name.to_string(),
            location: location.to_string()
        }
    }
}

impl Show for Foo {
    fn show(&amp;self) -&gt; String {
        self.name.clone()
    }
}

impl Location for Foo {
    fn location(&amp;self) -&gt; String {
        self.location.clone()
    }
}

impl ShowTell for Foo {}


#}</code></pre></pre>
<p>Now, if I have a value <code>foo</code> of type <code>Foo</code>, then a reference to that value will
satisfy <code>&amp;Show</code>, <code>&amp;Location</code> or <code>&amp;ShowTell</code> (which implies both.)</p>
<p>Here's a useful little macro:</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
# 
#fn main() {
macro_rules! dbg {
    ($x:expr) =&gt; {
        println!(&quot;{} = {:?}&quot;,stringify!($x),$x);
    }
}

#}</code></pre></pre>
<p>It takes one argument (represented by <code>$x</code>) which must be an 'expression'. We print out its
value, and a <em>stringified</em> version of the value. C programmers can be a <em>little</em> smug at this point,
but this means that if I passed <code>1+2</code> (an expression) then <code>stringify!(1+2)</code> is the literal
string &quot;1+2&quot;. This will save us some typing when playing with code:</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
# 
#fn main() {
let foo = Foo::new(&quot;Pete&quot;,&quot;bathroom&quot;);
dbg!(foo.show());
dbg!(foo.location());

let st: &amp;ShowTell = &amp;foo;

dbg!(st.show());
dbg!(st.location());

fn show_it_all(r: &amp;ShowTell) {
    dbg!(r.show());
    dbg!(r.location());
}

let boo = Foo::new(&quot;Alice&quot;,&quot;cupboard&quot;);
show_it_all(&amp;boo);

fn show(s: &amp;Show) {
    dbg!(s.show());
}

show(&amp;boo);

// foo.show() = &quot;Pete&quot;
// foo.location() = &quot;bathroom&quot;
// st.show() = &quot;Pete&quot;
// st.location() = &quot;bathroom&quot;
// r.show() = &quot;Alice&quot;
// r.location() = &quot;cupboard&quot;
// s.show() = &quot;Alice&quot;

#}</code></pre></pre>
<p>This <em>is</em> object-orientation, just not the kind you may be used to.</p>
<p>Please note that the <code>Show</code> reference passed to <code>show</code> can not be <em>dynamically</em>
upgraded to a <code>ShowTell</code>!  Languages with more dynamic class systems allow you to
check whether a given object is an instance of a class and then to do a
dynamic cast to that type. It isn't really a good idea in general, and specifically
cannot work in Rust because that <code>Show</code> reference has 'forgotten' that it was originally
a <code>ShowTell</code> reference.</p>
<p>You always have a choice: polymorphic, via trait objects, or monomorphic, via generics
constrainted by traits. Modern C++ and the Rust standard library tends to take the generic
route, but the polymorphic route is not obsolete. You do have to understand the different
trade-offs - generics generate the fastest code, which can be inlined. This may lead
to code bloat. But not everything needs to be as <em>fast as possible</em> - it may only happen
a 'few' times in the lifetime of a typical program run.</p>
<p>So, here's a summary:</p>
<ul>
<li>the role played by <code>class</code> is shared between data and traits</li>
<li>structs and enums are dumb, although you can define methods and do data hiding</li>
<li>a <em>limited</em> form of subtyping is possible on data using the <code>Deref</code> trait</li>
<li>traits don't have any data, but can be implemented for any type (not just structs)</li>
<li>traits can inherit from other traits</li>
<li>traits can have provided methods, allowing interface code re-use</li>
<li>traits give you both virtual methods (polymorphism) and generic constraints (monomorphism)</li>
</ul>
<a class="header" href="print.html#example-windows-api" name="example-windows-api"><h2>Example: Windows API</h2></a>
<p>One of the areas where traditional OOP is used extensively is GUI toolkits. An <code>EditControl</code> or a <code>ListWindow</code>
is-a <code>Window</code>, and so forth. This makes writing Rust bindings to GUI toolkits more difficult
than it needs to be.</p>
<p>Win32 programming can be done <a href="https://www.codeproject.com/Tips/1053658/Win-GUI-Programming-In-Rust-Language">directly</a>
in Rust, and it's a little less awkward than the original C. As soon as I graduated from C
to C++ I wanted something cleaner and did my own OOP wrapper.</p>
<p>A typical Win32 API function is <a href="https://docs.rs/user32-sys/0.0.9/i686-pc-windows-gnu/user32_sys/fn.ShowWindow.html">ShowWindow</a>
which is used to control the visibility of a window. Now, an <code>EditControl</code> has some specialized
functionality, but it's all done with a Win32 <code>HWND</code> ('handle to window') opaque value.
You would like <code>EditControl</code> to also have a <code>show</code> method, which traditionally would be done
by implementation inheritance. You <em>not</em> want to have to type out all these inherited methods
for each type! But Rust traits provide a solution. There would be a <code>Window</code> trait:</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
# 
#fn main() {
trait Window {
    // you need to define this!
    fn get_hwnd(&amp;self) -&gt; HWND;

    // and all these will be provided
    fn show(&amp;self, visible: bool) {
        unsafe {
         user32_sys::ShowWindow(self.get_hwnd(), if visible {1} else {0})
        }
    }

    // ..... oodles of methods operating on Windows

}

#}</code></pre></pre>
<p>So, the implementation struct for <code>EditControl</code> can just contain a <code>HWND</code> and implement <code>Window</code>
by defining one method; <code>EditControl</code> is a trait that inherits from <code>Window</code> and defines the extended
interface.  Something like <code>ComboxBox</code> - which behaves like an <code>EditControl</code> <em>and</em> a
<code>ListWindow</code> can be easily implemented with trait inheritance.</p>
<p>The Win32 API ('32' no longer means '32-bit' anymore) is in fact object-oriented, but an
older style, influenced by Alan Kay's definition: objects contain hidden data, and are operated
on by <em>messages</em>. So at the heart of any Windows application there's a message loop, and
the various kinds of windows (called 'window classes') implement these methods with their
own switch statements.  There is a message called <code>WM_SETTEXT</code> but the implementation can be
different: a label's text changes, but a top-level window's caption changes.</p>
<p><a href="https://gabdube.github.io/native-windows-gui/book_20.html">Here</a> is a rather promising
minimal Windows GUI framework. But to my taste, there are too many <code>unwrap</code> instances
going on - and some of them aren't even errors. This is because NWG is exploiting the
loose dynamic nature of messaging.  With a proper type-safe interface, more errors are
caught at compile-time.</p>
<p>The <a href="https://rust-lang.github.io/book/second-edition/ch17-00-oop.html">next edition</a>
of The Rust Programming Language book has a very good discussion on what 'object-oriented'
means in Rust.</p>
<a class="header" href="print.html#parsing-text-with-nom" name="parsing-text-with-nom"><h2>Parsing Text with Nom</h2></a>
<p><a href="https://github.com/Geal/nom">Nom</a>, <a href="https://docs.rs/nom">(documented here)</a> is a parser library
for Rust which is well worth the initial time investment.</p>
<p>If you have to parse a known data format, like CSV or JSON, then
it's best to use a specialized library like <a href="https://github.com/BurntSushi/rust-csv">Rust CSV</a> or
the JSON libraries discussed in <a href="4-modules.html#cargo">Section 4</a>.</p>
<p>Likewise, for configuration files
use dedicated parsers like <a href="https://docs.rs/rust-ini/0.10.0/ini/">ini</a> or
<a href="http://alexcrichton.com/toml-rs/toml/index.html">toml</a>. (The last one is particularly cool since
it integrates with the Serde framework, just as we saw with <a href="https://docs.rs/serde_json">serde_json</a>.</p>
<p>But if the text is not regular, or some made-up format, then you need to scan that text without
writing a lot of tedious string-processing code. The suggested go-to is often <a href="https://github.com/rust-lang/regex">regex</a>,
but regexes can be frustratingly opaque when sufficiently involved. Nom provides a way to parse
text which is just as powerful and can be built up by combining simpler parsers. And regexes have
their limits, for instance, don't <a href="http://stackoverflow.com/questions/1732348/regex-match-open-tags-except-xhtml-self-contained-tags">use regexes for parsing HTML</a>
but you <em>could</em> use Nom to parse HTML.  If you ever had the itch to write your own programming
language, Nom is a good place for you start on that hard road to obscurity.</p>
<p>There are some excellent tutorials for learning Nom, but I want to start at the hello-world
level to build some initial familiarity. The basic things you need to know - first, Nom is macros all the
way down, and second, Nom prefers to work with byte slices, not strings. The first means that you have to
be especially careful to get Nom expressions right, because the error messages are not going to be
friendly. And the second means that Nom can be used for <em>any</em> data format, not just text. People
have used Nom to decode binary protocols and file headers. It can also work with 'text'
in encodings other than UTF-8.</p>
<p>Recent versions of Nom work fine with string slices, although you need to use the macros that
end with <code>_s</code>.</p>
<pre><pre class="playpen"><code class="language-rust">#[macro_use]
extern crate nom;

named!(get_greeting&lt;&amp;str,&amp;str&gt;,
    tag_s!(&quot;hi&quot;)
);

fn main() {
    let res = get_greeting(&quot;hi there&quot;);
    println!(&quot;{:?}&quot;,res);
}
// Done(&quot; there&quot;, &quot;hi&quot;)

</code></pre></pre>
<p>The <code>named!</code> macro creates functions which take some input type (<code>&amp;[u8]</code> by default)
and return the second type in angle brackets.
<code>tag_s!</code> matches a literal string in the stream of characters, and its value is
a string slice representing that literal.  (If you wanted to work with <code>&amp;[u8]</code> then
use the <code>tag!</code> macro.)</p>
<p>We call the defined parser <code>get_greeting</code> with a <code>&amp;str</code> and
get back an <a href="http://rust.unhandledexpression.com/nom/enum.IResult.html">IResult</a>.
And indeed we get back the matching value.</p>
<p>Look at &quot; there&quot; - This is the string slice left over after matching..</p>
<p>We want to ignore whitespace. By just wrapping the <code>tag!</code> in <code>ws!</code> we can match &quot;hi&quot; anywhere
among spaces, tabs or newlines:</p>
<pre><pre class="playpen"><code class="language-rust">named!(get_greeting&lt;&amp;str,&amp;str&gt;,
    ws!(tag_s!(&quot;hi&quot;))
);

fn main() {
    let res = get_greeting(&quot;hi there&quot;);
    println!(&quot;{:?}&quot;,res);
}
// Done(&quot;there&quot;, &quot;hi&quot;)
</code></pre></pre>
<p>The result is &quot;hi&quot; as before, and the remaining string is &quot;there&quot;! The spaces have been skipped.</p>
<p>&quot;hi&quot; is matching nicely, although this isn't very useful yet.
Let's match <em>either</em> &quot;hi&quot; or &quot;bye&quot;. The <code>alt!</code> macro (&quot;alternate&quot;) takes parser expressions
separated by <code>|</code> and matches <em>any</em> of them. Note that you can use whitespace here to make
the parser function easier to read:</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
# 
#fn main() {
named!(get_greeting&lt;&amp;str&gt;,
    ws!(alt!(tag_s!(&quot;hi&quot;) | tag_s!(&quot;bye&quot;)))
);
println!(&quot;{:?}&quot;, get_greeting(&quot; hi &quot;));
println!(&quot;{:?}&quot;, get_greeting(&quot; bye &quot;));
println!(&quot;{:?}&quot;, get_greeting(&quot;  hola &quot;));
// Done(&quot;&quot;, &quot;hi&quot;)
// Done(&quot;&quot;, &quot;bye&quot;)
// Error(Alt)

#}</code></pre></pre>
<p>The last match failed because there is no alternative that matches &quot;hola&quot;.</p>
<p>Clearly we need to understand this <code>IResult</code> type to go further, but first let's compare this
with the regex solution:</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
# 
#fn main() {
    let greetings = Regex::new(r&quot;\s*(hi|bye)\s*&quot;).expect(&quot;bad regex&quot;);
    let caps = greetings.captures(&quot; hi &quot;).expect(&quot;match failed&quot;);
    println!(&quot;{:?}&quot;,caps);
// Captures({0: Some(&quot; hi &quot;), 1: Some(&quot;hi&quot;)})

#}</code></pre></pre>
<p>Regular expressions are certainly more <em>compact</em>!.
We needed to put '()' around the two possibilities
separated by '|' so that we will <em>capture</em> the greeting and nothing else. The first result is the
whole string, the second is the matched capture. ('|' is the so-called 'alternation' operator in
regexes, which is the motivation for the <code>alt!</code> macro syntax.)</p>
<p>But this is a very simple regex, and they get complicated very quickly. Being a text mini-language, you
have to escape significant characters like <code>*</code> and <code>(</code>. If I wanted to match &quot;(hi)&quot; or
&quot;(bye)&quot; the regex becomes &quot;\s*((hi|bye))\s*&quot; but the Nom parser simply becomes
<code>alt!(tag_s!(&quot;(hi)&quot;) | tag_s!(&quot;(bye)&quot;))</code>.</p>
<p>It's also a heavy-weight dependency. On this fairly feeble i5 laptop, Nom examples take about 0.55
seconds to compile, which is not much more than &quot;Hello world&quot;. But the regex examples take about
0.90s. And the stripped release build executable of the Nom example is about 0.3Mb (which is about
as small as statically linked Rust programs go) versus 0.8Mb for the regex example.</p>
<a class="header" href="print.html#what-a-nom-parser-returns" name="what-a-nom-parser-returns"><h2>What a Nom Parser returns</h2></a>
<p><a href="http://rust.unhandledexpression.com/nom/enum.IResult.html">IResult</a> has an interesting difference
from the standard <code>Result</code> type - there are three possibilities:</p>
<ul>
<li><code>Done</code> - success - you get both the result and the remaining bytes</li>
<li><code>Error</code> - failed to parse - you get an error</li>
<li><code>Incomplete</code> - more data needed</li>
</ul>
<p>We can write a generic <code>dump</code> function that handles any return value that can be debug-printed.
This also demonstrates the <code>to_result</code> method which returns a regular <code>Result</code> - this is probably
the method you will use for most cases since it returns either the returned value or an error.</p>
<pre><pre class="playpen"><code class="language-rust">#[macro_use]
extern crate nom;
use nom::IResult;
use std::str::from_utf8;
use std::fmt::Debug;

fn dump&lt;T: Debug&gt;(res: IResult&lt;&amp;str,T&gt;) {
    match res {
      IResult::Done(rest, value) =&gt; {println!(&quot;Done {:?} {:?}&quot;,rest,value)},
      IResult::Error(err) =&gt; {println!(&quot;Err {:?}&quot;,err)},
      IResult::Incomplete(needed) =&gt; {println!(&quot;Needed {:?}&quot;,needed)}
    }
}


fn main() {
    named!(get_greeting&lt;&amp;str,&amp;str&gt;,
        ws!(
            alt!( tag_s!(&quot;hi&quot;) | tag_s!(&quot;bye&quot;))
        )
    );

    dump(get_greeting(&quot; hi &quot;));
    dump(get_greeting(&quot; bye hi&quot;));
    dump(get_greeting(&quot;  hola &quot;));

    println!(&quot;result {:?}&quot;, get_greeting(&quot; bye  &quot;).to_result());
}
// Done Ok(&quot;&quot;) &quot;hi&quot;
// Done Ok(&quot;hi&quot;) &quot;bye&quot;
// Err Alt
// result Ok(&quot;bye&quot;)
</code></pre></pre>
<p>Parsers returning any unparsed text, and being able to indicate that they don't have enough
input characters to decide, is very useful for stream parsing. But usually <code>to_result</code> is your friend.</p>
<a class="header" href="print.html#combining-parsers" name="combining-parsers"><h2>Combining Parsers</h2></a>
<p>Let's continue the greeting example and imagine that a greeting consists of &quot;hi&quot; or &quot;bye&quot;, plus
a name. <code>nom::alpha</code> matches a series of alphabetical characters.
The <code>pair!</code> macro will collect the result of matching two parsers as a tuple:</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
# 
#fn main() {
    named!(full_greeting&lt;&amp;str,(&amp;str,&amp;str)&gt;,
        pair!(
            get_greeting,
            nom::alpha
        )
    );

    println!(&quot;result {:?}&quot;, full_greeting(&quot; hi Bob  &quot;).to_result());
// result Ok((&quot;hi&quot;, &quot;Bob&quot;))

#}</code></pre></pre>
<p>Now, further imagine that the greeter is perhaps a little shy or doesn't know anybody's name:
let us make the name optional. Naturally, the second value of the tuple becomes an <code>Option</code>.</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
# 
#fn main() {
    named!(full_greeting&lt;&amp;str, (&amp;str,Option&lt;&amp;str&gt;)&gt;,
        pair!(
            get_greeting,
            opt!(nom::alpha)
        )
    );

    println!(&quot;result {:?}&quot;, full_greeting(&quot; hi Bob  &quot;).to_result());
    println!(&quot;result {:?}&quot;, full_greeting(&quot; bye ?&quot;).to_result());
// result Ok((&quot;hi&quot;, Some(&quot;Bob&quot;)))
// result Ok((&quot;bye&quot;, None))

#}</code></pre></pre>
<p>Notice that it was straightforward to combine an existing parser for greetings with a parser
that picks up names, and then it was easy to make that name optional. This is the great power of Nom,
and it's why it's called a &quot;parser combinator library&quot;.  You can build up your complicated
parsers from simpler parsers, which you can test individually. (At this point, the equivalent
regex is starting to look like a Perl program: regexes do not combine well.)</p>
<p>However, we are not yet home and dry!  <code>full_greeting(&quot; bye &quot;)</code> will fail with an
<code>Incomplete</code> error. Nom knows that &quot;bye&quot; may be followed by a name and wants us to give it more
data. This is how a <em>streaming</em> parser needs to work, so you can feed it a file chunk by chunk,
but here we need to tell Nom that the input is complete.</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
# 
#fn main() {
    named!(full_greeting&lt;&amp;str,(&amp;str,Option&lt;&amp;str&gt;)&gt;,
        pair!(
            get_greeting,
            opt!(complete!(nom::alpha))
        )
    );

    println!(&quot;result {:?}&quot;, full_greeting(&quot; bye &quot;).to_result());
// result Ok((&quot;bye&quot;, None))

#}</code></pre></pre>
<a class="header" href="print.html#parsing-numbers" name="parsing-numbers"><h2>Parsing Numbers</h2></a>
<p>Nom provides a function <code>digit</code> which matches a series of numerical digits.
So we use <code>map!</code>, to convert the string into an integer,
and return the full <code>Result</code> type.</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
# 
#fn main() {
use nom::digit;
use std::str::FromStr;
use std::num::ParseIntError;

named!(int8 &lt;&amp;str, Result&lt;i8,ParseIntError&gt;&gt;,
    map!(digit, FromStr::from_str)
);

named!(int32 &lt;&amp;str, Result&lt;i32,ParseIntError&gt;&gt;,
    map!(digit, FromStr::from_str)
);

println!(&quot;{:?}&quot;, int8(&quot;120&quot;));
println!(&quot;{:?}&quot;, int8(&quot;1200&quot;));
println!(&quot;{:?}&quot;, int8(&quot;x120&quot;));
println!(&quot;{:?}&quot;, int32(&quot;1202&quot;));

// Done(&quot;&quot;, Ok(120))
// Done(&quot;&quot;, Err(ParseIntError { kind: Overflow }))
// Error(Digit)
// Done(&quot;&quot;, Ok(1202))

#}</code></pre></pre>
<p>So what we get is a parser <code>IResult</code> containing a conversion <code>Result</code> - and sure enough, there
is more than one way to fail here. Note that the body of our converting function has exactly
the same code; the actual conversion depends on the return type of the function.</p>
<p>Integers may have a sign. We can capture integers as a pair, where the first
value may be a sign, and the second value would be any digits following.</p>
<p>Consider:</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
# 
#fn main() {
named!(signed_digits&lt;&amp;str, (Option&lt;&amp;str&gt;,&amp;str)&gt;,
    pair!(
        opt!(alt!(tag_s!(&quot;+&quot;) | tag_s!(&quot;-&quot;))),  // maybe sign?
        digit
    )
);

println!(&quot;signed {:?}&quot;, signed_digits(&quot;4&quot;));
println!(&quot;signed {:?}&quot;, signed_digits(&quot;+12&quot;));
// signed Done(&quot;&quot;, (None, &quot;4&quot;))
// signed Done(&quot;&quot;, (Some(&quot;+&quot;), &quot;12&quot;))

#}</code></pre></pre>
<p>When we aren't interested in the intermediate results, but just want all the matching
input, then <code>recognize!</code> is what you need.</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
# 
#fn main() {
named!(maybe_signed_digits&lt;&amp;str,&amp;str&gt;,
    recognize!(signed_digits)
);

println!(&quot;signed {:?}&quot;, maybe_signed_digits(&quot;+12&quot;));
// signed Done(&quot;&quot;, &quot;+12&quot;)

#}</code></pre></pre>
<p>With this technique, we can recognize floating-point numbers. Again we map to string slice
from the byte slice over all these matches. <code>tuple!</code> is the generalization of <code>pair!</code>,
although we aren't interested in the generated tuple here. <code>complete!</code> is needed to resolve
the same problem we had with incomplete greetings - &quot;12&quot; is a valid number without the
optional floating-point part.</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
# 
#fn main() {
named!(floating_point&lt;&amp;str,&amp;str&gt;,
    recognize!(
        tuple!(
            maybe_signed_digits,
            opt!(complete!(pair!(
                tag_s!(&quot;.&quot;),
                digit
            ))),
            opt!(complete!(pair!(
                alt!(tag_s!(&quot;e&quot;) | tag_s!(&quot;E&quot;)),
                maybe_signed_digits
            )))
        )
    )
);

#}</code></pre></pre>
<p>By defining a little helper macro, we get some passing tests. The test
passes if <code>floating_point</code> matches all of the string that it is given.</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
# 
#fn main() {
macro_rules! nom_eq {
    ($p:expr,$e:expr) =&gt; (
        assert_eq!($p($e).to_result().unwrap(), $e)
    )
}

nom_eq!(floating_point, &quot;+2343&quot;);
nom_eq!(floating_point, &quot;-2343&quot;);
nom_eq!(floating_point, &quot;2343&quot;);
nom_eq!(floating_point, &quot;2343.23&quot;);
nom_eq!(floating_point, &quot;2e20&quot;);
nom_eq!(floating_point, &quot;2.0e-6&quot;);

#}</code></pre></pre>
<p>(Although sometimes macros feel a <em>little</em> dirty, making your tests pretty is a fine thing.)</p>
<p>And then we can parse and convert floating point numbers. Here I'll throw caution to the
winds and throw away the error:</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
# 
#fn main() {
    named!(float64&lt;f64&gt;,
        map_res!(floating_point, FromStr::from_str)
    );

#}</code></pre></pre>
<p>Please note how it's possible to build up complicated parsers step by step, testing each
part in isolation first. That's a strong advantage of parser combinators over regexes.
It is very much the classic programming tactic of divide-and-rule.</p>
<a class="header" href="print.html#operations-over-multiple-matches" name="operations-over-multiple-matches"><h2>Operations over Multiple Matches</h2></a>
<p>We've met <code>pairs!</code> and <code>tuple!</code> which capture a fixed number of matches as Rust tuples.</p>
<p>There is also <code>many0</code> and <code>many1</code> - they both capture indefinite numbers of matches as vectors.
The difference is that the first may capture 'zero or many' and the second 'one or many' (like the
difference between the regex <code>*</code> versus <code>+</code> modifiers.)  So <code>many1!(ws!(float64))</code> would
parse &quot;1 2 3&quot; into  <code>vec![1.0,2.0,3.0]</code>, but will fail on the empty string.</p>
<p><code>fold_many0</code> is a <em>reducing</em> operation. The match values are combined into a single value,
using a binary operator.
For instance, this is how Rust people did sums over iterators before <code>sum</code> was added; this fold
starts with an initial value (here zero) for the <em>accumulator</em> and keeps adding values to
that accumulator using <code>+</code>.</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
# 
#fn main() {
    let res = [1,2,3].iter().fold(0,|acc,v| acc + v);
    println!(&quot;{}&quot;,res);
    // 6

#}</code></pre></pre>
<p>Here's the Nom equivalent:</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
# 
#fn main() {
    named!(fold_sum&lt;&amp;str,f64&gt;,
        fold_many1!(
            ws!(float64),
            0.0,
            |acc, v| acc + v
        )
    );

    println!(&quot;fold {}&quot;, fold_sum(&quot;1 2 3&quot;).to_result().unwrap());
    //fold 6

#}</code></pre></pre>
<p>Up to now, we've had to capture every expression, or just grab all matching bytes with <code>recognize!</code>:</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
# 
#fn main() {
    named!(pointf&lt;(f64,&amp;[u8],f64)&gt;,
        tuple!(
            float64,
            tag_s!(&quot;,&quot;),
            float64
        )
    );

    println!(&quot;got {:?}&quot;, nom_res!(pointf,&quot;20,52.2&quot;).unwrap());
 //got (20, &quot;,&quot;, 52.2)

#}</code></pre></pre>
<p>For more complicated expressions, capturing the results of all the parsers leads to
rather untidy types!  We can do better.</p>
<p><code>do_parse!</code> lets you extract only the values you're interested in. The matches are separated
with <code>&gt;&gt;</code> - the matches of interest are of the form <code>name: parser</code>. Finally, there's a code
block in parentheses.</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
# 
#fn main() {
    #[derive(Debug)]
    struct Point {
        x: f64,
        y: f64
    }

    named!(pointf&lt;Point&gt;,
        do_parse!(
            first: float64 &gt;&gt;
            tag_s!(&quot;,&quot;) &gt;&gt;
            second: float64
            &gt;&gt;
            (Point{x: first, y: second})
        )
    );

    println!(&quot;got {:?}&quot;, nom_res!(pointf,&quot;20,52.2&quot;).unwrap());
// got Point { x: 20, y: 52.2 }

#}</code></pre></pre>
<p>We're not interested in that tag's value (it can only be a comma) but we assign the two float values
to temporary values which are used to build a struct. The code at the end can be any Rust
expression.</p>
<a class="header" href="print.html#parsing-arithmetic-expressions" name="parsing-arithmetic-expressions"><h2>Parsing Arithmetic Expressions</h2></a>
<p>With the necessary background established, we can do simple arithmetic expressions.
This is a good example of something that really can't be done with regexes.</p>
<p>The idea is to build up expressions from the bottom up. Expressions consist of <em>terms</em>, which are
added or subtracted. Terms consist of <em>factors</em>, which are multiplied or divided. And (for now)
factors are just floating-point numbers:</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
# 
#fn main() {
    named!(factor&lt;f64&gt;,
        ws!(float64)
    );

    named!(term&lt;&amp;str,f64&gt;, do_parse!(
        init: factor &gt;&gt;
        res: fold_many0!(
            tuple!(
                alt!(tag_s!(&quot;*&quot;) | tag_s!(&quot;/&quot;)),
                factor
            ),
            init,
            |acc, v:(_,f64)| {
                if v.0 == &quot;*&quot; {acc * v.1} else {acc / v.1}
            }
        )
        &gt;&gt; (res)
    ));

    named!(expr&lt;&amp;str,f64&gt;, do_parse!(
        init: term &gt;&gt;
        res: fold_many0!(
            tuple!(
                alt!(tag_s!(&quot;+&quot;) | tag_s!(&quot;-&quot;)),
                term
            ),
            init,
            |acc, v:(_,f64)| {
                if v.0 == &quot;+&quot; {acc + v.1} else {acc - v.1}
            }
        )
        &gt;&gt; (res)
    ));


#}</code></pre></pre>
<p>This expresses our definitions more precisely - an expression consists of at least one term, and then
zero or many plus-or-minus terms. We don't collect them, but <em>fold</em> them using the appropriate
operator. (It's one of those cases where Rust can't quite work out the type of the expression, so
we need a type hint.)  Doing it like this establishes the correct <em>operator precedence</em> - <code>*</code> always
wins over <code>+</code> and so forth.</p>
<p>We're going to need floating-point asserts here, and <a href="http://brendanzab.github.io/approx/approx/index.html">there's a crate for that</a>.</p>
<p>Add the line 'approx=&quot;0.1.1&quot; to your Cargo.toml, and away we go:</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
# 
#fn main() {
#[macro_use]
extern crate approx;
...
    assert_relative_eq!(fold_sum(&quot;1 2 3&quot;).to_result().unwrap(), 6.0);

#}</code></pre></pre>
<p>Let's define a convenient little testing macro. <code>stringify!</code> turns the expression into a string
literal which we can feed into <code>expr</code> and then compare the result with how Rust would
evaluate it.</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
# 
#fn main() {
    macro_rules! expr_eq {
        ($e:expr) =&gt; (assert_relative_eq!(
            expr(stringify!($e).to_result().unwrap(),
            $e)
        )
    }

    expr_eq!(2.3);
    expr_eq!(2.0 + 3.0 - 4.0);
    expr_eq!(2.0*3.0 - 4.0);

#}</code></pre></pre>
<p>This is very cool - a few lines to get an expression evaluator! But it gets better.
We add an alternative to numbers in the <code>factor</code> parser - expressions contained inside
parentheses:</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
# 
#fn main() {
    named!(factor&lt;&amp;str,f64&gt;,
        alt!(
            ws!(float64) |
            ws!(delimited!( tag_s!(&quot;(&quot;), expr, tag_s!(&quot;)&quot;) ))
        )
    );

    expr_eq!(2.2*(1.1 + 4.5)/3.4);
    expr_eq!((1.0 + 2.0)*(3.0 + 4.0*(5.0 + 6.0)));

#}</code></pre></pre>
<p>The coolness is that expressions are now defined <em>recursively</em> in terms of expressions!</p>
<p>The particular magic of <code>delimited!</code> is that parentheses may be nested - Nom makes sure
the brackets match up.</p>
<p>We are now way past the capabilities of regular expressions, and the stripped executable at 0.5Mb
is still half the size of a &quot;hello world&quot; regex program.</p>
<a class="header" href="print.html#pain-points" name="pain-points"><h2>Pain Points</h2></a>
<p>It is true to say that Rust is a harder language to learn than most
'mainstream' languages. There are exceptional people who don't find it so
difficult, but note the strict meaning of 'exceptional' - they are <em>exceptions</em>.
Many struggle at first, and then succeed. Initial difficulties aren't predictive
of later competency!</p>
<p>We all come from somewhere, and in the case of programming languages this
means previous exposure to mainstream languages like one of the 'dynamic'
languages like Python or one of the 'static' languages like C++. Either
way, Rust is sufficiently different to require mental retooling. Clever
people with experience jump in and are disappointed that their
cleverness is not immediately rewarded; people with less self-worth
think they aren't 'clever' enough.</p>
<p>For those with dynamic language experience (in which I would include
Java) everything is a reference, and all references are mutable by default.
And garbage collection <em>does</em> make it easier to write memory-safe
programs. A lot has gone into making the JVM pretty fast, at the cost
of memory use and predicability. Often that cost is considered worth it -
the old new idea that programmer productivity is more important than
computer performance.</p>
<p>But most computers in the world - the ones that handle really important
things like throttle control on cars - don't have the massive resources
that even a cheap laptop has, and they need to respond to events
in <em>real time</em>. Likewise, basic software infrastructure needs to be
correct, robust, and fast (the old engineering trinity). Much of this is
done in C and C++ which are inherently unsafe - the <em>total cost</em> of
this unsafety is the thing to look at here. Maybe you knock the program
together quicker, but <em>then</em> the real development starts.</p>
<p>System languages can't afford garbage collection, because they
are the bedrock on which everything rests. They allow you to be free
to waste resources as you see fit.</p>
<p>If there is no garbage collection, then memory must be managed in
other ways. Manual memory management - I grab memory, use it, and
explicitly give it back - is hard to get right. You can learn enough
C to be productive and dangerous in a few weeks - but it takes years
to become a good safe C programmer, checking every possible error condition.</p>
<p>Rust manages memory like modern C++ - as objects are destroyed, their
memory is reclaimed. You can allocate memory on the heap with <code>Box</code>, but
as soon as that box 'goes out of scope' at the end of the function, the
memory is reclaimed. So there is something like <code>new</code> but nothing like
<code>delete</code>. You create a <code>File</code> and at the end, the file handle (a precious
resource) is closed. In Rust this is called <em>dropping</em>.</p>
<p>You need to share resources - it's very inefficient to make copies of
everything - and that's where things get interesting. C++ also has
references, although Rust references are rather more like C pointers -
you need to say <code>*r</code> to refer to the value, you need to say <code>&amp;</code> to
pass a value as a reference.</p>
<p>Rust's <em>borrow checker</em> makes sure that is impossible
for a reference to exist after the original value is destroyed.</p>
<a class="header" href="print.html#type-inference" name="type-inference"><h2>Type Inference</h2></a>
<p>The distinction between 'static' and 'dynamic' isn't everything. Like with
most things, there are more dimensions in play. C is statically-typed
(every variable has a type at compile-time) but weakly-typed (e.g. <code>void*</code>
can point to <em>anything</em>); Python is dynamically-typed (the type is in
the value, not the variable) but strongly-typed. Java is static/sorta strong
(with reflection as convenient/dangerous escape valve) and Rust is
static/strong, with no runtime reflection.</p>
<p>Java is famous for needing all thoses types <em>typed out</em> in numbing detail,
Rust likes to <em>infer</em> types. This is generally a good idea, but it does
mean that you sometimes need to work out what the actual types are. You
will see <code>let n = 100</code> and wonder - what kind of integer is this? By
default, it would be <code>i32</code> - a four-byte signed integer. Everyone agrees
by now that C's unspecified integer types (like <code>int</code> and <code>long</code>) are
a bad idea; better to be explicit. You can always spell out the type,
as in <code>let n: u32 = 100</code> or let the literal force the type, as in
<code>let n = 100u32</code>.  But type inference goes much further than that!
If you declare <code>let n = 100</code> then all <code>rustc</code> knows that <code>n</code> must be
<em>some</em> integer type. If you then passed <code>n</code> to a function expecting
a <code>u64</code> then that must be the type of <code>n</code>!</p>
<p>After that, you try to pass <code>n</code> to a function expecting <code>u32</code>.
<code>rustc</code> will not let you do this, because <code>n</code> has been tied down to
<code>u64</code> and it <em>will not</em> take the easy way out and convert that
integer for you.  This is strong typing in action - there are none
of those little conversions and promotions which make your life
smoother until integer overflow bites your ass suddenly. You would have
to explicitly pass <code>n</code> as <code>n as u32</code> - a Rust typecast. Fortunately,
<code>rustc</code> is good at breaking the bad news in an 'actionable' way - that is,
you can follow the compiler's advice about fixing the problem.</p>
<p>So, Rust code can be very free of explicit types:</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
# 
#fn main() {
let mut v = Vec::new();
// v is deduced to have type Vec&lt;i32&gt;
v.push(10);
v.push(20);
v.push(&quot;hello&quot;) &lt;--- just can't do this, man!

#}</code></pre></pre>
<p>Not being able to put strings into a vector of integers is a feature,
not a bug. The flexibility of dynamic typing is also a curse.</p>
<p>(If you <em>do</em> need to put integers and strings into the same vector, then
Rust <code>enum</code> types are the way to do it safely.)</p>
<p>Sometimes you need to at least give a type <em>hint</em>. <code>collect</code> is a
fantastic iterator method, but it needs a hint. Say I have a
iterator returning <code>char</code>. Then <code>collect</code>
can swing two ways:</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
# 
#fn main() {
// a vector of char ['h','e','l','l','o']
let v: Vec&lt;_&gt; = &quot;hello&quot;.chars().collect();
// a string &quot;doy&quot;
let m: String = &quot;dolly&quot;.chars().filter(|&amp;c| c != 'l').collect();

#}</code></pre></pre>
<p>When feeling uncertain about the type of a variable, there's always this
trick, which forces <code>rustc</code> to reveal the actual type name in an
error message:</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
# 
#fn main() {
let x: () = var;

#}</code></pre></pre>
<p><code>rustc</code> may pick an over-specific type. Here we want to put different
references into a vector as <code>&amp;Debug</code> but need to declare the type
explicitly.</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
# 
#fn main() {
use std::fmt::Debug;

let answer = 42;
let message = &quot;hello&quot;;
let float = 2.7212;

let display: Vec&lt;&amp;Debug&gt; = vec![&amp;message, &amp;answer, &amp;float];

for d in display {
    println!(&quot;got {:?}&quot;, d);
}

#}</code></pre></pre>
<a class="header" href="print.html#mutable-references" name="mutable-references"><h2>Mutable References</h2></a>
<p>The rule is: only one mutable reference at a time. The reason is
that tracking mutability is hard when it can happen <em>all over the place</em>.
Not obvious in dinky little programs, but things can get bad in big
codebases.</p>
<p>The further constraint is that you can't have immutable references while
there's a mutable reference out. Otherwise, anybody who has those
references doesn't have a guarantee that they won't change. C++ also
has immutable references (e.g. <code>const string&amp;</code>) but does <em>not</em> give
you this guarantee that someone can't keep a <code>string&amp;</code> reference and modify it
behind your back.</p>
<p>This is a challenge if you are used to languages where every reference
is mutable! Unsafe, 'relaxed' languages depend on people understanding
their own programs and nobly deciding not to do Bad Things. But
big programs are written by more than one person and are beyond the
power of a single individual to understand in detail.</p>
<p>The <em>irritating</em> thing is that the borrow checker is not as smart as it
could be.</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
# 
#fn main() {
let mut m = HashMap::new();
m.insert(&quot;one&quot;, 1);
m.insert(&quot;two&quot;, 2);

if let Some(r) = m.get_mut(&quot;one&quot;) { // &lt;-- mutable borrow of m
    *r = 10;
} else {
    m.insert(&quot;one&quot;, 1); // can't borrow mutably again!
}

#}</code></pre></pre>
<p>Clearly this does not <em>really</em> violate the Rules since if we got <code>None</code> we
haven't actually borrowed anything from the map.</p>
<p>There are various ugly workarounds:</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
# 
#fn main() {
let mut found = false;
if let Some(r) = m.get_mut(&quot;one&quot;) {
    *r = 10;
    found = true;
}
if ! found {
    m.insert(&quot;one&quot;, 1);
}

#}</code></pre></pre>
<p>Which is yucky, but it works because the bothersome borrow is kept to
the first if-statement.</p>
<p>The better way here is to use <code>HashMap</code>'s <a href="https://doc.rust-lang.org/std/collections/hash_map/enum.Entry.html">entry API</a>.</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
# 
#fn main() {
use std::collections::hash_map::Entry;

match m.entry(&quot;one&quot;) {
    Entry::Occupied(e) =&gt; {
        *e.into_mut() = 10;
    },
    Entry::Vacant(e) =&gt; {
        e.insert(1);
    }
};

#}</code></pre></pre>
<p>The borrow checker will get less frustrating when <em>non-lexical lifetimes</em>
arrive sometime this year.</p>
<p>The borrow checker <em>does</em> understand some important cases, however.
If you have a struct, fields can be independently borrowed. So
composition is your friend; a big struct should contain smaller
structs, which have their own methods. Defining all the mutable methods
on the big struct will lead to a situation where you can't modify
things, even though the methods might only refer to one field.</p>
<p>With mutable data, there are special methods for treating parts of the
data independently. For instance, if you have a mutable slice, then <code>split_at_mut</code>
will split this into two mutable slices. This is perfectly safe, since Rust
knows that the slices do not overlap.</p>
<a class="header" href="print.html#references-and-lifetimes" name="references-and-lifetimes"><h2>References and Lifetimes</h2></a>
<p>Rust cannot allow a situation where a reference outlives the value. Otherwise
we would have a 'dangling reference' where it refers to a dead value -
a segfault is inevitable.</p>
<p><code>rustc</code> can often make sensible assumptions about lifetimes in functions:</p>
<pre><pre class="playpen"><code class="language-rust">fn pair(s: &amp;str, ch: char) -&gt; (&amp;str, &amp;str) {
    if let Some(idx) = s.find(ch) {
        (&amp;s[0..idx], &amp;s[idx+1..])
    } else {
        (s, &quot;&quot;)
    }
}
fn main() {
    let p = pair(&quot;hello:dolly&quot;, ':');
    println!(&quot;{:?}&quot;, p);
}
// (&quot;hello&quot;, &quot;dolly&quot;)
</code></pre></pre>
<p>This is quite safe because we cope with the case where the delimiter isn't found.
<code>rustc</code> is here assuming that both strings in the tuple are borrowed from the
string passed as an argument to the function.</p>
<p>Explicitly, the function definition looks like this:</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
# 
#fn main() {
fn pair&lt;'a&gt;(s: &amp;'a str, ch: char) -&gt; (&amp;'a str, &amp;'a str) {...}

#}</code></pre></pre>
<p>What the notation says is that the output strings live <em>at least as long</em> as the
input string. It's not saying that the lifetimes are the same, we could drop them
at any time, just that they cannot outlive <code>s</code>.</p>
<p>So, <code>rustc</code> makes common cases prettier with <em>lifetime ellision</em>.</p>
<p>Now, if that function received <em>two</em> strings, then you would need to
explicitly do lifetime annotation to tell Rust what output string is
borrowed from what input string.</p>
<p>You always need an explicit lifetime when a struct borrows a reference:</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
# 
#fn main() {
struct Container&lt;'a&gt; {
    s: &amp;'a str
}

#}</code></pre></pre>
<p>Which is again insisting that the struct cannot outlive the reference.
For both structs and functions, the lifetime needs to be declared in <code>&lt;&gt;</code>
like a type parameter.</p>
<p>Closures are very convenient and a powerful feature - a lot of the power
of Rust iterators comes from them. But if you store them, you have
to specify a lifetime. This is because basically a closure is a generated
struct that can be called, and that by default borrows its environment.
Here the <code>linear</code> closure has immutable references to <code>m</code> and <code>c</code>.</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
# 
#fn main() {
let m = 2.0;
let c = 0.5;

let linear = |x| m*x + c;
let sc = |x| m*x.cos()
...

#}</code></pre></pre>
<p>Both <code>linear</code> and <code>sc</code> implement <code>Fn(x: f64)-&gt;f64</code> but they are <em>not</em>
the same animal - they have different types and sizes!  So to store
them you have to make a <code>Box&lt;Fn(x: f64)-&gt;f64 + 'a&gt;</code>.</p>
<p>Very irritating if you're used to how fluent closures are in Javascript
or Lua, but C++ does a similar thing to Rust and needs <code>std::function</code>
to store different closures, taking a little penalty for the virtual
call.</p>
<a class="header" href="print.html#strings" name="strings"><h2>Strings</h2></a>
<p>It is common to feel irritated with Rust strings in the beginning. There are different
ways to create them, and they all feel verbose:</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
# 
#fn main() {
let s1 = &quot;hello&quot;.to_string();
let s2 = String::from(&quot;dolly&quot;);

#}</code></pre></pre>
<p>Isn't &quot;hello&quot; <em>already</em> a string? Well, in a way. <code>String</code> is an <em>owned</em> string,
allocated on the heap; a string literal &quot;hello&quot; is of type <code>&amp;str</code> (&quot;string slice&quot;)
and might be either baked into the executable (&quot;static&quot;) or borrowed from a <code>String</code>.
System languages need this distinction - consider a tiny microcontroller, which has
a little bit of RAM and rather more ROM. Literal strings will get stored in ROM
(&quot;read-only&quot;) which is both cheaper and consumes much less power.</p>
<p>But (you may say) it's so simple in C++:</p>
<pre><code class="language-C">std::string s = &quot;hello&quot;;
</code></pre>
<p>Which is shorter yes, but hides the implicit creation of a string object.
Rust likes to be explicit about memory allocations, hence <code>to_string</code>.
On the other hand, to borrow from a C++ string requires <code>c_str</code>, and
C strings are stupid.</p>
<p>Fortunately, things are better in Rust - <em>once</em> you accept that both <code>String</code> and <code>&amp;str</code>
are necessary. The methods of <code>String</code> are mostly for changing the string,
like <code>push</code> adding a char (under the hood it's very much like a <code>Vec&lt;u8&gt;</code>).
But all the methods of <code>&amp;str</code> are also available. By the same <code>Deref</code>
mechanism, a <code>String</code> can be passed as <code>&amp;str</code> to a function - which is
why you rarely see <code>&amp;String</code> in function definitions.</p>
<p>There are a number of ways to convert <code>&amp;str</code> to <code>String</code>, corresponding
to various traits. Rust needs these traits to work with types generically.
As a rule of thumb, anything that implements <code>Display</code> also knows <code>to_string</code>,
like <code>42.to_string()</code>.</p>
<p>Some operators may not behave according to intuition:</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
# 
#fn main() {
    let s1 = &quot;hello&quot;.to_string();
    let s2 = s1.clone();
    assert!(s1 == s2);  // cool
    assert!(s1 == &quot;hello&quot;); // fine
    assert!(s1 == &amp;s2); // WTF?

#}</code></pre></pre>
<p>Remember, <code>String</code> and <code>&amp;String</code> are different types, and <code>==</code> isn't
defined for that combination. This might puzzle a C++ person who is
used to references being almost interchangeable with values.
Furthermore, <code>&amp;s2</code> doesn't <em>magically</em> become a <code>&amp;str</code>, that's
a <em>deref coercion</em> which only happens when assigning to a <code>&amp;str</code>
variable or argument. (The explicit <code>s2.as_str()</code> would work.)</p>
<p>However, this more genuinely deserves a WTF:</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
# 
#fn main() {
let s3 = s1 + s2;  // &lt;--- no can do

#}</code></pre></pre>
<p>You cannot concatenate two <code>String</code> values, but you can concatenate
a <code>String</code> with a <code>&amp;str</code>.  You furthermore cannot concatenate a
<code>&amp;str</code> with a <code>String</code>. So mostly people don't use <code>+</code> and use
the <code>format!</code> macro, which is convenient but not so efficient.</p>
<p>Some string operations are available but work differently. For instance,
languages often have a <code>split</code> method for breaking up a string into an array
of strings. This method for Rust strings returns an <em>iterator</em>, which
you can <em>then</em> collect into a vector.</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
# 
#fn main() {
let parts: Vec&lt;_&gt; = s.split(',').collect();

#}</code></pre></pre>
<p>This is a bit clumsy if you are in a hurry to get a vector. But
you can do operations on the parts <em>without</em> allocating a vector!
For instance, length of largest string in the split?</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
# 
#fn main() {
let max = s.split(',').map(|s| s.len()).max().unwrap();

#}</code></pre></pre>
<p>(The <code>unwrap</code> is because an empty iterator has no maximum and we must
cover this case.)</p>
<p>The <code>collect</code> method returns a <code>Vec&lt;&amp;str&gt;</code>, where the parts are
borrowed from the original string - we only need allocate space
for the references.  There is no method like this in C++, but until
recently it would have to individually allocate each substring. (C++ 17
has <code>std::string_view</code> which behaves like a Rust string slice.)</p>
<a class="header" href="print.html#a-note-on-semicolons" name="a-note-on-semicolons"><h2>A Note on Semicolons</h2></a>
<p>Semicolons are <em>not</em> optional, but usually left out in the same places as
in C, e.g. after <code>{}</code> blocks. They also aren't needed after <code>enum</code> or
<code>struct</code> (that's a C peculiarity.)  However, if the block must have a
<em>value</em>, then the semi-colons are dropped:</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
# 
#fn main() {
    let msg = if ok {&quot;ok&quot;} else {&quot;error&quot;};

#}</code></pre></pre>
<p>Note that there must be a semi-colon after this <code>let</code> statement!</p>
<p>If there were semicolons after these string literals then the returned
value would be <code>()</code> (like <code>Nothing</code> or <code>void</code>). It's common error when
defining functions:</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
# 
#fn main() {
fn sqr(x: f64) -&gt; f64 {
    x * x;
}

#}</code></pre></pre>
<p><code>rustc</code> will give you a clear error in this case.</p>
<a class="header" href="print.html#c-specific-issues" name="c-specific-issues"><h2>C++-specific Issues</h2></a>
<a class="header" href="print.html#rust-value-semantics-are-different" name="rust-value-semantics-are-different"><h3>Rust value semantics are Different</h3></a>
<p>In C++, it's possible to define types which behave exactly like primitives
and copy themselves. In addition, a move constructor can be defined to
specify how a value can be moved out of a temporary context.</p>
<p>In Rust, primitives behave as expected, but the <code>Copy</code> trait can only
be defined if the aggregate type (struct, tuple or enum) itself contains
only copyable types. Arbitrary types may have <code>Clone</code>, but you have
to call the <code>clone</code> method on values. Rust requires any allocation
to be explicit and not hide in copy constructors or assignment operators.</p>
<p>So, copying and moving is always defined as just moving bits around and is
not overrideable.</p>
<p>If <code>s1</code> is a non <code>Copy</code> value type, then <code>s2 = s1;</code> causes a move to happen,
and this <em>consumes</em> <code>s1</code>!  So, when you really want a copy, use <code>clone</code>.</p>
<p>Borrowing is often better than copying, but then you must follow the
rules of borrowing. Fortunately, borrowing <em>is</em> an overridable behaviour.
For instance, <code>String</code> can be borrowed as <code>&amp;str</code>, and shares all the
immutable methods of <code>&amp;str</code>. <em>String slices</em> are very powerful compared
to the analogous C++ 'borrowing' operation, which is to extract a <code>const char*</code>
using <code>c_str</code>. <code>&amp;str</code> consists of a pointer to some owned bytes (or a string
literal) and a <em>size</em>. This leads to some very memory-efficient patterns.
You can have a <code>Vec&lt;&amp;str&gt;</code> where all the strings have been borrowed from
some underlying string - only space for the vector needs to be allocated:</p>
<p>For example, splitting by whitespace:</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
# 
#fn main() {
fn split_whitespace(s: &amp;str) -&gt; Vec&lt;&amp;str&gt; {
    s.split_whitespace().collect()
}

#}</code></pre></pre>
<p>Likewise, a C++ <code>s.substr(0,2)</code> call will always copy the string, but a slice
will just borrow: <code>&amp;s[0..2]</code>.</p>
<p>There is an equivalent relationship between <code>Vec&lt;T&gt;</code> and <code>&amp;[T]</code>.</p>
<a class="header" href="print.html#shared-references" name="shared-references"><h3>Shared References</h3></a>
<p>Rust has <em>smart pointers</em> like C++ - for instance, the equivalent of
<code>std::unique_ptr</code> is <code>Box</code>. There's no need for <code>delete</code>, since any
memory or other resources will be reclaimed when the box goes out of
scope (Rust very much embraces RAII).</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
# 
#fn main() {
let mut answer = Box::new(&quot;hello&quot;.to_string());
*answer = &quot;world&quot;.to_string();
answer.push('!');
println!(&quot;{} {}&quot;, answer, answer.len());

#}</code></pre></pre>
<p>People find <code>to_string</code> irritating at first, but it is <em>explicit</em>.</p>
<p>Note the explicit dererefence <code>*</code>, but methods on smart pointers
don't need any special notation (we do not say <code>(*answer).push('!')</code>)</p>
<p>Obviously, borrowing only works if there is a clearly defined owner of
the original content. In many designs this isn't possible.</p>
<p>In C++, this is where <code>std::shared_ptr</code> is used; copying just involves
modifying a reference count on the common data. This is not without
cost, however:</p>
<ul>
<li>even if the data is read-only, constantly modifying the reference
count can cause cache invalidation</li>
<li><code>std::shared_ptr</code> is designed to be thread-safe and carries locking
overhead as well</li>
</ul>
<p>In Rust, <code>std::rc::Rc</code> also acts like a shared smart pointer using
reference-counting. However, it is for immutable references only! If you
want a thread-safe variant, use <code>std::sync::Arc</code> (for 'Atomic Rc').
So Rust is being a little awkward here in providing two variants, but you
get to avoid the locking overhead for non-threaded operations.</p>
<p>These must be immutable references because that is fundamental to Rust's
memory model. However, there's a get-out card: <code>std::cell::RefCell</code>.
If you have a shared reference defined as <code>Rc&lt;RefCell&lt;T&gt;&gt;</code> then you
can mutably borrow using its <code>borrow_mut</code> method. This applies the
Rust borrowing rules <em>dynamically</em> - so e.g. any attempt to call
<code>borrow_mut</code> when a borrow was already happening will cause a panic.</p>
<p>This is still <em>safe</em>. Panics will happen
<em>before</em> any memory has been touched inappropriately! Like exceptions,
they unroll the call stack. So it's an unfortunate word for such
a structured process - it's an ordered withdrawal rather than a
panicked retreat.</p>
<p>The full <code>Rc&lt;RefCell&lt;T&gt;&gt;</code> type is clumsy, but the application code isn't
unpleasant. Here Rust (again) is prefering to be explicit.</p>
<p>If you wanted thread-safe access to shared state, then <code>Arc&lt;T&gt;</code> is the
only <em>safe</em> way to go. If you need mutable access, then <code>Arc&lt;Mutex&lt;T&gt;&gt;</code>
is the equivalent of <code>Rc&lt;RefCell&lt;T&gt;&gt;</code>. <code>Mutex</code> works a little differently
than how it's usually defined: it is a container for a value. You get
a <em>lock</em> on the value and can then modify it.</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
# 
#fn main() {
let answer = Arc::new(Mutex::new(10));

// in another thread
..
{
  let mut answer_ref = answer.lock().unwrap();
  *answer_ref = 42;
}

#}</code></pre></pre>
<p>Why the <code>unwrap</code>? If the previous holding thread panicked, then
this <code>lock</code> fails. (It's one place in the documentation where <code>unwrap</code>
is considered a reasonable thing to do, since clearly things have
gone seriously wrong. Panics can always be caught on threads.)</p>
<p>It's important (as always with mutexes) that this exclusive lock is
held for as little time as possible. So it's common for them to
happen in a limited scope - then the lock ends when the mutable
reference goes out of scope.</p>
<p>Compared with the apparently simpler situation in C++ (&quot;use shared_ptr dude&quot;)
this seems awkward. But now any <em>modifications</em> of shared state become obvious,
and the <code>Mutex</code> lock pattern forces thread safety.</p>
<p>Like everything, use shared references with <a href="https://news.ycombinator.com/item?id=11698784">caution</a>.</p>
<a class="header" href="print.html#iterators" name="iterators"><h3>Iterators</h3></a>
<p>Iterators in C++ are defined fairly informally; they involve smart pointers,
usually starting with <code>c.begin()</code> and ending with <code>c.end()</code>. Operations on
iterators are then implemented as stand-alone template functions, like <code>std::find_if</code>.</p>
<p>Rust iterators are defined by the <code>Iterator</code> trait; <code>next</code> returns an <code>Option</code> and when
the <code>Option</code> is <code>None</code> we are finished.</p>
<p>The most common operations are now methods.
Here is the equivalent of <code>find_if</code>. It returns an <code>Option</code> (case
of not finding is <code>None</code>) and here the <code>if let</code> statement is convenient for
extracting the non-<code>None</code> case:</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
# 
#fn main() {
let arr = [10, 2, 30, 5];
if let Some(res) = arr.find(|x| x == 2) {
    // res is 2
}

#}</code></pre></pre>
<a class="header" href="print.html#unsafety-and-linked-lists" name="unsafety-and-linked-lists"><h3>Unsafety and Linked Lists</h3></a>
<p>It's no secret that parts of the Rust stdlib are implemented using <code>unsafe</code>. This
does not invalidate the conservative approach of the borrow checker. Remember that
&quot;unsafe&quot; has a particular meaning - operations which Rust cannot fully verify at
compile time. From Rust's perspective, C++ operates in unsafe mode all the time!
So if a large application needs a few dozen lines of unsafe code, then that's fine,
since these few lines can be carefully checked by a human. Humans are not good at
checking 100Kloc+ of code.</p>
<p>I mention this, because there appears to be a pattern:
an experienced C++ person tries to implement a linked list or a tree structure,
and gets frustrated. Well, a double-linked list <em>is</em> possible in safe Rust,
with <code>Rc</code> references going forward, and <code>Weak</code> references going back. But the
standard library gets more performance out of using... pointers.</p>

                </div>

                <!-- Mobile navigation buttons -->
                

                

            </div>

            

            

        </div>


        <!-- Local fallback for Font Awesome -->
        <script>
            if ($(".fa").css("font-family") !== "FontAwesome") {
                $('<link rel="stylesheet" type="text/css" href="_FontAwesome/css/font-awesome.css">').prependTo('head');
            }
        </script>

        <!-- Livereload script (if served using the cli tool) -->
        

        <script src="highlight.js"></script>
        <script src="book.js"></script>
    </body>
</html>
